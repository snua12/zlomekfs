diff -urN /home/mitr/t/fuse4bsd-hg/fuse_module/fuse_dev.c fuse4bsd-hg/fuse_module/fuse_dev.c
--- /home/mitr/t/fuse4bsd-hg/fuse_module/fuse_dev.c	2007-03-30 22:59:28.000000000 +0200
+++ fuse4bsd-hg/fuse_module/fuse_dev.c	2007-04-05 03:48:48.000000000 +0200
@@ -24,9 +24,11 @@
 #include <sys/sysctl.h>
 #include <sys/poll.h>
 #include <sys/selinfo.h>
+#include <sys/vnode.h>
 
 #include "fuse.h"
 #include "fuse_session.h"
+#include "fuse_vnode.h"
 
 static __inline int fuse_ohead_audit(struct fuse_out_header *ohead,
                                      struct uio *uio);
@@ -368,7 +370,13 @@
 	ohead->error = -(ohead->error);
 
 	return (0);
-}	
+}
+
+static int (*const back_fns[])(struct fuse_data *, uint64_t nodeid) = {
+	[FUSE_BACK_INVALIDATE_METADATA] = fuse_back_invalidate_metadata,
+	[FUSE_BACK_INVALIDATE_DATA] = fuse_back_invalidate_data,
+	[FUSE_BACK_SYNC_INODE] = fuse_back_sync_inode,
+};
 
 /*
  * fusedev_write first reads the header sent by the daemon.
@@ -411,6 +419,18 @@
 	
 	data = fusedev_get_data(dev);
 
+	if (!ohead.unique) {
+		struct fuse_back_header bh;
+
+		if (uio->uio_resid != sizeof(struct fuse_back_header))
+			return (EINVAL);
+		if ((err = uiomove(&bh, sizeof(bh), uio)) != 0)
+			return (err);
+		if (bh.opcode >= sizeof(back_fns)/sizeof(back_fns[0])
+		    || back_fns[bh.opcode] == NULL)
+			return (ENOSYS);
+		return back_fns[bh.opcode](data, bh.nodeid);
+	}
 	/* Pass stuff over to callback if there is one installed */
 
 	/* Looking for ticket with the unique id of header */
@@ -443,7 +463,6 @@
 			/* pretender doesn't wanna do anything with answer */
 			DEBUG_MSG("stuff devalidated, so we drop it\n");
 			fuse_ticket_drop(tick);
-			return (err);
 		}
 	} else {
 		/* no callback at all! */
@@ -470,6 +489,13 @@
 		DEBUG_MSG("erhm, no handler for this response\n");
 	}
 
+	mtx_lock(&data->aw_mtx);
+	if (TAILQ_EMPTY(&data->aw_head)) {
+		mtx_unlock(&data->aw_mtx);
+		fuse_process_inval_queue(data);
+	} else
+		mtx_unlock(&data->aw_mtx);
+	
 	return (err);
 }
 
diff -urN /home/mitr/t/fuse4bsd-hg/fuse_module/fuse_io.c fuse4bsd-hg/fuse_module/fuse_io.c
--- /home/mitr/t/fuse4bsd-hg/fuse_module/fuse_io.c	2007-03-30 22:59:28.000000000 +0200
+++ fuse4bsd-hg/fuse_module/fuse_io.c	2007-04-04 00:42:15.000000000 +0200
@@ -66,9 +66,11 @@
 	RECTIFY_TDCR(td, cred);
 	ASSERT_VOP_LOCKED__FH(vp);
 
-	if (fufh)
+	if (fufh) {
+		VI_LOCK(vp);
 		fufh->useco++;
-	else if ((err = fuse_get_filehandle(vp, NULL, cred, flag, &fufh, NULL))) {
+		VI_UNLOCK(vp);
+	} else if ((err = fuse_get_filehandle(vp, NULL, cred, flag, &fufh, NULL))) {
 		DEBUG2G("no filehandle for vnode #%llu\n", VTOILLU(vp));
 		return (err);
 	}
@@ -120,9 +122,11 @@
 		panic("uninterpreted mode passed to fuse_io_dispatch");
 	}
 
-	if (VTOFUD(vp))
+	if (VTOFUD(vp)) {
+		VI_LOCK(vp);
 		fufh->useco--;
-	else
+		VI_UNLOCK(vp);
+	} else
 		DEBUG2G("poor nasty nasty vnode %p...\n", vp);
 	fuse_invalidate_attr(vp);
 
@@ -802,7 +806,9 @@
 #endif
 	if (fufh) {
 		DEBUG2G("we have a useable filehandle passed on\n");
+		VI_LOCK(vp);
 		fufh->useco++;
+		VI_UNLOCK(vp);
 	} else
 		err = fuse_get_filehandle(vp, NULL, cred,
 	                             bp->b_iocmd == BIO_READ ? FREAD : FWRITE,
@@ -925,8 +931,11 @@
 		DEBUG("no ticket on leave\n");
 
 out:
-	if (fufh)
+	if (fufh) {
+		VI_LOCK(vp);
 		fufh->useco--;
+		VI_UNLOCK(vp);
+	}
 
 	if (err) {
 		bp->b_ioflags |= BIO_ERROR;
diff -urN /home/mitr/t/fuse4bsd-hg/fuse_module/fuse_io.h fuse4bsd-hg/fuse_module/fuse_io.h
--- /home/mitr/t/fuse4bsd-hg/fuse_module/fuse_io.h	2007-03-30 22:59:28.000000000 +0200
+++ fuse4bsd-hg/fuse_module/fuse_io.h	2007-04-04 00:42:31.000000000 +0200
@@ -6,14 +6,15 @@
  * as well occur standalone.
  */
 
+/* "i" == protected by vnode interlock */
 struct fuse_filehandle {
 	uint64_t fh_id;
 	int mode;
 	struct ucred *cred;
 	pid_t pid;
-	int useco;
-	LIST_ENTRY(fuse_filehandle) fh_link;
-	struct file *fp;
+	int useco;		/* i */
+	LIST_ENTRY(fuse_filehandle) fh_link; /* i */
+	struct file *fp;		     /* i */
 	int flags;
 	enum fuse_opcode op;
 };
diff -urN /home/mitr/t/fuse4bsd-hg/fuse_module/fuse_msg.c fuse4bsd-hg/fuse_module/fuse_msg.c
--- /home/mitr/t/fuse4bsd-hg/fuse_module/fuse_msg.c	2007-03-30 22:59:28.000000000 +0200
+++ fuse4bsd-hg/fuse_module/fuse_msg.c	2007-04-05 03:50:39.000000000 +0200
@@ -149,6 +149,8 @@
 	tick = malloc(sizeof(*tick), M_FUSEMSG, M_WAITOK | M_ZERO);
 
 	tick->tk_unique = data->ticketer++;
+	if (data->ticketer == 0)
+		data->ticketer = 1;
 	tick->tk_data = data;
 
 	fiov_init(&tick->tk_ms_fiov, sizeof(struct fuse_in_header));
@@ -289,7 +291,9 @@
 	TAILQ_INIT(&data->alltickets_head);
 	mtx_init(&data->aw_mtx, "fuse answer list mutex", NULL, MTX_DEF);
 	TAILQ_INIT(&data->aw_head);
-	data->ticketer = 0;
+	TAILQ_INIT(&data->inval_queue_head);
+	data->inval_queue_len = 0;
+	data->ticketer = 1;
 	data->freeticket_counter = 0;
 	data->daemoncred = crhold(cred);
 
@@ -305,6 +309,7 @@
 fdata_destroy(struct fuse_data *data)
 {
 	struct fuse_ticket *tick;
+	struct fuse_inval_metadata *fim;
 
 	/* Driving off stage all that stuff thrown at device... */
 	mtx_destroy(&data->ms_mtx);
@@ -312,6 +317,10 @@
 	mtx_destroy(&data->ticket_mtx);
 	sx_destroy(&data->rename_lock);
 
+	while ((fim = TAILQ_FIRST(&data->inval_queue_head)) != NULL) {
+		TAILQ_REMOVE(&data->inval_queue_head, fim, fim_link);
+		free(fim, M_FUSEFIM);
+	}
 	while ((tick = fuse_pop_allticks(data)))
 		fticket_destroy(tick);
 
@@ -417,7 +426,7 @@
 		KASSERT(tick, ("no free ticket available tho counter said there is"));
 	}
 
-	if (! (data->dataflag & FSESS_INITED) && data->ticketer > 1)
+	if (! (data->dataflag & FSESS_INITED) && data->ticketer > 2)
 		err = msleep(&data->ticketer, &data->ticket_mtx,
 		             PCATCH | PDROP, "fu_ini", 0);
 	else
diff -urN /home/mitr/t/fuse4bsd-hg/fuse_module/fuse_session.h fuse4bsd-hg/fuse_module/fuse_session.h
--- /home/mitr/t/fuse4bsd-hg/fuse_module/fuse_session.h	2007-03-30 22:59:28.000000000 +0200
+++ fuse4bsd-hg/fuse_module/fuse_session.h	2007-04-05 03:50:09.000000000 +0200
@@ -117,6 +117,14 @@
 /* pull in userspace data from uio and pass it to tick */
 int fticket_pull(struct fuse_ticket *tick, struct uio *uio);
 
+/* A pending FUSE_BACK_INVALIDATE_METADATA request */
+struct fuse_inval_metadata {
+	TAILQ_ENTRY(fuse_inval_metadata) fim_link;
+	uint64_t fim_nodeid;
+};
+
+MALLOC_DECLARE(M_FUSEFIM);
+
 enum mountpri { FM_NOMOUNTED, FM_PRIMARY, FM_SECONDARY };
 
 /*
@@ -135,6 +143,8 @@
 	/* queue of answer waiters */
 	struct mtx aw_mtx;
 	TAILQ_HEAD(, fuse_ticket) aw_head;
+	TAILQ_HEAD(, fuse_inval_metadata) inval_queue_head;
+	unsigned inval_queue_len;
 
 	/* fuse_ticket repository */
 	struct mtx ticket_mtx;
@@ -183,6 +193,10 @@
 #define FSESS_DEFAULT_PERMISSIONS 0x0800 /* kernel does permission checking, based
                                             on file mode */
 
+/* To make sure the user-space daemon can't fill kernel memory with invalidate
+   queue */
+#define MAX_INVAL_QUEUE_LEN	1024
+
 static __inline struct fuse_data *
 fusedev_get_data(struct cdev *fdev)
 {
diff -urN /home/mitr/t/fuse4bsd-hg/fuse_module/fuse_vfsops.c fuse4bsd-hg/fuse_module/fuse_vfsops.c
--- /home/mitr/t/fuse4bsd-hg/fuse_module/fuse_vfsops.c	2007-03-30 22:59:28.000000000 +0200
+++ fuse4bsd-hg/fuse_module/fuse_vfsops.c	2007-04-03 14:00:17.000000000 +0200
@@ -438,8 +438,8 @@
 
 out:
 	if (err ) {
-		data->mntco--;
 		FUSE_LOCK;
+		data->mntco--;
 		if (data->mntco == 0 && ! (data->dataflag & FSESS_OPENED)) {
 			fdev->si_drv1 = NULL;
 			fdata_destroy(data);
@@ -522,8 +522,8 @@
 	if (err)
 		return (err);
 
-	data->mntco--;
 	FUSE_LOCK;
+	data->mntco--;
 	fdev = data->fdev;
 	DEBUG2G("mntco %d, opened 0x%x\n",
 	        data->mntco, data->dataflag & FSESS_OPENED);
diff -urN /home/mitr/t/fuse4bsd-hg/fuse_module/fuse_vnode.h fuse4bsd-hg/fuse_module/fuse_vnode.h
--- /home/mitr/t/fuse4bsd-hg/fuse_module/fuse_vnode.h	2007-03-30 22:59:28.000000000 +0200
+++ fuse4bsd-hg/fuse_module/fuse_vnode.h	2007-04-05 03:46:15.000000000 +0200
@@ -7,11 +7,11 @@
 	uint64_t parent_nid;
 
 	int flags;
-	LIST_HEAD(, fuse_filehandle) fh_head;
-	int fh_counter;
+	LIST_HEAD(, fuse_filehandle) fh_head; /* i filehandle list */
+	int fh_counter;		/* i number of entries in fh_head */
 
-	struct vattr cached_attrs;
-	struct timespec cached_attrs_valid;
+	struct vattr cached_attrs; /* i */
+	struct timespec cached_attrs_valid; /* i */
 
 #ifdef FUSE_HAS_CREATE
 	struct componentname *germcnp;
@@ -28,8 +28,11 @@
 static __inline void
 fuse_invalidate_attr(struct vnode *vp)
 {
-	if (VTOFUD(vp))
+	if (VTOFUD(vp)) {
+		VI_LOCK(vp);
 		bzero(&VTOFUD(vp)->cached_attrs_valid, sizeof(struct timespec));
+		VI_UNLOCK(vp);
+	}
 }
 
 MALLOC_DECLARE(M_FUSEVN);
@@ -74,3 +77,9 @@
 int fuse_get_filehandle(struct vnode *vp, struct thread *td, struct ucred *cred,
                    int mode, struct fuse_filehandle **fufhp,
                    struct get_filehandle_param *gefhp);
+
+int fuse_back_invalidate_metadata(struct fuse_data *data, uint64_t nodeid);
+int fuse_back_invalidate_data(struct fuse_data *data, uint64_t nodeid);
+int fuse_back_sync_inode(struct fuse_data *data, uint64_t nodeid);
+
+void fuse_process_inval_queue(struct fuse_data *data);
diff -urN /home/mitr/t/fuse4bsd-hg/fuse_module/fuse_vnops.c fuse4bsd-hg/fuse_module/fuse_vnops.c
--- /home/mitr/t/fuse4bsd-hg/fuse_module/fuse_vnops.c	2007-04-03 23:56:19.000000000 +0200
+++ fuse4bsd-hg/fuse_module/fuse_vnops.c	2007-04-05 04:22:33.000000000 +0200
@@ -75,6 +75,7 @@
 };
 
 struct fuse_release_param {
+	LIST_HEAD(, fuse_filehandle) collected;
 	int err;
 	uint8_t fg:1;
 	uint8_t flush:1;
@@ -149,7 +150,11 @@
 static fuse_metrics_t fuse_file_ditch;
 static fuse_metrics_t fuse_standard_metrics;
 static fuse_metrics_t fuse_fsync_filehandle;
-static fuse_metrics_t release_filehandle;
+static fuse_metrics_t collect_fh_for_release;
+
+static void release_filehandles(struct vnode *vp, struct thread *td,
+				struct ucred *cred,
+				struct fuse_release_param *frp);
 
 #if FUSE_HAS_CREATE
 static vfs_hash_cmp_t fuse_vnode_fgdrop_cmp;
@@ -438,6 +443,7 @@
 	vput(vp);
 }
 
+/* called under the vp interlock! */
 static int
 fuse_file_ditch(struct vnode *vp, struct thread *td, struct ucred *cred,
                struct fuse_filehandle *fufh, void *param)
@@ -472,7 +478,6 @@
 	DEBUG("getting at vnode of ino %llu\n", VTOILLU(vp));
 	ASSERT_VOP_ELOCKED(vp, "recycling unlocked vnode");
 
-	ASSERT_VOP_ELOCKED__FH(vp);
 	iterate_filehandles(vp, td, NULL, fuse_file_ditch, NULL);
 	/*
 	 * Sometimes the FORGET message sent below used to hit the target
@@ -482,9 +487,15 @@
 	 * So now we just peacefully sit here and wait for the answer before
 	 * goin' on.
 	 */
+	LIST_INIT(&frp.collected);
 	frp.fg = 1;
 	frp.flush = 0;
-	iterate_filehandles(vp, td, NULL, release_filehandle, &frp);
+	iterate_filehandles(vp, td, NULL, collect_fh_for_release, &frp);
+	/* So, this is EVIL.  Nevertheless, vp must be unlocked during the
+	   blocking release.  Let's hope the VFS doesn't collapse... */
+	VOP_UNLOCK(vp, 0, td);
+	release_filehandles(vp, td, NULL, &frp);
+	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, td);
 
 	if (! (vp->v_vflag & VV_ROOT)) {
 		if (fvdat->nid != FUSE_NULL_ID)
@@ -516,9 +527,10 @@
 	return (0);
 }
 
+/* called under the vp interlock! */
 static int
-release_filehandle(struct vnode *vp, struct thread *td, struct ucred *cred,
-		   struct fuse_filehandle *fufh, void *param)
+collect_fh_for_release(struct vnode *vp, struct thread *td, struct ucred *cred,
+		       struct fuse_filehandle *fufh, void *param)
 {
 	KASSERT(fufh->useco >= 0,
 		("negative use count for fuse filehandle #%llu@#%llu",
@@ -529,19 +541,37 @@
 	        VTOILLU(vp), fufh, (long long unsigned) fufh->fh_id, fufh->fp,
 	        fufh->useco);
 	if (! fufh->fp && fufh->useco == 0) {
+		struct fuse_release_param *frp;
+
+		frp = param;
 		LIST_REMOVE(fufh, fh_link);
-		fuse_send_release(vp, td, cred, fufh, fufh->mode, param);
+		LIST_INSERT_HEAD(&frp->collected, fufh, fh_link);
 	}
 
 	return (0);		
 }
 
 static void
+release_filehandles(struct vnode *vp, struct thread *td, struct ucred *cred,
+		    struct fuse_release_param *frp)
+{
+	struct fuse_filehandle *fufh, *fufhxxx;
+
+	RECTIFY_TDCR(td, cred);
+
+	LIST_FOREACH_SAFE(fufh, &frp->collected, fh_link, fufhxxx) {
+		LIST_REMOVE(fufh, fh_link);
+		fuse_send_release(vp, td, cred, fufh, fufh->mode, frp);
+	}
+}
+
+static void
 fuse_filehandle_gc(struct vnode *vp, struct thread *td, struct ucred *cred,
                    struct fuse_release_param *frp)
 {
-	ASSERT_VOP_ELOCKED__FH(vp);
-	iterate_filehandles(vp, td, cred, release_filehandle, frp);
+	LIST_INIT(&frp->collected);
+	iterate_filehandles(vp, td, cred, collect_fh_for_release, frp);
+	release_filehandles(vp, td, cred, frp);
 }
 
 static int
@@ -673,6 +703,7 @@
 #define cache_attrs(vp, fuse_out) do {					      \
 	struct timespec uptsp_ ## __func__;				      \
 									      \
+	VI_LOCK(vp);							      \
 	VTOFUD(vp)->cached_attrs_valid.tv_sec = (fuse_out)->attr_valid;	      \
 	VTOFUD(vp)->cached_attrs_valid.tv_nsec = (fuse_out)->attr_valid_nsec; \
 	nanouptime(&uptsp_ ## __func__);				      \
@@ -683,6 +714,7 @@
 	timespecadd(&VTOFUD(vp)->cached_attrs_valid, &uptsp_ ## __func__);    \
 									      \
 	fat2vat((vp)->v_mount, &(fuse_out)->attr, VTOVA(vp));		      \
+	VI_UNLOCK(vp);							      \
 } while (0)
 
 /*
@@ -771,14 +803,17 @@
 
 	/* look for cached attributes */
 	nanouptime(&uptsp);
+	VI_LOCK(vp);
 	if (timespeccmp(&uptsp, &VTOFUD(vp)->cached_attrs_valid, <=)) {
 		DEBUG("found valid cached attrs for vp #%llu\n", VTOILLU(vp));
 
 		if (vap != VTOVA(vp))
 			memcpy(vap, VTOVA(vp), sizeof(*vap));
+		VI_UNLOCK(vp);
 
 		return (0);
 	}
+	VI_UNLOCK(vp);
 
 	if (! (fusefs_get_data(vp->v_mount)->dataflag & FSESS_INITED)) {
 		if (! (vp->v_vflag & VV_ROOT)) {
@@ -1400,6 +1435,7 @@
 	return (err);
 }
 
+/* fmetr is called under the vp interlock! */
 static int
 iterate_filehandles(struct vnode *vp, struct thread *td, struct ucred *cred,
 		    fuse_metrics_t fmetr, void *param)
@@ -1410,14 +1446,17 @@
 
 	RECTIFY_TDCR(td, cred);
 
+	VI_LOCK(vp);
 	LIST_FOREACH_SAFE(fufh, &fvdat->fh_head, fh_link, fufhxxx) {
 		if ((rv = fmetr(vp, td, cred, fufh, param)))
-			return (rv); 
+			break;
 	}
+	VI_UNLOCK(vp);
 
 	return (0);
 }
 
+/* called under the vp interlock! */
 static int
 fuse_standard_metrics(struct vnode *vp, struct thread *td, struct ucred *cred,
                       struct fuse_filehandle *fufh, void *param)
@@ -1695,7 +1734,9 @@
 	fufh->op = op;
 
 	ASSERT_VOP_ELOCKED__FH(vp);
+	VI_LOCK(vp);
 	LIST_INSERT_HEAD(&fvdat->fh_head, fufh, fh_link);
+	VI_UNLOCK(vp);
 	if (gefhp && gefhp->do_gc) {
 		/*
 		 * The neat idea is that a cache cleanup is the best time for
@@ -1720,11 +1761,16 @@
 		struct fuse_release_param frp;
 
 		DEBUG2G("gc'ing...\n");
+		LIST_INIT(&frp.collected);
 		frp.fg = 0;
 		frp.flush = 0;
-		iterate_filehandles(vp, td, cred, release_filehandle, &frp);
+		iterate_filehandles(vp, td, cred, collect_fh_for_release,
+				    &frp);
+		release_filehandles(vp, td, cred, &frp);
 	}
+	VI_LOCK(vp);
 	fvdat->fh_counter++;
+	VI_UNLOCK(vp);
 
 #if _DEBUG2G
 	if (gefhp && gefhp->do_gc) {
@@ -1823,10 +1869,15 @@
 
 	if (fp && ! err) {
 		fp->f_ops = &fuse_fileops;
+		VI_LOCK(vp);
 		fufh->fp = fp;
+		VI_UNLOCK(vp);
 		fp->f_data = fufh;
-	} else
+	} else {
+		VI_LOCK(vp);
 		fufh->useco--;
+		VI_UNLOCK(vp);
+	}
 
 out:
 	if (VTOFUD(vp))
@@ -1850,9 +1901,11 @@
 
 	KASSERT(! fufh->fp && fufh->useco == 0, ("active-looking fuse filehandle was attempted to release"));
 
+	VI_LOCK(vp);
 	VTOFUD(vp)->fh_counter--;
 	DEBUG2G("filehandle of vnode #%llu being released, fh counter now is %d\n",
 	         VTOILLU(vp), VTOFUD(vp)->fh_counter);
+	VI_UNLOCK(vp);
 
 	if (vp->v_type == VBAD)
 		goto out;
@@ -1894,34 +1947,32 @@
 	struct vnode *vp = fp->f_vnode;
 	struct fuse_release_param frp;
 
+	frp.err = 0;
 	if (! _file_is_fat(fp))
 		panic("non-fat file passed to close routine");
 
-	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, td);
-
 	if (_file_is_bad(fp)) {
 		DEBUG2G("fp %p, vnode #%llu: went bad, giving up\n",
 		        fp, VTOILLU(vp));
 /*
-		VOP_UNLOCK(vp, 0, td);
 		return (EBADF);
  */
 		goto out;
 	}
 	fufh = FTOFH(fp);
+	VI_LOCK(vp);
 	KASSERT(fufh->fp == fp, ("file's filehandle is stolen"));
 	DEBUG2G("vnode #%llu, fufh owner %p, useco %d\n",
 	        VTOILLU(vp), fp, fufh->useco);
 
 	fufh->useco--;
-	ASSERT_VOP_ELOCKED__FH(vp);
 	fufh->fp = NULL;
 	if (fufh->useco == 0)
 		LIST_REMOVE(fufh, fh_link);
 	fp->f_data = NULL;
 
 	if (fufh->useco == 0) {
-		frp.err = 0;
+		VI_UNLOCK(vp);
 #if FUSE_HAS_FLUSH_RELEASE
 		frp.fg = 1;
 		frp.flush = 1;
@@ -1931,9 +1982,11 @@
 #endif
 		fuse_send_release(vp, td, NULL, fufh,
 		                  fp->f_flag & ~O_EXCL, &frp);
-	}
+	} else
+		VI_UNLOCK(vp);
 
 out:
+	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, td);
 	if (fp->f_flag & FWRITE)
                 vp->v_writecount--;
 	vput(vp);
@@ -1953,13 +2006,8 @@
 
 	DEBUG2G("vnode #%llu\n", VTOILLU(ap->a_vp));
 	frp.err = 0;
-#if FUSE_HAS_FLUSH_RELEASE
-	frp.fg = 1;
-	frp.flush = 1;
-#else
 	frp.fg = 0;
 	frp.flush = 0;
-#endif
 	fuse_filehandle_gc(ap->a_vp, ap->a_td, ap->a_cred, &frp);
 
 	return (frp.err);
@@ -2040,7 +2088,9 @@
 	err = fuse_read_directbackend(&fioda);
 
 	fiov_teardown(&cookediov);
+	VI_LOCK(vp);
 	fufh->useco--;
+	VI_UNLOCK(vp);
 	fuse_invalidate_attr(vp);
 
 	return (err);
@@ -2998,6 +3048,7 @@
 	return (err);
 }
 
+/* called under the vp interlock! */
 static int 
 fuse_fsync_filehandle(struct vnode *vp, struct thread *td, struct ucred *cred,
                       struct fuse_filehandle *fufh, void *param)
@@ -3474,3 +3525,147 @@
 	return (0);
 }
 #endif
+
+static int
+fd_find_inode(struct fuse_data *data, uint64_t nodeid, int flag,
+	      struct vnode **vpp)
+{
+	struct mount *mp;
+	int err;
+
+	FUSE_LOCK;
+	if (data->mntco == 0) {
+		FUSE_UNLOCK;
+		return (ENOTCONN);
+	}
+	mp = data->mp;
+	MNT_ILOCK(mp);
+	MNT_REF(mp);
+	MNT_IUNLOCK(mp);
+	FUSE_UNLOCK;
+
+	if (nodeid == FUSE_ROOT_ID)
+		err = VFS_ROOT(mp, flag, vpp, curthread);
+	else
+		err = vfs_hash_get(mp, nodeid, flag, curthread, vpp,
+				   fuse_vnode_cmp, &nodeid);
+	MNT_ILOCK(mp);
+	MNT_REL(mp);
+	MNT_IUNLOCK(mp);
+
+	return (err);
+}
+
+MALLOC_DEFINE(M_FUSEFIM, "fuse_fim", "fuse invalidate metadata request queue");
+
+/* May fail with EBUSY */
+static int
+fuse_do_back_invalidate_metadata(struct fuse_data *data, uint64_t nodeid)
+{
+	struct vnode *vp;
+	int err;
+
+	err = fd_find_inode(data, nodeid, LK_SHARED | LK_NOWAIT, &vp);
+	if (err)
+		return (err);
+	
+	if (vp) {
+		fuse_invalidate_attr(vp);
+		vput(vp);
+	}
+	return (0);
+}
+
+int
+fuse_back_invalidate_metadata(struct fuse_data *data, uint64_t nodeid)
+{
+	int err;
+
+	err = fuse_do_back_invalidate_metadata(data, nodeid);
+	if (err == EBUSY) {
+		struct fuse_inval_metadata *fim;
+		/* We can't block on the vnode lock here; we were called by
+		   the FUSE daemon, most likely while processing another VFS
+		   request, which holds a locked vnode, probably the one we are
+		   interested in.  Postpone the invalidation to same later
+		   time. */
+		/* FIXME: limit the number of outstanding invalidations */
+
+		fim = malloc(sizeof (*fim), M_FUSEFIM, M_WAITOK);
+		fim->fim_nodeid = nodeid;
+		mtx_lock(&data->aw_mtx);
+		if (data->inval_queue_len < MAX_INVAL_QUEUE_LEN) {
+			TAILQ_INSERT_TAIL(&data->inval_queue_head, fim,
+					  fim_link);
+			data->inval_queue_len++;
+			mtx_unlock(&data->aw_mtx);
+		} else {
+			mtx_unlock(&data->aw_mtx);
+			free(fim, M_FUSEFIM);
+		}
+		/* Userspace can't do anything useful about an invalidation
+		   failure, anyway... */
+			err = 0;
+	}
+	return (err);
+}
+
+void
+fuse_process_inval_queue(struct fuse_data *data)
+{
+	struct fuse_inval_metadata *fim;
+	TAILQ_HEAD(, fuse_inval_metadata) busy;
+
+	TAILQ_INIT(&busy);
+	mtx_lock(&data->aw_mtx);
+	while ((fim = TAILQ_FIRST(&data->inval_queue_head)) != NULL) {
+		TAILQ_REMOVE(&data->inval_queue_head, fim, fim_link);
+		mtx_unlock(&data->aw_mtx);
+
+		if (fuse_do_back_invalidate_metadata(data, fim->fim_nodeid)
+		    == 0) {
+			free(fim, M_FUSEFIM);
+			mtx_lock(&data->aw_mtx);
+			data->inval_queue_len--;
+		} else {
+			TAILQ_INSERT_TAIL(&busy, fim, fim_link);
+			mtx_lock(&data->aw_mtx);
+		}
+	}
+	TAILQ_CONCAT(&data->inval_queue_head, &busy, fim_link);
+	mtx_unlock(&data->aw_mtx);
+}
+
+int
+fuse_back_invalidate_data(struct fuse_data *data, uint64_t nodeid)
+{
+	struct vnode *vp;
+	int err;
+	
+	err = fd_find_inode(data, nodeid, LK_SHARED, &vp);
+	if (err)
+		return (err);
+	
+	if (vp) {
+		(void)vinvalbuf(vp, 0, curthread, 0, 0);
+		vput(vp);
+	}
+	return (0);
+}
+
+int
+fuse_back_sync_inode(struct fuse_data *data, uint64_t nodeid)
+{
+	struct vnode *vp;
+	int err;
+	
+	err = fd_find_inode(data, nodeid, LK_SHARED, &vp);
+	if (err)
+		return (err);
+	
+	if (vp) {
+		err = vinvalbuf(vp, V_SAVE, curthread, 0, 0);
+		vput(vp);
+	}
+	return (err);
+}
