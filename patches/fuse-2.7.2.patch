diff -Naur a/fuse-2.7.2/include/fuse_common.h b/fuse-2.7.2/include/fuse_common.h
--- a/fuse-2.7.2/include/fuse_common.h	2007-12-17 14:28:02.000000000 +0100
+++ b/fuse-2.7.2/include/fuse_common.h	2007-12-18 10:20:25.000000000 +0100
@@ -65,8 +65,13 @@
 	    operation.	Introduced in version 2.6 */
 	unsigned int flush : 1;
 
+	/** Can be filled in by open, to indicate that data should not be cached,
+	    but that a future OPEN may reenable caching by not setting this
+	    flag. */
+	unsigned int no_caching : 1;
+
 	/** Padding.  Do not use*/
-	unsigned int padding : 29;
+	unsigned int padding : 28;
 
 	/** File handle.  May be filled in by filesystem in open().
 	    Available in all other file operations */
diff -Naur a/fuse-2.7.2/include/fuse_kernel.h b/fuse-2.7.2/include/fuse_kernel.h
--- a/fuse-2.7.2/include/fuse_kernel.h	2007-09-18 13:18:38.000000000 +0200
+++ b/fuse-2.7.2/include/fuse_kernel.h	2007-12-18 10:17:47.000000000 +0100
@@ -113,9 +113,11 @@
  *
  * FOPEN_DIRECT_IO: bypass page cache for this open file
  * FOPEN_KEEP_CACHE: don't invalidate the data cache on open
+ * FOPEN_NO_CACHING: don't cache data until enabled by a future OPEN request
  */
 #define FOPEN_DIRECT_IO		(1 << 0)
 #define FOPEN_KEEP_CACHE	(1 << 1)
+#define FOPEN_NO_CACHING	(1 << 2)
 
 /**
  * INIT request/reply flags
@@ -167,6 +169,13 @@
 	FUSE_DESTROY       = 38,
 };
 
+enum fuse_back_opcode {
+	FUSE_BACK_INVALIDATE_METADATA		= 1,
+	FUSE_BACK_INVALIDATE_DATA		= 2,
+	FUSE_BACK_SYNC_INODE			= 3,
+	FUSE_BACK_INVALIDATE_DATA_NO_CACHING	= 4,
+};
+
 /* The read buffer is required to be at least 8k, but may be much larger */
 #define FUSE_MIN_READ_BUFFER 8192
 
@@ -359,7 +368,12 @@
 struct fuse_out_header {
 	__u32	len;
 	__s32	error;
-	__u64	unique;
+	__u64	unique;		/* If 0, a fuse_back_header follows */
+};
+
+struct fuse_back_header {
+	__u32	opcode;
+	__u64	nodeid;
 };
 
 struct fuse_dirent {
diff -Naur a/fuse-2.7.2/include/fuse_lowlevel.h b/fuse-2.7.2/include/fuse_lowlevel.h
--- a/fuse-2.7.2/include/fuse_lowlevel.h	2007-12-12 15:33:33.000000000 +0100
+++ b/fuse-2.7.2/include/fuse_lowlevel.h	2007-12-18 10:17:47.000000000 +0100
@@ -990,6 +990,33 @@
  */
 int fuse_reply_bmap(fuse_req_t req, uint64_t idx);
 
+/**
+ * Ask the kernel to invalidate inode metadata
+ *
+ * @param se the session
+ * @param ino the inode
+ * @return zero to success, -errno for failure
+ */
+int fuse_kernel_invalidate_metadata(struct fuse_session *se, fuse_ino_t ino);
+
+/**
+ * Ask the kernel to invalidate inode data
+ *
+ * @param se the session
+ * @param ino the inode
+ * @return zero to success, -errno for failure
+ */
+int fuse_kernel_invalidate_data(struct fuse_session *se, fuse_ino_t ino);
+
+/**
+ * Ask the kernel to write out dirty data for an inode
+ *
+ * @param se the session
+ * @param ino the inode
+ * @return zero to success, -errno for failure
+ */
+int fuse_kernel_sync_inode(struct fuse_session *se, fuse_ino_t ino);
+
 /* ----------------------------------------------------------- *
  * Filling a buffer in readdir				       *
  * ----------------------------------------------------------- */
diff -Naur a/fuse-2.7.2/kernel/dev.c b/fuse-2.7.2/kernel/dev.c
--- a/fuse-2.7.2/kernel/dev.c	2007-10-16 18:35:22.000000000 +0200
+++ b/fuse-2.7.2/kernel/dev.c	2007-12-18 10:17:47.000000000 +0100
@@ -826,6 +826,15 @@
 			      out->page_zeroing);
 }
 
+static int (*const back_fns[])(struct fuse_conn *, unsigned long nodeid) =
+{
+	[FUSE_BACK_INVALIDATE_METADATA] = fuse_back_invalidate_metadata,
+	[FUSE_BACK_INVALIDATE_DATA] = fuse_back_invalidate_data,
+	[FUSE_BACK_SYNC_INODE] = fuse_back_sync_inode,
+	[FUSE_BACK_INVALIDATE_DATA_NO_CACHING]
+	= fuse_back_invalidate_data_no_caching,
+};
+
 /*
  * Write a single reply to a request.  First the header is copied from
  * the write buffer.  The request is then searched on the processing
@@ -853,8 +862,7 @@
 	if (err)
 		goto err_finish;
 	err = -EINVAL;
-	if (!oh.unique || oh.error <= -1000 || oh.error > 0 ||
-	    oh.len != nbytes)
+	if (oh.error <= -1000 || oh.error > 0 || oh.len != nbytes)
 		goto err_finish;
 
 	spin_lock(&fc->lock);
@@ -862,6 +870,27 @@
 	if (!fc->connected)
 		goto err_unlock;
 
+	if (!oh.unique) {
+		struct fuse_back_header bh;
+
+		spin_unlock(&fc->lock);
+
+		err = -EINVAL;
+		if (nbytes != sizeof(struct fuse_out_header)
+		    + sizeof(struct fuse_back_header))
+			goto err_finish;
+		err = fuse_copy_one(&cs, &bh, sizeof(bh));
+		if (err)
+			goto err_finish;
+		fuse_copy_finish(&cs);
+
+		err = -ENOSYS;
+		if (bh.opcode > ARRAY_SIZE(back_fns)
+		    || back_fns[bh.opcode] == NULL)
+			goto err_finish;
+		err = back_fns[bh.opcode](fc, bh.nodeid);
+		goto err_finish;
+	}
 	req = request_find(fc, oh.unique);
 	if (!req)
 		goto err_unlock;
diff -Naur a/fuse-2.7.2/kernel/dir.c b/fuse-2.7.2/kernel/dir.c
--- a/fuse-2.7.2/kernel/dir.c	2007-12-12 20:00:11.000000000 +0100
+++ b/fuse-2.7.2/kernel/dir.c	2007-12-18 10:17:47.000000000 +0100
@@ -130,10 +130,20 @@
 static int fuse_dentry_revalidate(struct dentry *entry, struct nameidata *nd)
 {
 	struct inode *inode = entry->d_inode;
+	int invalid;
 
 	if (inode && is_bad_inode(inode))
 		return 0;
-	else if (fuse_dentry_time(entry) < get_jiffies_64()) {
+	invalid = 0;
+	if (inode && get_fuse_inode(inode)->i_time == (u64)-1) {
+		/* The dentry was in use when the inode purge request was
+		   processed. */
+		shrink_dcache_parent(entry);
+		d_drop(entry);
+		invalid = 1;
+	} else if (fuse_dentry_time(entry) < get_jiffies_64())
+		invalid = 1;
+	if (invalid) {
 		int err;
 		struct fuse_entry_out outarg;
 		struct fuse_conn *fc;
@@ -757,6 +767,13 @@
 
 	if (!fuse_allow_task(fc, current))
 		return -EACCES;
+	if (fi->i_time == (u64)-1) {
+		/* The dentry was in use when the inode purge request was
+		   processed. */
+		shrink_dcache_parent(entry);
+		d_drop(entry);
+		return 0;
+	}
 	if (get_node_id(inode) != FUSE_ROOT_ID &&
 	    fi->i_time >= get_jiffies_64())
 		return 0;
diff -Naur a/fuse-2.7.2/kernel/file.c b/fuse-2.7.2/kernel/file.c
--- a/fuse-2.7.2/kernel/file.c	2007-10-16 18:35:22.000000000 +0200
+++ b/fuse-2.7.2/kernel/file.c	2007-12-18 10:17:47.000000000 +0100
@@ -79,8 +79,10 @@
 #ifdef KERNEL_2_6_21_PLUS
 		invalidate_mapping_pages(inode->i_mapping, 0, -1);
 #else
-		invalidate_inode_pages(inode->i_mapping);
+	invalidate_inode_pages(inode->i_mapping);
 #endif
+        get_fuse_inode(inode)->no_caching = (outarg->open_flags
+					     & FOPEN_NO_CACHING) != 0;
 	ff->fh = outarg->fh;
 	file->private_data = ff;
 }
@@ -650,6 +652,61 @@
 	return generic_file_mmap(file, vma);
 }
 
+#ifndef KERNEL_2_6_19_PLUS
+static ssize_t fuse_file_read(struct file *file, char __user *buf, size_t count,
+			      loff_t *ppos)
+{
+	struct inode *inode;
+
+	inode = file->f_dentry->d_inode;
+	if (get_fuse_inode(inode)->no_caching)
+		return fuse_direct_read(file, buf, count, ppos);
+	return generic_file_read(file, buf, count, ppos);
+}
+#else
+static ssize_t fuse_file_aio_read(struct kiocb *iocb, const struct iovec *iov,
+				  unsigned long nr_segs, loff_t pos)
+{
+	struct file *file;
+	struct inode *inode;
+
+	file = iocb->ki_filp;
+	inode = file->f_dentry->d_inode;
+	if (!get_fuse_inode(inode)->no_caching)
+		return generic_file_aio_read(iocb, iov, nr_segs, pos);
+	else {
+		ssize_t retval;
+		size_t count;
+
+		count = 0;
+		retval = generic_segment_checks(iov, &nr_segs, &count,
+						VERIFY_WRITE);
+		if (retval)
+			return retval;
+
+		if (count) {
+			loff_t *ppos;
+			unsigned long seg;
+
+			ppos = &iocb->ki_pos;
+			for (seg = 0; seg < nr_segs; seg++) {
+				ssize_t res;
+
+				res = fuse_direct_read(file, iov[seg].iov_base,
+						       iov[seg].iov_len, ppos);
+				if (res < 0) {
+					if (!retval)
+						retval = res;
+					break;
+				}
+				retval += res;
+			}
+		}
+		return retval;
+	}
+}
+#endif
+
 static int fuse_set_page_dirty(struct page *page)
 {
 	printk("fuse_set_page_dirty: should not happen\n");
@@ -851,11 +908,11 @@
 static struct file_operations fuse_file_operations = {
 	.llseek		= generic_file_llseek,
 #ifndef KERNEL_2_6_19_PLUS
-	.read		= generic_file_read,
+	.read		= fuse_file_read,
 	.write		= generic_file_write,
 #else
 	.read		= do_sync_read,
-	.aio_read	= generic_file_aio_read,
+	.aio_read	= fuse_file_aio_read,
 	.write		= do_sync_write,
 	.aio_write	= generic_file_aio_write,
 #endif
@@ -898,3 +955,96 @@
 	inode->i_fop = &fuse_file_operations;
 	inode->i_data.a_ops = &fuse_file_aops;
 }
+
+static struct inode *fc_ilookup(struct fuse_conn *fc, unsigned long nodeid)
+{
+	struct super_block *sb;
+	struct inode *inode;
+
+	/* This feels unclean */
+	spin_lock(&fc->lock);
+	if (!fc->connected) {
+		spin_unlock(&fc->lock);
+		return ERR_PTR(-ENOTCONN);
+	}
+	sb = fc->sb;
+	sb->s_count++; /* FIXME: need to hold sb_lock? */
+	spin_unlock(&fc->lock);
+	down_read(&sb->s_umount);
+	inode = fuse_ilookup(sb, nodeid);
+	drop_super(sb);
+	return inode;
+}
+
+int fuse_back_invalidate_metadata(struct fuse_conn *fc, unsigned long nodeid)
+{
+	struct inode *inode;
+
+	inode = fc_ilookup(fc, nodeid);
+	if (IS_ERR(inode))
+	    return PTR_ERR(inode);
+	if (inode != NULL) {
+		struct fuse_inode *fi;
+
+		fi = get_fuse_inode(inode);
+		fi->i_time = (u64)-1;
+		d_prune_aliases(inode);
+		iput(inode);
+	}
+	return 0;
+}
+
+int fuse_back_invalidate_data(struct fuse_conn *fc, unsigned long nodeid)
+{
+	struct inode *inode;
+
+	inode = fc_ilookup(fc, nodeid);
+	if (IS_ERR(inode))
+	    return PTR_ERR(inode);
+	if (inode != NULL) {
+#ifdef KERNEL_2_6_21_PLUS
+		invalidate_mapping_pages(inode->i_mapping, 0, -1);
+#else
+		invalidate_inode_pages(inode->i_mapping);
+#endif
+		iput(inode);
+	}
+	return 0;
+}
+
+int fuse_back_invalidate_data_no_caching(struct fuse_conn *fc,
+					 unsigned long nodeid)
+{
+	struct inode *inode;
+
+	inode = fc_ilookup(fc, nodeid);
+	if (IS_ERR(inode))
+	    return PTR_ERR(inode);
+	if (inode != NULL) {
+#ifdef KERNEL_2_6_21_PLUS
+		invalidate_mapping_pages(inode->i_mapping, 0, -1);
+#else
+		invalidate_inode_pages(inode->i_mapping);
+#endif
+		get_fuse_inode (inode)->no_caching = 1;
+		iput(inode);
+	}
+	return 0;
+}
+
+
+int fuse_back_sync_inode(struct fuse_conn *fc, unsigned long nodeid)
+{
+	struct inode *inode;
+	int ret;
+
+	inode = fc_ilookup(fc, nodeid);
+	if (IS_ERR(inode))
+		return PTR_ERR(inode);
+	ret = 0;
+	if (inode != NULL) {
+		ret = write_inode_now(inode, 1);
+		iput(inode);
+	}
+	return ret;
+}
diff -Naur a/fuse-2.7.2/kernel/fuse_i.h b/fuse-2.7.2/kernel/fuse_i.h
--- a/fuse-2.7.2/kernel/fuse_i.h	2007-12-12 20:00:11.000000000 +0100
+++ b/fuse-2.7.2/kernel/fuse_i.h	2007-12-18 10:17:47.000000000 +0100
@@ -143,8 +143,11 @@
 	/** The request used for sending the FORGET message */
 	struct fuse_req *forget_req;
 
-	/** Time in jiffies until the file attributes are valid */
+	/** Time in jiffies until the file attributes are valid; (u64)-1 if the
+	    inode is forever invalid.  */
 	u64 i_time;
+
+	unsigned int no_caching:1;
 };
 
 /** FUSE specific file data */
@@ -439,6 +442,9 @@
 	/** Negotiated minor version */
 	unsigned minor;
 
+	/** The mounted super block; valid only if connected != 0 */
+	struct super_block *sb;
+
 	/** Backing dev info */
 	struct backing_dev_info bdi;
 
@@ -494,6 +500,32 @@
 			int generation, struct fuse_attr *attr);
 
 /**
+ * Get a filled in inode, if it exists in the cache
+ */
+struct inode *fuse_ilookup(struct super_block *sb, unsigned long nodeid);
+
+/**
+ * Invalidate the metadata of the specified inode
+ */
+int fuse_back_invalidate_metadata(struct fuse_conn *fc, unsigned long nodeid);
+
+/**
+ * Invalidate the page cache of the specified inode
+ */
+int fuse_back_invalidate_data(struct fuse_conn *fc, unsigned long nodeid);
+
+/**
+ * Invalidate the page cache of the specified inode and stop caching it
+ */
+int fuse_back_invalidate_data_no_caching(struct fuse_conn *fc,
+					 unsigned long nodeid);
+
+/**
+ * Writeback dirty data for the specified inode
+ */
+int fuse_back_sync_inode(struct fuse_conn *fc, unsigned long nodeid);
+
+/**
  * Send FORGET command
  */
 void fuse_send_forget(struct fuse_conn *fc, struct fuse_req *req,
diff -Naur a/fuse-2.7.2/kernel/fuse_kernel.h b/fuse-2.7.2/kernel/fuse_kernel.h
--- a/fuse-2.7.2/kernel/fuse_kernel.h	2007-09-18 13:18:38.000000000 +0200
+++ b/fuse-2.7.2/kernel/fuse_kernel.h	2007-12-18 10:17:47.000000000 +0100
@@ -113,9 +113,11 @@
  *
  * FOPEN_DIRECT_IO: bypass page cache for this open file
  * FOPEN_KEEP_CACHE: don't invalidate the data cache on open
+ * FOPEN_NO_CACHING: don't cache data until enabled by a future OPEN request
  */
 #define FOPEN_DIRECT_IO		(1 << 0)
 #define FOPEN_KEEP_CACHE	(1 << 1)
+#define FOPEN_NO_CACHING	(1 << 2)
 
 /**
  * INIT request/reply flags
@@ -167,6 +169,13 @@
 	FUSE_DESTROY       = 38,
 };
 
+enum fuse_back_opcode {
+	FUSE_BACK_INVALIDATE_METADATA		= 1,
+	FUSE_BACK_INVALIDATE_DATA		= 2,
+	FUSE_BACK_SYNC_INODE			= 3,
+	FUSE_BACK_INVALIDATE_DATA_NO_CACHING	= 4,
+};
+
 /* The read buffer is required to be at least 8k, but may be much larger */
 #define FUSE_MIN_READ_BUFFER 8192
 
@@ -359,7 +368,12 @@
 struct fuse_out_header {
 	__u32	len;
 	__s32	error;
-	__u64	unique;
+	__u64	unique;		/* If 0, a fuse_back_header follows */
+};
+
+struct fuse_back_header {
+	__u32	opcode;
+	__u64	nodeid;
 };
 
 struct fuse_dirent {
diff -Naur a/fuse-2.7.2/kernel/inode.c b/fuse-2.7.2/kernel/inode.c
--- a/fuse-2.7.2/kernel/inode.c	2007-12-12 20:01:04.000000000 +0100
+++ b/fuse-2.7.2/kernel/inode.c	2007-12-18 10:17:47.000000000 +0100
@@ -59,6 +59,7 @@
 
 	fi = get_fuse_inode(inode);
 	fi->i_time = 0;
+	fi->no_caching = 0;
 	fi->nodeid = 0;
 	fi->nlookup = 0;
 	fi->forget_req = fuse_request_alloc();
@@ -187,6 +188,11 @@
 	return 0;
 }
 
+struct inode *fuse_ilookup(struct super_block *sb, unsigned long nodeid)
+{
+	return ilookup5(sb, nodeid, fuse_inode_eq, &nodeid);
+}
+
 struct inode *fuse_iget(struct super_block *sb, unsigned long nodeid,
 			int generation, struct fuse_attr *attr)
 {
@@ -801,6 +807,7 @@
 	fc->user_id = d.user_id;
 	fc->group_id = d.group_id;
 	fc->max_read = d.max_read;
+	fc->sb = sb;
 
 	/* Used by get_root_inode() */
 	sb->s_fs_info = fc;
diff -Naur a/fuse-2.7.2/lib/fuse_kern_chan.c b/fuse-2.7.2/lib/fuse_kern_chan.c
--- a/fuse-2.7.2/lib/fuse_kern_chan.c	2007-12-12 15:33:35.000000000 +0100
+++ b/fuse-2.7.2/lib/fuse_kern_chan.c	2007-12-18 10:39:09.000000000 +0100
@@ -48,7 +48,8 @@
 		return -err;
 	}
 	if ((size_t) res < sizeof(struct fuse_in_header)) {
-		fprintf(stderr, "short read on fuse device\n");
+        fprintf(stderr, "short read on fuse device: %llu\n", 
+		(unsigned long long)res);
 		return -EIO;
 	}
 	return res;
diff -Naur a/fuse-2.7.2/lib/fuse_lowlevel.c b/fuse-2.7.2/lib/fuse_lowlevel.c
--- a/fuse-2.7.2/lib/fuse_lowlevel.c	2007-12-12 15:33:35.000000000 +0100
+++ b/fuse-2.7.2/lib/fuse_lowlevel.c	2007-12-18 10:17:47.000000000 +0100
@@ -1076,6 +1076,41 @@
 	return interrupted;
 }
 
+static int fuse_send_back(struct fuse_session *se, uint32_t op, fuse_ino_t ino)
+{
+    struct fuse_chan *ch = fuse_session_next_chan(se, NULL);
+    struct fuse_out_header out;
+    struct fuse_back_header bh;
+    struct iovec iov[2];
+
+    out.unique = 0;
+    out.error = 0;
+    iov[0].iov_base = &out;
+    iov[0].iov_len = sizeof(struct fuse_out_header);
+    bh.opcode = op;
+    bh.nodeid = ino;
+    iov[1].iov_base = &bh;
+    iov[1].iov_len = sizeof(struct fuse_back_header);
+    out.len = iov_length(iov, 2);
+
+    return fuse_chan_send(ch, iov, 2);
+}
+
+int fuse_kernel_invalidate_metadata(struct fuse_session *se, fuse_ino_t ino)
+{
+    return fuse_send_back(se, FUSE_BACK_INVALIDATE_METADATA, ino);
+}
+
+int fuse_kernel_invalidate_data(struct fuse_session *se, fuse_ino_t ino)
+{
+    return fuse_send_back(se, FUSE_BACK_INVALIDATE_DATA, ino);
+}
+
+int fuse_kernel_sync_inode(struct fuse_session *se, fuse_ino_t ino)
+{
+    return fuse_send_back(se, FUSE_BACK_SYNC_INODE, ino);
+}
+
 static struct {
 	void (*func)(fuse_req_t, fuse_ino_t, const void *);
 	const char *name;
diff -Naur a/fuse-2.7.2/lib/fuse_versionscript b/fuse-2.7.2/lib/fuse_versionscript
--- a/fuse-2.7.2/lib/fuse_versionscript	2007-12-12 15:33:35.000000000 +0100
+++ b/fuse-2.7.2/lib/fuse_versionscript	2007-12-18 10:17:47.000000000 +0100
@@ -148,6 +148,9 @@
 		fuse_fs_unlink;
 		fuse_fs_utimens;
 		fuse_fs_write;
+		fuse_kernel_invalidate_metadata;
+		fuse_kernel_invalidate_data;
+		fuse_kernel_sync_inode;
 		fuse_register_module;
 		fuse_reply_iov;
 		fuse_version;
diff -Naur a/fuse-2.7.2/lib/mount_bsd.c b/fuse-2.7.2/lib/mount_bsd.c
--- a/fuse-2.7.2/lib/mount_bsd.c	2007-12-12 15:33:35.000000000 +0100
+++ b/fuse-2.7.2/lib/mount_bsd.c	2007-12-18 10:42:01.000000000 +0100
@@ -30,7 +30,8 @@
 	KEY_RO,
 	KEY_HELP,
 	KEY_VERSION,
-	KEY_KERN
+	KEY_KERN,
+	KEY_SUBTYPE,
 };
 
 struct mount_opts {
@@ -49,6 +50,7 @@
 	FUSE_OPT_KEY("--help",		    KEY_HELP),
 	FUSE_OPT_KEY("-V",		    KEY_VERSION),
 	FUSE_OPT_KEY("--version",	    KEY_VERSION),
+	FUSE_OPT_KEY("subtype=",		KEY_SUBTYPE),
 	/* standard FreeBSD mount options */
 	FUSE_OPT_KEY("dev",		    KEY_KERN),
 	FUSE_OPT_KEY("async",		    KEY_KERN),
@@ -163,6 +165,10 @@
 		mo->ishelp = 1;
 		break;
 	}
+
+	case KEY_SUBTYPE:
+		return 0;
+
 	return 1;
 }
 
