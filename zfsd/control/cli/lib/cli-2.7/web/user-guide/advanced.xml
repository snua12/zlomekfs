<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
    Copyright (c) 2006-2011, Alexis Royer, http://alexis.royer.free.fr/CLI

    All rights reserved.

    Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

        * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
        * Neither the name of the CLI library project nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->


<section id="adv"><title id="adv.title">Advanced</title>

    <para>
    Some of you may have special needs.
    Here is some additional information for advanced users.
    </para>

    <para>
    Many topics are illustrated either with C++ code or Java code,
    but please note that they are generally applicable to both languages:
    just transpose the C++/Java class names to the corresponding Java/C++ classes.
    </para>

    <section id="adv.telnet"><title id="adv.telnet.title">Telnet</title>

        <para>
        Let's start with telnet implementation.
        The CLI library is provided <classname>TelnetServer</classname> and <classname>TelnetConnection</classname> classes.
        These classes allow you to easily make your CLI run with network connections.
        </para>

            <example id="eg.telnet"><title id="eg.telnet">Simple telnet server</title>
                <para>
                First of all, inherit from <classname>TelnetServer</classname>.
                All you have to do is to override
                <function>onNewConnection</function> to allocate resources for new network connections,
                and <function>onCloseConnection</function> to free them when the thing is done. 
<programlisting>
class MyServer extends cli.TelnetServer {
    public MyServer() {
        // Up to 10 clients on port 9012.
        super(10, 9012, cli.ResourceString.LANG_EN);
    }
    protected cli.Shell onNewConnection(cli.TelnetConnection CLI_NewConnection) {
        // Create CLI and Shell instances for that new connection.
        cli.Cli cli_Cli = new MyCli();
        cli.Shell cli_Shell = new cli.Shell(cli_Cli);
        return cli_Shell;
    }
    protected void onCloseConnection(cli.Shell CLI_Shell, cli.TelnetConnection CLI_ConnectionClosed) {
        // Free connection resources: the garbage collector does the thing for us in Java.
    }
}
</programlisting>
            </para>

            <para>
            Eventually call <function>startServer</function> and that's it.
<programlisting>
MyServer cli_Server = new MyServer();
cli_Server.startServer(); // Blocking call
</programlisting>
            </para>

            <note>
            <classname>TelnetServer</classname> and <classname>TelnetConnection</classname> have been improved a lot with CLI 2.7.
            By the way, APIs have changed a bit, but no problem until you refer to that user guide section, also added in version 2.7.
            </note>

            <para>
            Start your server, and connect to it thanks to Teraterm for instance:
                <informalfigure>
                    <mediaobject>
                        <imageobject><imagedata fileref="misc/tterm-telnet.png" srccredit="tterm-doxygen"/></imageobject>
                    <textobject><phrase>Teraterm telnet settings.</phrase></textobject>
                    <caption><para>Teraterm telnet settings.</para></caption>
                    </mediaobject>
                </informalfigure>
            </para>
        </example>

        <para>
        If you need the server not to be blocking for your application,
        up to you to thread the thing.
        </para>

    </section>

    <section id="adv.menus"><title id="adv.menus.title">Advanced menu management</title>

        <section id="adv.menus.handlers"><title id="adv.menus.handlers.title"><sgmltag class="element">handler</sgmltag>
                    - <sgmltag class="element">menu</sgmltag> elements special features</title>

            <para>
            <sgmltag class="element">menu</sgmltag> elements may be provided with <sgmltag class="element">handler</sgmltag> elements.
            These <sgmltag class="element">handler</sgmltag> elements allow you to trigger native code on certain events.
            </para>

            <para>
            The CLI library manages three kinds of handlers:
            <variablelist>
            <varlistentry><term><sgmltag class="attvalue">error</sgmltag></term>
                <listitem>
                    <sgmltag class="attvalue">error</sgmltag> handlers are available on the root <sgmltag class="element">cli</sgmltag> element,
                    and are called when the CLI library displays an error.
                    This can be useful when writing CLI-based compilers, trapping syntax errors by the way.
                    <sgmltag class="attvalue">error</sgmltag> handlers return a boolean value: <code>false</code> disables the regular error display.
                </listitem></varlistentry>
            <varlistentry><term><sgmltag class="attvalue">exit</sgmltag></term>
                <listitem>
                    <sgmltag class="attvalue">exit</sgmltag> handlers are called when the menu exits.
                    When the CLI quits, the shell calls <sgmltag class="attvalue">exit</sgmltag> handlers for each menu in the current stack of menus.
                </listitem></varlistentry>
            <varlistentry><term><sgmltag class="attvalue">prompt</sgmltag></term>
                <listitem>
                    <sgmltag class="attvalue">prompt</sgmltag> handlers must return a string.
                    They allow the user application to dynamically change the prompt for the menu,
                    depending on the current state of the application.
                    This can be useful when writing configuration menus, for several items, with the same set of commands.
                    Instead of copy/paste the menu, just changing the name of it, for each item,
                    you may use the same menu with a <sgmltag class="attvalue">prompt</sgmltag> handler.
                </listitem></varlistentry>
            </variablelist>
            </para>

            <example id="eg.menus.handlers"><title id="eg.menus.handlers.title">Menu handlers</title>
                The example below contains one main menu and a sub-menu:
                <orderedlist>
                <listitem>The main menu contains a <sgmltag class="attvalue">error</sgmltag> handler.
                        The code attached is called each time the CLI displays an error.
                        The parameters <varname>location</varname> and <varname>message</varname> are provided and may be used.</listitem>
                <listitem>Both menus contain a <sgmltag class="attvalue">exit</sgmltag> handler.
                        The code attached is called whenever the menus exit respectively.</listitem>
                <listitem>Both menus contain a <sgmltag class="attvalue">prompt</sgmltag> handler.
                        The one for the main menu does nothing as far as it returns an empty string.
                        The one for the sub-menu however changes the prompt of it,
                        depending on the <sgmltag class="attvalue">menu-id</sgmltag> parameter value set previously.</listitem>
                </orderedlist>

                    <informaltable frame="none">
                    <tgroup cols="2">
                    <tbody>
                    <row>
                    <entry valign="top">

                        &sample-menu-handler;

                    </entry>
                    <entry><!-- Vertical spacing --></entry>
                    <entry valign="top">
<programlisting>













(2)





(3)










(1)









(2)



(3)




</programlisting>
                    </entry>
                    </row>
                    </tbody>
                    </tgroup>
                    </informaltable>
            </example>

        </section>

        <section id="adv.menus.cpp"><title id="adv.menus.cpp.title"><sgmltag class="element">menu</sgmltag> element management from native code</title>

            <para>
            It is sometime useful to let the user application decide whether a menu should be entered or not.
            </para>

            <para>
            Let's explain the need with an example.
            Imagine the case of a command line leading to the configuration menu of network interfaces.
            Such a command line would contain a string parameter so that the user can give the name of the network interface to configure.
            When using a <sgmltag class="element">menu</sgmltag> element,
            the menu would automatically be entered,
            even though we face a troublesome situation, such as a wrong interface name for instance.
            However, basically, when the user types in a wrong interface name,
            we would rather expect the application to print out an error message and <emphasis>not</emphasis> enter the configuration menu.
            </para>

            <para>
            The example below explains how to implement such behaviour:
            </para>

            <example id="eg.menus.cpp"><title id="eg.menus.cpp.title">Menu management from native code</title>
                The example below contains one main menu and a sub-menu,
                however the sub-menu is not directly accessed thanks to a <sgmltag class="element">menu</sgmltag> element.
                Native code methods are used instead:
                <orderedlist>
                <listitem>Depending on a condition, the C++ <function>cli::Shell::EnterMenu</function> method is called.
                        The <function>cli::Cli::GetMenu</function> method is used in order to retrieve the given <classname>cli::Menu</classname> reference.</listitem>
                <listitem>The same thing can be done for Java, thanks to the <function>cli.Shell.enterMenu</function> and <function>cli.Cli.getMenu</function> methods.</listitem>
                <listitem>An error message is displayed when the menu cannot be entered.</listitem>
                </orderedlist>
                    <informaltable frame="none">
                    <tgroup cols="2">
                    <tbody>
                    <row>
                    <entry valign="top">
<programlisting>





,--
|
+--
|
|
|
|
|
`-&gt;


</programlisting>
                    </entry>
                    <entry><!-- Vertical spacing --></entry>
                    <entry valign="top">

                        &sample-menu-cpp;

                    </entry>
                    <entry><!-- Vertical spacing --></entry>
                    <entry valign="top">
<programlisting>





(1)
(3)
(2)
(3)







</programlisting>
                    </entry>
                    </row>
                    </tbody>
                    </tgroup>
                    </informaltable>
            </example>

        </section>

    </section>

    <section id="adv.shellfeatures"><title id="adv.shellfeatures.title"><classname>Shell</classname> advanced features</title>

        <para>
        The features described in the table below are available from native code.
        Please refer to <productname>doxygen</productname> or <productname>javadoc</productname> documentation for additional information.
        </para>

        <table><title><classname>Shell</classname> advanced features</title>
        <tgroup cols="3" colsep="1" rowsep="1" align="left">
        <colspec colname="description"/><colspec colname="cpp"/><colspec colname="java"/>
        <spanspec spanname="section" namest="description" nameend="java" align="left"/>
        <spanspec spanname="deprecation" namest="cpp" nameend="java" align="left"/>
        <thead>
            <row>   <entry>Description</entry>
                    <entry>C++</entry>
                    <entry>Java</entry></row>
        </thead>
        <tbody>
            <row>   <entry spanname="section">Input management</entry></row>
            <row>   <entry>Input stream access</entry>
                    <entry><ulink url="../doxygen/html/classShell.html#d2291c8673fec28e2f8151f09413b6a1"><function>Shell::GetInput</function></ulink></entry>
                    <entry><ulink url="../javadoc/html/cli/Shell.html#getInput()"><function>Shell.getInput</function></ulink></entry></row>
            <row>   <entry>Output stream access</entry>
                    <entry><ulink url="../doxygen/html/classShell.html#70af9792100a23e8b5f509737269ffe1"><function>Shell::GetStream</function></ulink></entry>
                    <entry><ulink url="../javadoc/html/cli/Shell.html#getStream(int)"><function>Shell.getStream</function></ulink></entry></row>
            <row>   <entry>Output stream positioning</entry>
                    <entry><ulink url="../doxygen/html/classShell.html#b8ef37dc6a98ba279bf0901e2cd9155c"><function>Shell::SetStream</function></ulink></entry>
                    <entry><ulink url="../javadoc/html/cli/Shell.html#setStream(int, cli.OutputDevice.Interface)"><function>Shell.setStream</function></ulink></entry></row>
            <row>   <entry>Enabled/disabled stream accessor</entry>
                    <entry><ulink url="../doxygen/html/classShell.html#de17c6ad4098d8ce4fe9bf5bcc96f172"><function>Shell::StreamEnabled</function></ulink></entry>
                    <entry><ulink url="../javadoc/html/cli/Shell.html#streamEnabled(int)"><function>Shell.streamEnabled</function></ulink></entry></row>
            <row>   <entry>Enable/disable stream</entry>
                    <entry><ulink url="../doxygen/html/classShell.html#bf9b1288aa95e7a4668d43f6e4aa497d"><function>Shell::EnableStream</function></ulink></entry>
                    <entry><ulink url="../javadoc/html/cli/Shell.html#enableStream(int,%20boolean)"><function>Shell.enableStream</function></ulink></entry></row>
            <row>   <entry spanname="section">Presentation</entry></row>
            <row>   <entry>Welcome message setting</entry>
                    <entry><ulink url="../doxygen/html/classShell.html#8778b8def7fbd6df15c9e615530097d4"><function>Shell::SetWelcomeMessage</function></ulink></entry>
                    <entry><ulink url="../javadoc/html/cli/Shell.html#setWelcomeMessage(cli.ResourceString)"><function>Shell.setWelcomeMessage</function></ulink></entry></row>
            <row>   <entry>Bye message setting</entry>
                    <entry><ulink url="../doxygen/html/classShell.html#e80179cef20af1e277ccec1d78d6b775"><function>Shell::SetByeMessage</function></ulink></entry>
                    <entry><ulink url="../javadoc/html/cli/Shell.html#setByeMessage(cli.ResourceString)"><function>Shell.setByeMessage</function></ulink></entry></row>
            <row>   <entry>Prompt message positioning</entry>
                    <entry><ulink url="../doxygen/html/classShell.html#f4e5a2eaa80d146926bcde65351a3e4d"><function>Shell::SetPrompt</function></ulink></entry>
                    <entry><ulink url="../javadoc/html/cli/Shell.html#setPrompt(cli.ResourceString)"><function>Shell.setPrompt</function></ulink></entry></row>
            <row>   <entry>Error formatting</entry>
                    <entry spanname="deprecation">Deprecated since version 2.6, use <link linkend="adv.menus.handlers">error handlers</link> instead.</entry></row>
            <row>   <entry>Help margin accessor</entry>
                    <entry><ulink url="../doxygen/html/classShell.html#88ecb7b84507a6a0a328bbad2f7dc546"><function>Shell::GetHelpMargin</function></ulink></entry>
                    <entry><ulink url="../javadoc/html/cli/Shell.html#getHelpMargin()"><function>Shell.getHelpMargin</function></ulink></entry></row>
            <row>   <entry>Help offset accessor</entry>
                    <entry><ulink url="../doxygen/html/classShell.html#b634fad29d7130768a0d035b4b84fa5c"><function>Shell::GetHelpOffset</function></ulink></entry>
                    <entry><ulink url="../javadoc/html/cli/Shell.html#getHelpOffset()"><function>Shell.getHelpOffset</function></ulink></entry></row>
            <row>   <entry spanname="section">Language settings</entry></row>
            <row>   <entry>Language setting</entry>
                    <entry><ulink url="../doxygen/html/classShell.html#4da46821d20e0c7519dec0ad3e381c3a"><function>Shell::SetLang</function></ulink></entry>
                    <entry><ulink url="../javadoc/html/cli/Shell.html#setLang(int)"><function>Shell.setLang</function></ulink></entry></row>
            <row>   <entry>Language access</entry>
                    <entry><ulink url="../doxygen/html/classShell.html#fae8f69c25a41e89d184e3c49b1b3918"><function>Shell::GetLang</function></ulink></entry>
                    <entry><ulink url="../javadoc/html/cli/Shell.html#getLang()"><function>Shell.getLang</function></ulink></entry></row>
            <row>   <entry spanname="section">Beep settings</entry></row>
            <row>   <entry>Beep configuration setting</entry>
                    <entry><ulink url="../doxygen/html/classShell.html#d14c863b1b25d88be7575e0ed6ee36ae"><function>Shell::SetBeep</function></ulink></entry>
                    <entry><ulink url="../javadoc/html/cli/Shell.html#setBeep(boolean)"><function>Shell.setBeep</function></ulink></entry></row>
            <row>   <entry>Beep configuration access</entry>
                    <entry><ulink url="../doxygen/html/classShell.html#0ac2a73a2b92fcdc38f682a6c2267590"><function>Shell::GetBeep</function></ulink></entry>
                    <entry><ulink url="../javadoc/html/cli/Shell.html#getBeep()"><function>Shell.getBeep</function></ulink></entry></row>
            <row>   <entry spanname="section">Execution</entry></row>
            <row>   <entry>Retrieves the current menu (or one of those in the current menu stack)</entry>
                    <entry><ulink url="../doxygen/html/classShell.html#2a2d05ec7a5c7302d548dd6d064be127"><function>Shell::GetCurrentMenu</function></ulink></entry>
                    <entry><ulink url="../javadoc/html/cli/Shell.html#getCurrentMenu(int)"><function>Shell.getCurrentMenu</function></ulink></entry></row>
            <row>   <entry>Enters a menu</entry>
                    <entry><ulink url="../doxygen/html/classShell.html#fc960160c73e316a462e3dafa76c083e"><function>Shell::EnterMenu</function></ulink></entry>
                    <entry><ulink url="../javadoc/html/cli/Shell.html#enterMenu(cli.Menu, boolean)"><function>Shell.enterMenu</function></ulink></entry></row>
            <row>   <entry>Exits the current menu</entry>
                    <entry><ulink url="../doxygen/html/classShell.html#c155dd1bbf445626efb288e3305d7bcb"><function>Shell::ExitMenu</function></ulink></entry>
                    <entry><ulink url="../javadoc/html/cli/Shell.html#exitMenu(boolean)"><function>Shell.exitMenu</function></ulink></entry></row>
            <row>   <entry>Terminates the shell</entry>
                    <entry><ulink url="../doxygen/html/classShell.html#3d082082d4a4ee56c6d4e82564ae868b"><function>Shell::Quit</function></ulink></entry>
                    <entry><ulink url="../javadoc/html/cli/Shell.html#quit()"><function>Shell.quit</function></ulink></entry></row>
            <row>   <entry>Terminates the shell</entry>
                    <entry><ulink url="../doxygen/html/classShell.html#14b1f93386a3f66d65beec6fbbd80a20"><function>Shell::QuitThreadSafe</function></ulink></entry>
                    <entry><ulink url="../javadoc/html/cli/Shell.html#quitThreadSafe()"><function>Shell.quitThreadSafe</function></ulink></entry></row>
            <row>   <entry spanname="section">Basic command access</entry></row>
            <row>   <entry>Displays help depending on the context of the current line</entry>
                    <entry><ulink url="../doxygen/html/classShell.html#10d22c619c06ef903ffde6153cf7ec1e"><function>Shell::DisplayHelp</function></ulink></entry>
                    <entry><ulink url="../javadoc/html/cli/Shell.html#displayHelp()"><function>Shell.displayHelp</function></ulink></entry></row>
            <row>   <entry>Prints the working menu</entry>
                    <entry><ulink url="../doxygen/html/classShell.html#9e18d5399d3855c50f1d54015e09bc86"><function>Shell::PrintWorkingMenu</function></ulink></entry>
                    <entry><ulink url="../javadoc/html/cli/Shell.html#printWorkingMenu()"><function>Shell.printWorkingMenu</function></ulink></entry></row>
            <row>   <entry>Cleans the screen</entry>
                    <entry><ulink url="../doxygen/html/classShell.html#6b6751262f2ee8f36302902747ed56a2"><function>Shell::CleanScreen</function></ulink></entry>
                    <entry><ulink url="../javadoc/html/cli/Shell.html#cleanScreen(boolean)"><function>Shell.cleanScreen</function></ulink></entry></row>
            <row>   <entry spanname="section">Debug</entry></row>
            <row>   <entry>Configuration menu enabling</entry>
                    <entry><ulink url="../doxygen/html/classCli.html#fcef4a4232b6a21d8a6262adb51b8b49"><function>Cli::EnableConfigMenu</function></ulink></entry>
                    <entry><ulink url="../javadoc/html/cli/Cli.html#enableConfigMenu(boolean)"><function>Cli.enableConfigMenu</function></ulink></entry></row>
            <row>   <entry>Configuration menu enabled status</entry>
                    <entry><ulink url="../doxygen/html/classCli.html#2dba8bf5e11a92c68324cf77c59413a2"><function>Cli::IsConfigMenuEnabled</function></ulink></entry>
                    <entry><ulink url="../javadoc/html/cli/Cli.html#isConfigMenuEnabled()"><function>Cli.isConfigMenuEnabled</function></ulink></entry></row>
        </tbody>
        </tgroup>
        </table>
    </section>

    <section id="adv.traces"><title id="adv.traces.title">Traces</title>

        <para>
        The CLI library has an internal traces system.
        All traces are attached to a class of traces.
        By the way, you can control which traces have to be displayed thanks to the traces class filter.
        When compiled in debug, the CLI library natively includes a traces menu to see and change this filter.
        </para>

        <para>
        The <classname>cli::Traces</classname> and <classname>cli::TraceClass</classname> classes
        are defined in <filename class="headerfile">cli/traces.h</filename>, which is available to you.
        The traces system can be accessed through the singleton <function>cli::GetTraces</function>.
        This gives you the opportunity to use it to control the trace filter
        through the <function>cli::Traces::SetFilter</function> and <function>cli::Traces::SetAllFilter</function> methods.
        You may also use it for your own traces through the <function>cli::Traces::Trace</function> method.
        </para>

        <para>
        <classname>cli::Traces</classname> uses an output device that defaults to stderr.
        You may change this device through the <function>cli::Traces::SetStream</function> method,
        and redirect traces to a file for instances.
        Changing this device for the null device is a way to disable all traces.
        </para>

        <note>
        The io_device unit test gives an example of traces redirection to a file.
        </note>.

    </section>

    <section id="adv.iodevices"><title id="adv.iodevices.title">Define your own input/output device</title>

        <section id="adv.iodevices.provided"><title>Input/output devices provided by the CLI library</title>

            <para>
            The CLI library has generic classes defining input/output device interfaces:
            <classname>cli::OutputDevice</classname>, <classname>cli::IODevice</classname> and <classname>cli::NonBlockingIODevice</classname>.
            The CLI library gives several implementations of these generic classes:
                <informalfigure>
                    <mediaobject>
                        <imageobject><imagedata fileref="../doxygen/html/classOutputDevice__inherit__graph.png" srccredit="doxygen"/></imageobject>
                    <textobject><phrase>Input/output devices class hierarchy.</phrase></textobject>
                    <caption><para>Input/output devices class hierarchy.</para></caption>
                    </mediaobject>
                </informalfigure>
            <variablelist>
            <varlistentry><term><classname>cli::Console</classname></term>
                <listitem>Console input/output device.</listitem></varlistentry>
            <varlistentry><term><classname>cli::InputFileDevice</classname></term>
                <listitem>Reading from a file can be useful for replaying scripts for instance.</listitem></varlistentry>
            <varlistentry><term><classname>cli::IOMux</classname></term>
                <listitem>Input and output can be multiplexed thanks to this class.
                    More information is available in the corresponding <link linkend="adv.IOMux">section</link>.</listitem></varlistentry>
            <varlistentry><term><classname>cli::SingleCommand</classname></term>
                <listitem>Single command device object.
                    This device allows you define a single command line
                    and have it executed.</listitem></varlistentry>
            <varlistentry><term><classname>cli::TelnetConnection</classname></term>
                <listitem>Telnet connection input/output device.
                    <note>
                    The telnet protocol is not fully managed for the moment.
                    Use simple TCP client connections for now
                    with <application>teraterm</application> for instance.
                    </note>
                </listitem></varlistentry>
            <varlistentry><term><classname>cli::OutputFileDevice</classname></term>
                <listitem>Redirect output to a file thanks to this device.</listitem></varlistentry>
            <varlistentry><term><classname>cli::StringDevice</classname></term>
                <listitem>Output to a string object.
                    This device can be useful for unit-test among others.</listitem></varlistentry>
            </variablelist>
            </para>

            <note>
            The <classname>ui::Text</classname> class is a specific class dedicated to
            <link linkend="ui.more"><classname>ui::More</classname></link> and <link linkend="ui.less"><classname>ui::Less</classname></link> management.
            Therefore it is not discussed in this section.
            </note>

        </section>

        <section id="adv.iodevices.inherit"><title>Inherit from generic input/output devices interfaces</title>

            <para>
            You may need some support for other devices (such as RS232 for instance).
            Feel free to create new classes inheriting from generic input/output device interfaces, and implement what you need.
            </para>

            <para>
            When inheriting from <classname>cli::OutputDevice</classname>, <classname>cli::IODevice</classname> or <classname>cli::NonBlockingIODevice</classname>,
            the following handlers must/may be overridden:

                <table><title>Output device handlers</title>
                    <para>
                    See <ulink url="../doxygen/html/classOutputDevice.html"><classname>cli::OutputDevice</classname></ulink> for C++,
                    <ulink url="../javadoc/html/cli/OutputDevice.Java.html"><classname>cli.OutputDevice.Java</classname></ulink> for Java.
                    </para>
                <tgroup cols="4" colsep="1" rowsep="1" align="left">
                <colspec colname="cpp"/><colspec colname="java"/><colspec colname="mandatory"/><colspec colname="description"/>
                <thead>
                    <row>   <entry>C++</entry>
                            <entry>Java</entry>
                            <entry></entry>
                            <entry>Description</entry></row>
                </thead>
                <tbody>
                    <row>   <entry><ulink url="../doxygen/html/classOutputDevice.html#0c933e5b3de0d0e48dcbd4ba56b7f147"><function>OpenDevice</function></ulink></entry>
                            <entry><ulink url="../javadoc/html/cli/OutputDevice.Java.html#openDevice()"><function>openDevice</function></ulink></entry>
                            <entry>Mandatory</entry>
                            <entry>
                                <para>
                                Device opening handler.
                                This is the place for device initializations.
                                </para>
                            </entry></row>
                    <row>   <entry><ulink url="../doxygen/html/classOutputDevice.html#4a3680bb550c7cb6b08f1cef6124f3c2"><function>CloseDevice</function></ulink></entry>
                            <entry><ulink url="../javadoc/html/cli/OutputDevice.Java.html#closeDevice()"><function>closeDevice</function></ulink></entry>
                            <entry>Mandatory</entry>
                            <entry>
                                <para>
                                Device closure handler.
                                Free resources allocated in <function>OpenDevice</function>.
                                </para>
                            </entry></row>
                    <row>   <entry><ulink url="../doxygen/html/classOutputDevice.html#a4653710e8f6f3d9bd53cdfec4fe253d"><function>PutString</function></ulink></entry>
                            <entry><ulink url="../javadoc/html/cli/OutputDevice.Java.html#put(java.lang.String)"><function>put</function></ulink></entry>
                            <entry>Mandatory</entry>
                            <entry>
                                <para>
                                Character output handler.
                                </para>

                                <note>
                                Please note the <command>check io-device outputs</command> command in the <command>cli-config</command> menu in debug mode.
                                This commands tries to output every <type>char</type> from range 0 to 255.
                                This routine may help you to integrate your output device implementation.
                                </note>

                                <note>
                                Since version 2.3, the <classname>cli::OutputDevice</classname> basic class does not manage an "end of line" pattern anymore.
                                It is up to the sub-classes to trap <code class="value">'\n'</code> characters in the <function>PutString</function> handler,
                                and do the appropriate stuff at this time.
                                </note>
                            </entry></row>
                    <row>   <entry><ulink url="../doxygen/html/classOutputDevice.html#4b4cc34728972042f3a79e5e63178b7b"><function>Beep</function></ulink></entry>
                            <entry><ulink url="../javadoc/html/cli/OutputDevice.Java.html#beep()"><function>beep</function></ulink></entry>
                            <entry>Optional</entry>
                            <entry>
                                <para>
                                Beep handler.
                                Default implementation outputs a '\a' character.
                                </para>
                            </entry></row>
                    <row>   <entry><ulink url="../doxygen/html/classOutputDevice.html#04c4210231e603e0d398698885a9c5de"><function>CleanScreen</function></ulink></entry>
                            <entry><ulink url="../javadoc/html/cli/OutputDevice.Java.html#cleanScreen()"><function>cleanScreen</function></ulink></entry>
                            <entry>Optional</entry>
                            <entry>
                                <para>
                                Clean screen handler.
                                Default implementation prints out 50 blank lines.
                                </para>
                            </entry></row>
                    <row>   <entry><ulink url="../doxygen/html/classOutputDevice.html#3cec03b49e12d20ee63f5ca9037f67da"><function>GetScreenInfo</function></ulink></entry>
                            <entry><ulink url="../javadoc/html/cli/OutputDevice.Java.html#getScreenInfo()"><function>getScreenInfo</function></ulink></entry>
                            <entry>Optional</entry>
                            <entry>
                                <para>
                                Screen information:
                                <itemizedlist>
                                <listitem>Dimensions: width and height,</listitem>
                                <listitem>True cls characteristic:
                                            whether the device implements an efficient "clean screen" feature,</listitem>
                                <listitem>Line wrapping characteristic:
                                            true when the device automatically adds a new line when the cursor reaches the right border of the screen.</listitem>
                                </itemizedlist>
                                </para>

                                <para>
                                Default implementation indicates a 80x20 screen with no true "clean screen" feature nor line wrapping.
                                Thus, overriding this handler is optional, but you'd better do it,
                                especially if you intend to use <classname>ui::More</classname> or <classname>ui::Less</classname> objects.
                                </para>
                            </entry></row>
                    <row>   <entry><ulink url="../doxygen/html/classOutputDevice.html#3be4874ce99500243bfaeada5091f3f4"><function>WouldOutput</function></ulink></entry>
                            <entry><ulink url="../javadoc/html/cli/OutputDevice.Java.html#wouldOutput(cli.OutputDevice.Interface)"><function>wouldOutput</function></ulink></entry>
                            <entry>Optional</entry>
                            <entry>
                                <para>
                                Stack overflow protection.
                                Determines whether the current device would output the given device in any way.
                                Default implementation checks whether CLI_Device is the self device.
                                </para>

                                <para>
                                If you implement output redirection, don't forget override and call the <function>WouldOutput</function> handler,
                                like <classname>cli::IOMux</classname> does.
                                This method has been designed to improve consistency, and prevent stack overflow
                                because of possible infinite loop of calls on character output.
                                </para>
                            </entry></row>
                </tbody>
                </tgroup>
                </table>

                <table><title>Input device handlers</title>
                    <para>
                    See <ulink url="../doxygen/html/classIODevice.html"><classname>cli::IODevice</classname></ulink> for C++,
                    <ulink url="../javadoc/html/cli/IODevice.Java.html"><classname>cli.IODevice</classname></ulink> for Java.
                    </para>
                <tgroup cols="4" colsep="1" rowsep="1" align="left">
                <colspec colname="cpp"/><colspec colname="java"/><colspec colname="mandatory"/><colspec colname="description"/>
                <thead>
                    <row>   <entry>C++</entry>
                            <entry>Java</entry>
                            <entry></entry>
                            <entry>Description</entry></row>
                </thead>
                <tbody>
                    <row>   <entry><ulink url="../doxygen/html/classIODevice.html#7bafac5c500746f742aa289f33e38feb"><function>GetKey</function></ulink></entry>
                            <entry><ulink url="../javadoc/html/cli/IODevice.Java.html#getKey()"><function>getKey</function></ulink></entry>
                            <entry>Mandatory</entry>
                            <entry>
                                <para>
                                Input key capture handler (blocking call).
                                Base implementation provides regular conversions from <type>char</type> to <type>cli::KEY</type> types.
                                </para>

                                <note>
                                Please note the <command>check io-device</command> command in the <command>cli-config</command> menu in debug mode.
                                This command asks you to press each character managed by the library, in order to make a complete inventory.
                                This routine, with the use of traces (see <link linkend="adv.traces" endterm="adv.traces.title"/>),
                                may help you to integrate your input device implementation.
                                </note>
                            </entry></row>
                    <row>   <entry><ulink url="../doxygen/html/classIODevice.html#803bd02bf68fcbb8b40b50548b1cfb8b"><function>GetLocation</function></ulink></entry>
                            <entry><ulink url="../javadoc/html/cli/IODevice.Java.html#getLocation()"><function>getLocation</function></ulink></entry>
                            <entry>Optional</entry>
                            <entry>
                                <para>
                                Input location.
                                Return a text indicating where the location of the last character input.
                                Useful when developing compiler applications.
                                </para>
                            </entry></row>
                    <row>   <entry><ulink url="../doxygen/html/classIODevice.html#d03f2900ba78cac1f7e7ba53633ec607"><function>WouldInput</function></ulink></entry>
                            <entry><ulink url="../javadoc/html/cli/IODevice.Java.html#wouldInput(cli.IODevice.Interface)"><function>wouldInput</function></ulink></entry>
                            <entry>Optional</entry>
                            <entry>
                                <para>
                                Stack overflow protection.
                                Determines whether the current device would input the given device in any way.
                                Default implementation checks whether CLI_Device is the self device.
                                </para>

                                <para>
                                If you implement input redirection, don't forget override and call the <function>WouldInput</function> handler,
                                like <classname>cli::IOMux</classname> does.
                                This method has been designed to improve consistency,
                                and prevent stack overflow because of possible infinite loop of calls on character input.
                                </para>
                            </entry></row>
                </tbody>
                </tgroup>
                </table>

                <table><title>Non blocking device handlers</title>
                    <para>
                    See <ulink url="../doxygen/html/classNonBlockingIODevice.html"><classname>cli::NonBlockingIODevice</classname></ulink> for C++,
                    <ulink url="../javadoc/html/cli/NonBlockingIODevice.Java.html"><classname>cli.NonBlockingIODevice</classname></ulink> for Java.
                    See also <link linkend="adv.non-blocking" endterm="adv.non-blocking.title"/> section for a specific explanation of non blocking devices.
                    </para>
                <tgroup cols="4" colsep="1" rowsep="1" align="left">
                <colspec colname="cpp"/><colspec colname="java"/><colspec colname="mandatory"/><colspec colname="description"/>
                <thead>
                    <row>   <entry>C++</entry>
                            <entry>Java</entry>
                            <entry></entry>
                            <entry>Description</entry></row>
                </thead>
                <tbody>
                    <row>   <entry><ulink url="../doxygen/html/classNonBlockingIODevice.html#b3bd1255c2b1f9416fec8a9dbc5bb35a"><function>WaitForKeys</function></ulink></entry>
                            <entry><ulink url="../javadoc/html/cli/NonBlockingIODevice.Java.html#waitForKeys(int)"><function>waitForKeys</function></ulink></entry>
                            <entry>Optional</entry>
                            <entry>
                                <para>
                                When a blocking call requires keys to be entered before returning,
                                this method makes the thread waits smartly depending on the integration context.
                                </para>

                                <para>
                                Warning!
                                This kind of wait implementation may cause nested peek message loops,
                                but if you are using <link linkend="ui">UI features</link>, you might need to implement such kind of loops.
                                </para>
                            </entry></row>
                    <row>   <entry><ulink url="../doxygen/html/classNonBlockingIODevice.html#e7f95aa8e13de4a2b4a271da01b19db2"><function>OnKey</function></ulink></entry>
                            <entry><ulink url="../javadoc/html/cli/NonBlockingIODevice.Java.html#onKey(int)"><function>onKey</function></ulink></entry>
                            <entry>Optional</entry>
                            <entry>
                                <para>
                                This method is declared as handler as a consequence of the previous <function>WaitForKeys</function> handler.
                                When the device is waiting for keys, this handler allows you to trap the information of incoming keys,
                                and make the waiting loop exit.
                                </para>
                            </entry></row>
                </tbody>
                </tgroup>
                </table>
            </para>

        </section>

    </section>

    <section id="adv.IOMux"><title>Input / output multiplexer device</title>

        <para>
        Considering the input device could be not the same all along CLI execution,
        I have created an input / output multiplexer device.
        Thus, this kind of device allows you to mix several input devices
        and redirect outputs to other devices.
        </para>

        <para>
        This device may seem complex at first.
        It can be useful however to create simple compilers as described in the <link linkend="adv.compilers">section after</link>.
        </para>

    </section>

    <section id="adv.quit"><title>Thread-safe termination</title>

        <para>
        Some of you may need the ability to stop the CLI execution immediately on certain events.
        </para>

        <para>
        It is strongly recommended not to kill brutally the thread the CLI is running within.
        </para>

        <para>
        The <function>cli::Shell::QuitThreadSafe</function> method has been designed for that need.
        This method indicates the shell that it should stop its execution as soon as possible, i.e. as soon as a character is entered for most cases.
        By the way, if the input device of the shell is a personal input device you have designed for your special needs,
        you could also have this device return <code class="value">cli::NULL_KEY</code> immediately.
        </para>

    </section>

    <section id="adv.non-blocking"><title id="adv.non-blocking.title">Non blocking execution</title>

        <para>
        The regular integration of the CLI is to have the shell running its main loop in a dedicated thread or a process,
        waiting for the input device to return characters, thanks to the blocking call <function>cli::IODevice::GetKey</function>.
        </para>

        <para>
        This is often source of problems when the integration takes place in a mono-thread application (such as Windows MFC for instance).
        Such kind of applications is not usually designed to safely manage threading and access concurrency.
        That's the reason why a "non blocking" execution mode has been developed.
        </para>

        <para>
        It is available by simply giving a <classname>cli::NonBlockingIODevice</classname> input device to the shell for its execution.
        It is up to you to:
        <itemizedlist>
        <listitem>Inherit from this abstract class (see <link linkend="adv.iodevices" endterm="adv.iodevices.title"/>),</listitem>
        <listitem>Have your characters being trapped by the application,</listitem>
        <listitem>Push them to the shell thanks to the protected <function>cli::NonBlockingIODevice::OnKey</function> method.</listitem>
        </itemizedlist>
        </para>

        <example id="eg.non-blocking"><title id="eg.non-blocking.title">Non blocking execution</title>
            The following Java example illustrates the execution thread when using a non blocking device:
<programlisting>
cli.Cli cli_Cli = new MyCli();
cli.Shell cli_Shell = new cli.Shell(cli_Cli);
MyNonBlockingIODevice cli_Device = new MyNonBlockingIODevice(); // extends cli.NonBlockingIODevice

// Since cli_Device is a non blocking device, the following call does not block the execution thread.
cli_Shell.run(cli_Device);
// cli_Shell is still running at this point!

// Let's push characters...
cli_Device.onKey(cli.OutputDevice.KEY_q);
cli_Device.onKey(cli.OutputDevice.KEY_u);
cli_Device.onKey(cli.OutputDevice.KEY_i);
cli_Device.onKey(cli.OutputDevice.KEY_t);
cli_Device.onKey(cli.OutputDevice.ENTER);
// Since the 'quit' command has been pushed, cli_Shell is not running anymore at this point!
</programlisting>
        </example>

    </section>

    <section id="adv.dimension"><title>Embedded integration and memory management</title>

        <para>
        When integrating the CLI in an embedded context, memory considerations become a critical point.
        </para>

        <para>
        The library basically uses the STL library for strings, queues and maps basic objects.
        But in an embedded integration, it is usually preferred not to use STL at all, because the memory is not known to be safely managed.
        That's the reason why an <emphasis>inner</emphasis> toolkit implement is provided with the CLI library.
        This toolkit, enabled through the <varname>CLI_NO_STL</varname> compilation directive,
        provides an implementation of strings, queues and maps with a limit of memory extension.
        </para>

        <para>
        Eventually, you may also have a look at the header file <filename>constraints.h</filename>.
        This header defines a set of constants that are overridable at compile time.
        </para>

    </section>

    <section id="adv.pch"><title id="adv.pch.title">Pre-compiled headers</title>

        <para>
        C++ CLI is ready for pre-compiled headers.
        Every CLI source starts its inclusions with:
            <programlisting>#include "cli/pch.h"</programlisting>
        A default empty <filename>cli/pch.h</filename> is provided with C++ CLI includes,
        so that builds work on even though pre-compiled headers are not set up.
        </para>

        <para>
        I you wish to use pre-compiled headers, I advise you not to modify the header provided with the library.
        Indeed, if you modify that header, then when you upgrade the CLI library with later versions, you may loose your changes by the way.
        You'd better create your own <filename>cli/pch.h</filename> somewhere by your own sources,
        and configure include paths so that your <filename>cli/pch.h</filename> file is included before the one provided by the library.
        Then include <filename>cli/pch.h</filename> in your pre-compiled source object to finalize pre-compilation settings.
        </para>

        <note>
        As far as the CLI library in its default configuration uses the Standard Library headers, pre-compiled headers really fastens your builds.
        </note>

    </section>

    <section id="adv.compilers"><title>Making compilers</title>

        <para>
        The CLI library can be used to make out compilers of simple syntaxes.
        I'm used to combine the <classname>cli::InputFileDevice</classname> class to read from files,
        and the <classname>cli::IOMux</classname> class to read from a set of files one after the other.
        </para>

        <para>
        The <classname>cli::InputFileDevice</classname> provides two methods very useful in that case:
        <variablelist>
        <varlistentry><term><function>EnableSpecialCharacters</function></term>
                <listitem>Makes the <classname>cli::InputFileDevice</classname> object enable or disable special characters reading.
                When the special characters are disabled, tabulations will be understood like spaces, interrogation dots will be escaped...
                which is more convenient for a compiler implementation.</listitem></varlistentry>
        <varlistentry><term><function>GetLocation</function></term>
                <listitem>When an error occurs, this method can be called to retrieve the current position of reading in the input file.</listitem></varlistentry>
        </variablelist>
        </para>

        <note>
        The <ulink url="http://alexis.royer.free.fr/Watch">Watch project</ulink> does implement such kind of design.
        </note>

    </section>

    <section id="adv.noxmlres"><title>Without the XML resource file</title>

        <para>
        Some of you could find the library interesting for what it already implements,
        but not the XML resource file, too limitative maybe.
        </para>

        <para>
        Indeed the XML resource file aims to facilitate and fasten the development.
        But you could plan using library objects directly,
        and maybe inherit from them in order to improve the stuff.
        </para>

        <para>
        Well... Up to you!
        </para>

    </section>

</section>
