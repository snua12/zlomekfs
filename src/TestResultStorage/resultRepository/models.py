from django.db import models



UUID_LEN = 36
NAME_LEN = 64
TEST_NAME_LEN = NAME_LEN
MACHINE_NAME_LEN = NAME_LEN
TEST_DESC_LEN = 256
FILE_NAME_LEN = 100
PROFILE_NAME_LEN = 100
DUMP_DIRECTORY = "dumps"

class BatchRun(models.Model):
    startTime = models.DateTimeField(
                verbose_name = "Date and time when the BatchRUn has started.",
                db_index = True)
    duration = models.PositiveIntegerField(verbose_name = "Duration of batch \
                (should be set at the end or derived from last test values",
                blank = True)
    hasFinished = models.BooleanField(verbose_name = "If this batch still runs or not",
                default = False)
    batchUuid = models.CharField(max_length = UUID_LEN, unique = True,
                verbose_name = "UUid for this batch - generated by runner in time of start")
    sourceRepositoryUrl = models.URLField(verify_exists = False,
                verbose_name = "Url to repository from which sources has been fetched",
                blank = True, db_index = True)
    repositoryRevision = models.PositiveIntegerField(
                verbose_name = "Revision of sources build for tests",
                blank = True)
    description = models.CharField(max_length = TEST_DESC_LEN,
                verbose_name = "Short description of batch.",
                blank = True)
    profile = models.CharField(max_length = PROFILE_NAME_LEN,
                verbose_name = "Profile in which sources had been build for tests",
                blank = True, db_index = True)
    machineName = models.CharField(max_length = MACHINE_NAME_LEN,
                verbose_name = "Hostname of machine on which has this batch run",
                blank = True, db_index = True)
    
    def __unicode__(self):
        return self.batchUuid
        
    class Meta:
        get_latest_by = "order_startTime"
        ordering = ['startTime', 'hasFinished']
    
    class Admin:
        pass

TEST_RESULT_CHOICES = (
    (0, 'Success'),
    (1, 'Failure'),
    (2, 'Error'),
    (-1, 'Skipped'),
    (-2, 'Unknown'),
)

class TestRun(models.Model):
    batchId = models.ForeignKey(BatchRun, verbose_name = "Batch in which this test has run.",
                db_index = True)
    startTime = models.DateTimeField(verbose_name = "Date and time when the test has started")
    duration = models.PositiveIntegerField(verbose_name = "Duration of test run in seconds",)
    runUuid = models.CharField(max_length = UUID_LEN, unique = True,
                verbose_name = "Uuid for this test (generated by runner in time of report.")
    testName = models.CharField(max_length = TEST_NAME_LEN,
                verbose_name = "Name of test ie module.class.testName or simple testName",
                db_index = True)
    description = models.CharField(max_length = TEST_DESC_LEN,
                verbose_name = "Short description of test run.",
                blank = True)
    result = models.PositiveIntegerField(choices=TEST_RESULT_CHOICES,
                verbose_name = "If test has successed, failed or what",
                db_index = True)
    sourceRepositoryPath = models.CharField(max_length = FILE_NAME_LEN,
                verbose_name = "Path to file containing the test relative to \
                            BatchRun.sourceRepositoryUrl",
                blank = True,
                db_index = True)
    
    def __unicode__(self):
        return self.testName
    
    class Meta:
        get_latest_by = "order_startTime"
        order_with_respect_to = 'batchId'
        ordering = ['batchId', 'startTime']
    
    class Admin:
        pass

class TestRunData(models.Model):
    runId = models.ForeignKey(TestRun, verbose_name = "Test run which generates this data",
                db_index = True)
    dumpFile = models.FileField(verbose_name = "Tar with dumped test run data (snapshots, etc)",
                max_length = FILE_NAME_LEN, upload_to = DUMP_DIRECTORY,
                blank = True, core = True, editable = False, unique = True)
    backtrace = models.TextField(verbose_name = "Backtrace of failure (if present)",
                blank = True,  core = True)
    errText = models.TextField(verbose_name = "Error text generated by test",
                blank = True,  core = True)
    
    def __unicode__(self):
        return self.dumpFileName
        
    class Meta:
        get_latest_by = "order_runId"
        order_with_respect_to = 'runId'
        ordering = ['runId']
    
    class Admin:
        pass
        
