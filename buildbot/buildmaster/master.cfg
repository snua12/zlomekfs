# -*- python -*-
# ex: set syntax=python:

# This is a sample buildmaster config file. It must be installed as
# 'master.cfg' in your buildmaster's base directory (although the filename
# can be changed with the --basedir option to 'mktap buildbot master').

# It has one job: define a dictionary named BuildmasterConfig. This
# dictionary has a variety of keys to control different aspects of the
# buildmaster. They are documented in docs/config.xhtml .


# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.

import logging
import copy

log = logging.getLogger('buildbot.master')

WAIT_BEFORE_BUILD = 1

c = BuildmasterConfig = {}

from buildbot.buildslave import BuildSlave
c['slaves'] = [BuildSlave("bug", "h2so42"),BuildSlave("zen", "h2so42")]

c['slavePortnum'] = "tcp:9989"

c['projectName'] = 'ZloFS'
c['projectURL'] = 'http://dsrg.mff.cuni.cz/~ceres/prj/zlomekFS'
c['buildbotURL'] = 'http://10.0.0.2:8010' 

####### CHANGESOURCES

# the 'sources' list tells the buildmaster how it should find out about
# source code changes. Any class which implements IChangeSource can be added
# to this list: there are several in buildbot/changes/*.py to choose from.

def split_file_branches(path):
    pieces = path.split('/')
    if pieces[0] == 'trunk':
        return (None, '/'.join(pieces[1:]))
    elif pieces[0] == 'branches':
        if len(pieces) > 3:
            return ('/'.join(pieces[0:3]),
                '/'.join(pieces[3:]))
        else:
            return ('/'.join(pieces[0:2]),
                '/'.join(pieces[2:]))
    else:
        return None

from buildbot.changes.svnpoller import SVNPoller

c['change_source'] = [SVNPoller (svnurl = 'https://shiva.ms.mff.cuni.cz/svn/zzzzzfs',
                                     pollinterval = 60,
                                     split_file = split_file_branches)]


c['schedulers'] = []


class DependRunner(object):
    def __init__(self, schedulers):
        self.schedulers = schedulers
    
    def __call__(self, *arg, **kwarg):
        for scheduler in self.schedulers:
            scheduler.setTimer(0)


from buildbot.scheduler import Scheduler
s_zouhar_zen_unit = Scheduler("s_zouhar_zen_unit",
                  'branches/zouhar/zen-unit',
                  60 * WAIT_BEFORE_BUILD,
                  ["b_zouhar_zen-unit_32", "b_zouhar_zen-unit_64"])
c['schedulers'].append(s_zouhar_zen_unit)


s_zouhar_zfs = Scheduler("s_zouhar_zfs",
                  'branches/zouhar/zfs',
                  60 * WAIT_BEFORE_BUILD,
                  ["b_zouhar_zfs_32", "b_zouhar_zfs_64"])
c['schedulers'].append(s_zouhar_zfs)


s_zouhar_syplog = Scheduler("s_zouhar_syplog",
                  'branches/zouhar/syplog',
                  60 * WAIT_BEFORE_BUILD,
                  ["b_zouhar_syplog_32", "b_zouhar_syplog_64"])
c['schedulers'].append(s_zouhar_syplog)

s_zouhar_TestResultStorage = Scheduler("s_zouhar_TestResultStorage",
                  'branches/zouhar/TestResultStorage',
                  60 * WAIT_BEFORE_BUILD,
                  ["b_zouhar_TestResultStorage_32", "b_zouhar_TestResultStorage_64"])
c['schedulers'].append(s_zouhar_TestResultStorage)

s_zouhar_insecticide = Scheduler("s_zouhar_insecticide",
                  'branches/zouhar/insecticide',
                  60 * WAIT_BEFORE_BUILD,
                  ["b_zouhar_insecticide_32", "b_zouhar_insecticide_64"])
c['schedulers'].append(s_zouhar_insecticide)


s_zouhar_pysyplog = Scheduler("s_zouhar_pysyplog",
                  'branches/zouhar/syplog/py',
                  60 * WAIT_BEFORE_BUILD,
                  ["b_zouhar_pysyplog_32", "b_zouhar_pysyplog_64"])
c['schedulers'].append(s_zouhar_pysyplog)

s_zouhar_zfsd_status = Scheduler("s_zouhar_zfsd_status",
                  'branches/zouhar/zfs/zfsd-status-py',
                  60 * WAIT_BEFORE_BUILD,
                  ["b_zouhar_zfsd-status_32", "b_zouhar_zfsd-status_64"])
c['schedulers'].append(s_zouhar_zfsd_status)




s_zouhar_zen_unit.subscribeToSuccessfulBuilds(DependRunner([s_zouhar_syplog, s_zouhar_zfs]))
s_zouhar_syplog.subscribeToSuccessfulBuilds(DependRunner([s_zouhar_zfs, s_zouhar_pysyplog]))
s_zouhar_zfs.subscribeToSuccessfulBuilds(DependRunner([s_zouhar_zfsd_status]))
s_zouhar_TestResultStorage.subscribeToSuccessfulBuilds(DependRunner([s_zouhar_insecticide]))


'''
s_zouhar_syplog-py = Dependent("s_zouhar-syplog-py", s_zouhar_syplog,
                             ["b_zouhar-syplog-pu"])

s_zouhar_test = Dependent("zouhar-test", s_zouhar_install,
                          ["zouhar-test"])

'''



from buildbot.process import factory
from buildbot.steps import source, shell, dummy

from TestResultStorage.resultRepository.models import BatchRun, ProfileInfo, Project, TestRun
import datetime
import uuid

class CreateBatchStep(shell.ShellCommand):
    def __init__(self, repository, branch, project, env,
                 **kwargs):
        self.repository = repository
        self.project = project
        self.branch = branch
        self.env = env
        shell.ShellCommand.__init__(self, env = env, **kwargs)
        
    def start(self):
        project = Project.objects.get_or_create(projectName = self.project, sourceRepositoryUrl = self.repository)
        batch = BatchRun()
        batch.startTime = datetime.datetime.now()
        batch.result = -2
        if project:
        	batch.project = project[0]
        batch.branch = self.branch
        batch.repositoryRevision = self.getProperty('revision')
#        self.batch.duration = 0
        batch.description = "Buildbot batch for %s in rev %s" % (self.getProperty('branch'),
                                  str(self.getProperty('revision')))
        batch.machineName = self.getProperty('slavename')
        
        batch.profileName = self.env['PROFILE_NAME']
        
        batch.save()
        self.setProperty('batchUuid', batch.id)
        self.env['BATCHUUID'] = str(batch.id)
        if not batch.id:
            log.error("Error: batch id is null")
        else:
            self.appendProfileInfo(batch)
        
        shell.ShellCommand.start(self)
    
    def appendProfileInfo(self, batch):
        for key in self.env.keys():
            info = ProfileInfo.objects.get_or_create(variableName = str(key),
                                        variableValue = str(self.env[key]))
            batch.profileInfo.add(info[0])
        
        batch.save()

class FinalizeBatchStep(shell.ShellCommand):
    def __init__(self, env,
                 **kwargs):
        self.env = env
        shell.ShellCommand.__init__(self, env = env, **kwargs)
    
    def start(self):
        batch = BatchRun.objects.get(id = self.env['BATCHUUID'])
        if batch:
            endTime = datetime.datetime.now()
            startTime = batch.startTime
            
            #we assume that run is shorter than month
            duration = endTime.day - startTime.day
            duration = duration * 24 + endTime.hour - startTime.hour
            duration = duration * 60 + endTime.minute - startTime.minute
            duration = duration * 60 + endTime.second - startTime.second
            duration = duration * 1000 + (endTime.microsecond - startTime.microsecond) / 1000
            tests = TestRun.objects.filter (batchId = batch)
            batch.testCount = tests.count()
            
            if tests.filter(result=2).count(): #errors
            	batch.result = 2
            elif tests.filter(result=1).count(): #failures
            	batch.result = 1
            elif tests.filter(result=-2).count(): #unknown
            	pass
            else: #we assume skipped tests as o.k.
            	batch.result = 0
            
            batch.duration = duration
            batch.hasFinished = True
            batch.save()
        
        shell.ShellCommand.start(self)
        
class MakeRpm(shell.Compile):
    descriptionDone = "rpm"
    description = "build rpm"
    def start(self):
        revision = self.getProperty("revision")
        if revision:
            self.setCommand(["make", "rpm", "REVISION=%s" %revision ])
        else:
            self.setCommand(["make", "rpm"])
        shell.ShellCommand.start(self)
             
c['builders'] = []

#profile = None

from profile_default import profile_default
profile = profile_default

file = open ('/home/buildmaster/profile', 'w')
file.write(str(profile))
file.close()

#testStep = shell.ShellCommand(command = ['make', '-C', 'tests/nose-tests', 'test'], env = profile)

for (package, branch) in [
	("zen-unit", "zen-unit"),
	("syplog", "syplog"),
	("pysyplog", "syplog/py"),
	("zfs", "zfs"),
	("zfsd-status", "zfs/zfsd-status-py"),
	("TestResultStorage", "TestResultStorage"),
	("insecticide", "insecticide")
				]:
	
	for (slaveName, arch) in [('bug', '32'), ('zen', '64')]:
		factory_inst = factory.BuildFactory()
		# we need copy for each builder to prevent BATCHUUID collisions
		prof = copy.copy(profile)
		
		factory_inst.addStep(source.SVN(mode='update', 
				baseURL='https://shiva.ms.mff.cuni.cz/svn/zzzzzfs/', 
				defaultBranch='branches/zouhar/' + branch), env = prof)
		
		# make step is included in rpm step   
		#    factory_inst.addStep(shell.Compile, description = "make",
		#                         descriptionDone = "build", command='make all', env = prof)
		#factory_inst.addStep(shell.Compile, command='make package', description = "build package",
		#                     descriptionDone = "packaging", env = prof)
		factory_inst.addStep(MakeRpm, env = prof)
		
		factory_inst.addStep(shell.ShellCommand,
				command = 'rpm -Uvh --oldpackage --replacepkgs build/RPMS/*/' + package + '*.rpm || [ $? = 6 ]',
				description = "install rpm", env = prof)
		#create batch
		factory_inst.addStep(CreateBatchStep,
					repository = 'https://shiva.ms.mff.cuni.cz/svn/zzzzzfs',
					branch = 'branches/zouhar/' + branch, project = package,
					env = prof, description = "creating batch",
					descriptionDone = "batch creation", command = "echo batch")
		
		factory_inst.addStep(shell.Test, command="make test", description = "test",
					descriptionDone = "tests", env = prof)
		#finalize batch
		factory_inst.addStep(FinalizeBatchStep, env = prof, description = "finalizing batch",
					descriptionDone = "batch finalization", command = "echo catch")
		'''
		factory_inst.addStep(shell.ShellCommand,
				command = ['cp','-f', '/usr/src/redhat/RPMS/*/' + package + '*.rpm', "/srv/ftp/pub"],
				description = "upload rpm")
		'''
		factory_inst.addStep(shell.Compile,
				command = ['make', 'clean'],
				description = 'clean', descriptionDone='cleaning', env = prof)
		
		'''
		factory_inst.addStep(shell.ShellCommand,
				command = ['rpm', '-e', package],
				description = "uninstall rpm")
		'''
		
		
		c['builders'].append(
			{'name':'b_zouhar_' + package + "_" + arch, 'slavename':slaveName, 'builddir':package + "_" + arch,
			'factory':factory_inst})




####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

from buildbot.status import html
c['status'].append(html.Waterfall(http_port=8010))

# from buildbot.status import mail
# c['status'].append(mail.MailNotifier(fromaddr="buildbot@localhost",
#                                      extraRecipients=["builds@example.com"],
#                                      sendToInterestedUsers=False))
#
# from buildbot.status import words
# c['status'].append(words.IRC(host="irc.example.com", nick="bb",
#                              channels=["#example"]))
#
# from buildbot.status import client
# c['status'].append(client.PBListener(9988))


####### DEBUGGING OPTIONS

# if you set 'debugPassword', then you can connect to the buildmaster with
# the diagnostic tool in contrib/debugclient.py . From this tool, you can
# manually force builds and inject changes, which may be useful for testing
# your buildmaster without actually commiting changes to your repository (or
# before you have a functioning 'sources' set up). The debug tool uses the
# same port number as the slaves do: 'slavePortnum'.

#c['debugPassword'] = "debugpassword"

# if you set 'manhole', you can ssh into the buildmaster and get an
# interactive python shell, which may be useful for debugging buildbot
# internals. It is probably only useful for buildbot developers. You can also
# use an authorized_keys file, or plain telnet.
#from buildbot import manhole
#c['manhole'] = manhole.PasswordManhole("tcp:9999:interface=127.0.0.1",
#                                       "admin", "password")

