# -*- python -*-
# ex: set syntax=python:

# This is a sample buildmaster config file. It must be installed as
# 'master.cfg' in your buildmaster's base directory (although the filename
# can be changed with the --basedir option to 'mktap buildbot master').

# It has one job: define a dictionary named BuildmasterConfig. This
# dictionary has a variety of keys to control different aspects of the
# buildmaster. They are documented in docs/config.xhtml .


# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

from buildbot.buildslave import BuildSlave
c['slaves'] = [BuildSlave("vboxi386", "h2so42", max_builds=1)]

c['slavePortnum'] = 9989

c['projectName'] = 'ZloFS'
c['projectURL'] = 'http://dsrg.mff.cuni.cz/~ceres/prj/zlomekFS'
c['buildbotURL'] = 'http://10.0.0.2:8010' 

####### CHANGESOURCES

# the 'sources' list tells the buildmaster how it should find out about
# source code changes. Any class which implements IChangeSource can be added
# to this list: there are several in buildbot/changes/*.py to choose from.

def split_file_branches(path):
    pieces = path.split('/')
    if pieces[0] == 'trunk':
        return (None, '/'.join(pieces[1:]))
    elif pieces[0] == 'branches':
        if len(pieces) > 3:
            return ('/'.join(pieces[0:3]),
                '/'.join(pieces[3:]))
        else:
            return ('/'.join(pieces[0:2]),
                '/'.join(pieces[2:]))
    else:
        return None

from buildbot.changes.svnpoller import SVNPoller

c['change_source'] = [SVNPoller (svnurl = 'https://shiva.ms.mff.cuni.cz/svn/zzzzzfs',
                                     pollinterval = 120,
                                     split_file = split_file_branches)]


c['schedulers'] = []


class DependRunner(object):
    def __init__(self, schedulers):
        self.schedulers = schedulers
    
    def __call__(self, *arg, **kwarg):
        for scheduler in self.schedulers:
            scheduler.setTimer(0)
    

def echoed (stamp):
    file = open("/home/buildmaster/test", "w")
    file.write( "build " + str(stamp) + " successful")
    file.close()


from buildbot.scheduler import Scheduler, Dependent
s_zouhar_zen_unit = Scheduler("s_zouhar_zen_unit",
                  'branches/zouhar/zen-unit',
                  5*60,
                  ["b_zouhar_zen-unit"])
c['schedulers'].append(s_zouhar_zen_unit)


s_zouhar_zfs = Scheduler("s_zouhar_zfs",
                  'branches/zouhar/zfs',
                  5*60,
                  ["b_zouhar_zfs"])
c['schedulers'].append(s_zouhar_zfs)


s_zouhar_syplog = Scheduler("s_zouhar_syplog",
                  'branches/zouhar/syplog',
                  5*60,
                  ["b_zouhar_syplog"])
s_zouhar_syplog.subscribeToSuccessfulBuilds(echoed)
c['schedulers'].append(s_zouhar_syplog)

s_zouhar_TestResultStorage = Scheduler("s_zouhar_TestResultStorage",
                  'branches/zouhar/TestResultStorage',
                  5*60,
                  ["b_zouhar_TestResultStorage"])
c['schedulers'].append(s_zouhar_TestResultStorage)

s_zouhar_insecticide = Scheduler("s_zouhar_insecticide",
                  'branches/zouhar/insecticide',
                  5*60,
                  ["b_zouhar_insecticide"])
c['schedulers'].append(s_zouhar_insecticide)


s_zouhar_pysyplog = Scheduler("s_zouhar_pysyplog",
                  'branches/zouhar/syplog/py',
                  5*60,
                  ["b_zouhar_pysyplog"])
c['schedulers'].append(s_zouhar_pysyplog)

s_zouhar_zfsd_status = Scheduler("s_zouhar_zfsd_status",
                  'branches/zouhar/zfs/zfsd-status-py',
                  5*60,
                  ["b_zouhar_zfsd-status"])
c['schedulers'].append(s_zouhar_zfsd_status)




s_zouhar_zen_unit.subscribeToSuccessfulBuilds(DependRunner([s_zouhar_syplog, s_zouhar_zfs]))
s_zouhar_syplog.subscribeToSuccessfulBuilds(DependRunner([s_zouhar_zfs, s_zouhar_pysyplog]))
s_zouhar_zfs.subscribeToSuccessfulBuilds(DependRunner([s_zouhar_zfsd_status]))
s_zouhar_TestResultStorage.subscribeToSuccessfulBuilds(DependRunner([s_zouhar_insecticide]))


'''
s_zouhar_syplog-py = Dependent("s_zouhar-syplog-py", s_zouhar_syplog,
                             ["b_zouhar-syplog-pu"])

s_zouhar_test = Dependent("zouhar-test", s_zouhar_install,
                          ["zouhar-test"])

'''



from buildbot.process import factory
from buildbot.steps import source, shell

c['builders'] = []

compileStep = shell.Compile(command='make all', description = "make", descriptionDone = "build")
packageStep = shell.Compile(command='make package', description = "build package", descriptionDone = "packaging")
rpmStep = shell.Compile(command='make rpm', description = "build rpm", descriptionDone = "rpm build")
cleanStep = shell.Compile(command="make clean", description = "clean", descriptionDone = "clean")
testStep = shell.Compile(command="make test", description = "test", descriptionDone = "tests")


for (package, branch) in [
            ("zen-unit", "zen-unit"),
            ("syplog", "syplog"),
            ("pysyplog", "syplog/py"),
            ("zfs", "zfs"),
            ("zfsd-status", "zfs/zfsd-status-py"),
            ("TestResultStorage", "TestResultStorage"),
            ("insecticide", "insecticide")
                                  ]:
    factory_inst = factory.BuildFactory()
    factory_inst.addStep(source.SVN(mode='update', 
                      baseURL='https://shiva.ms.mff.cuni.cz/svn/zzzzzfs/', 
                      defaultBranch='branches/zouhar/' + branch))
    
    factory_inst.addStep(compileStep)
    factory_inst.addStep(packageStep)
    factory_inst.addStep(rpmStep)
    factory_inst.addStep(shell.ShellCommand,
                       command = ['rpm', '-Uvh', '--force', '/usr/src/redhat/RPMS/*/' + package + '*.rpm'],
                       description = "install rpm")
    factory_inst.addStep(testStep)
    '''
    factory_inst.addStep(shell.ShellCommand,
                       command = ['cp','-f', '/usr/src/redhat/RPMS/*/' + package + '*.rpm', "/srv/ftp/pub"],
                       description = "upload rpm")
    '''
    factory_inst.addStep(shell.ShellCommand,
                       command = ['rm', '-rf', '/usr/src/redhat/RPMS/*/' + package + '*.rpm'],
                       description = "delete rpm")
    
    '''
    factory_inst.addStep(shell.ShellCommand,
                       command = ['rpm', '-e', package],
                       description = "uninstall rpm")
    '''
    
    c['builders'].append(
         {'name':'b_zouhar_' + package, 'slavename':'vboxi386', 'builddir':package,
         'factory':factory_inst})



####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

from buildbot.status import html
c['status'].append(html.Waterfall(http_port=8010))

# from buildbot.status import mail
# c['status'].append(mail.MailNotifier(fromaddr="buildbot@localhost",
#                                      extraRecipients=["builds@example.com"],
#                                      sendToInterestedUsers=False))
#
# from buildbot.status import words
# c['status'].append(words.IRC(host="irc.example.com", nick="bb",
#                              channels=["#example"]))
#
# from buildbot.status import client
# c['status'].append(client.PBListener(9988))


####### DEBUGGING OPTIONS

# if you set 'debugPassword', then you can connect to the buildmaster with
# the diagnostic tool in contrib/debugclient.py . From this tool, you can
# manually force builds and inject changes, which may be useful for testing
# your buildmaster without actually commiting changes to your repository (or
# before you have a functioning 'sources' set up). The debug tool uses the
# same port number as the slaves do: 'slavePortnum'.

#c['debugPassword'] = "debugpassword"

# if you set 'manhole', you can ssh into the buildmaster and get an
# interactive python shell, which may be useful for debugging buildbot
# internals. It is probably only useful for buildbot developers. You can also
# use an authorized_keys file, or plain telnet.
#from buildbot import manhole
#c['manhole'] = manhole.PasswordManhole("tcp:9999:interface=127.0.0.1",
#                                       "admin", "password")

