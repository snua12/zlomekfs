# -*- python -*-
# ex: set syntax=python:

# This is a sample buildmaster config file. It must be installed as
# 'master.cfg' in your buildmaster's base directory (although the filename
# can be changed with the --basedir option to 'mktap buildbot master').

# It has one job: define a dictionary named BuildmasterConfig. This
# dictionary has a variety of keys to control different aspects of the
# buildmaster. They are documented in docs/config.xhtml .


# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.

import logging
import copy
from TestResultStorage.settings import MEDIA_ROOT

log = logging.getLogger('buildbot.master')

WAIT_BEFORE_BUILD = 1

c = BuildmasterConfig = {}

from buildbot.buildslave import BuildSlave
c['slaves'] = [BuildSlave("bug", "h2so42"),BuildSlave("zen", "h2so42")]

c['slavePortnum'] = "tcp:9989"

c['projectName'] = 'ZloFS'
c['projectURL'] = 'http://dsrg.mff.cuni.cz/~ceres/prj/zlomekFS'
c['buildbotURL'] = 'http://10.0.0.2:8010' 

####### CHANGESOURCES

# the 'sources' list tells the buildmaster how it should find out about
# source code changes. Any class which implements IChangeSource can be added
# to this list: there are several in buildbot/changes/*.py to choose from.

def split_file_branches(path):
    pieces = path.split('/')
    if pieces[0] == 'trunk':
        return (None, '/'.join(pieces[1:]))
    elif pieces[0] == 'branches':
        if len(pieces) > 3:
            return ('/'.join(pieces[0:3]),
                '/'.join(pieces[3:]))
        else:
            return ('/'.join(pieces[0:2]),
                '/'.join(pieces[2:]))
    else:
        return None

from buildbot.changes.svnpoller import SVNPoller

c['change_source'] = [SVNPoller (svnurl = 'https://shiva.ms.mff.cuni.cz/svn/zzzzzfs',
                                     pollinterval = 60,
                                     split_file = split_file_branches)]


c['schedulers'] = []


class DependRunner(object):
    def __init__(self, schedulers):
        self.schedulers = schedulers
    
    def __call__(self, *arg, **kwarg):
        for scheduler in self.schedulers:
            scheduler.setTimer(0)


from buildbot.scheduler import Scheduler
s_zouhar_zen_unit = Scheduler("s_zouhar_zen_unit",
                  'branches/zouhar/zen-unit',
                  60 * WAIT_BEFORE_BUILD,
                  ["b_zouhar_zen-unit_32", "b_zouhar_zen-unit_64"])
c['schedulers'].append(s_zouhar_zen_unit)


s_zouhar_zfs = Scheduler("s_zouhar_zfs",
                  'branches/zouhar/zfs',
                  60 * WAIT_BEFORE_BUILD,
                  ["b_zouhar_zfs_32", "b_zouhar_zfs_64"])
c['schedulers'].append(s_zouhar_zfs)


s_zouhar_syplog = Scheduler("s_zouhar_syplog",
                  'branches/zouhar/syplog',
                  60 * WAIT_BEFORE_BUILD,
                  ["b_zouhar_syplog_32", "b_zouhar_syplog_64"])
c['schedulers'].append(s_zouhar_syplog)

s_zouhar_TestResultStorage = Scheduler("s_zouhar_TestResultStorage",
                  'branches/zouhar/TestResultStorage',
                  60 * WAIT_BEFORE_BUILD,
                  ["b_zouhar_TestResultStorage_32", "b_zouhar_TestResultStorage_64"])
c['schedulers'].append(s_zouhar_TestResultStorage)

s_zouhar_insecticide = Scheduler("s_zouhar_insecticide",
                  'branches/zouhar/insecticide',
                  60 * WAIT_BEFORE_BUILD,
                  ["b_zouhar_insecticide_32", "b_zouhar_insecticide_64"])
c['schedulers'].append(s_zouhar_insecticide)


s_zouhar_pysyplog = Scheduler("s_zouhar_pysyplog",
                  'branches/zouhar/syplog/py',
                  60 * WAIT_BEFORE_BUILD,
                  ["b_zouhar_pysyplog_32", "b_zouhar_pysyplog_64"])
c['schedulers'].append(s_zouhar_pysyplog)

s_zouhar_zfsd_status = Scheduler("s_zouhar_zfsd_status",
                  'branches/zouhar/zfs/zfsd-status-py',
                  60 * WAIT_BEFORE_BUILD,
                  ["b_zouhar_zfsd-status_32", "b_zouhar_zfsd-status_64"])
c['schedulers'].append(s_zouhar_zfsd_status)

s_zouhar_buildmaster_cfg = Scheduler("s_zouhar_buildmaster_cfg",
                  'branches/zouhar/buildbot',
                  60 * WAIT_BEFORE_BUILD,
                  ["b_zouhar_buildmaster_cfg"])


s_zouhar_zen_unit.subscribeToSuccessfulBuilds(DependRunner([s_zouhar_syplog, s_zouhar_zfs]))
s_zouhar_syplog.subscribeToSuccessfulBuilds(DependRunner([s_zouhar_zfs, s_zouhar_pysyplog]))
s_zouhar_zfs.subscribeToSuccessfulBuilds(DependRunner([s_zouhar_zfsd_status]))
s_zouhar_TestResultStorage.subscribeToSuccessfulBuilds(DependRunner([s_zouhar_insecticide]))


'''
s_zouhar_syplog-py = Dependent("s_zouhar-syplog-py", s_zouhar_syplog,
                             ["b_zouhar-syplog-pu"])

s_zouhar_test = Dependent("zouhar-test", s_zouhar_install,
                          ["zouhar-test"])

'''



from buildbot.process import factory
from buildbot.steps.python import PyFlakes
from buildbot.steps import source, shell, dummy


class MakeRpm(shell.Compile):
    descriptionDone = "rpm"
    description = "build rpm"
    def start(self):
        revision = self.getProperty("revision")
        if revision:
            self.setCommand(["make", "rpm", "REVISION=%s" %revision ])
        else:
            self.setCommand(["make", "rpm"])
        shell.ShellCommand.start(self)


c['builders'] = []

profile = {}

for (package, branch, flakes) in [
	("zen-unit", "zen-unit", None),
	("syplog", "syplog", None),
	("pysyplog", "syplog/py", "syplog/py"),
	("zfs", "zfs", None),
	("zfsd-status", "zfs/zfsd-status-py", "zfs/zfsd-status-py"),
	("TestResultStorage", "TestResultStorage", "."),
	("insecticide", "insecticide", '.')
				]:
	
	for (slaveName, arch) in [('bug', '32'), ('zen', '64')]:
		factory_inst = factory.BuildFactory()
		# we need copy for each builder to prevent BATCHUUID collisions
		prof = copy.copy(profile)
		prof['PROJECT_NAME'] = package
		prof['BRANCH'] = branch
		prof['SLAVE_NAME'] = slaveName
		
		factory_inst.addStep(source.SVN(mode='update', 
				baseURL='https://shiva.ms.mff.cuni.cz/svn/zzzzzfs/', 
				defaultBranch='branches/zouhar/' + branch), env = prof)
		
		# make step is included in rpm step   
		#    factory_inst.addStep(shell.Compile, description = "make",
		#                         descriptionDone = "build", command='make all', env = prof)
		#factory_inst.addStep(shell.Compile, command='make package', description = "build package",
		#                     descriptionDone = "packaging", env = prof)
		factory_inst.addStep(MakeRpm, env = prof)
		
		factory_inst.addStep(shell.ShellCommand,
				command = 'rpm -Uvh --oldpackage build/RPMS/*/' + package + '*.rpm || [ $? = 6 ]',
				description = "install rpm", env = prof)
		
		factory_inst.addStep(shell.Test, command="make test", description = "test",
					descriptionDone = "tests", env = prof)

		if flakes:
			factory_inst.addStep(PyFlakes, command=["pyflakes", flakes])
		
		#upload rpms
		factory_inst.addStep(shell.ShellCommand, command = "cp -rf build/RPMS/*/* " + MEDIA_ROOT,
				description = "upload rpm", env = prof)
		
		factory_inst.addStep(shell.Compile,
				command = ['make', 'clean'],
				description = 'clean', descriptionDone='cleaning', env = prof)
		
		'''
		factory_inst.addStep(shell.ShellCommand,
				command = ['rpm', '-e', package],
				description = "uninstall rpm")
		'''
		
		
		c['builders'].append(
			{'name':'b_zouhar_' + package + "_" + arch, 'slavename':slaveName, 'builddir':package + "_" + arch,
			'factory':factory_inst})





b_buildmaster_cfg = factory.BuildFactory()

b_buildmaster_cfg.addStep(source.SVN(mode='update', 
		baseURL='https://shiva.ms.mff.cuni.cz/svn/zzzzzfs/', 
		defaultBranch='branches/zouhar/buildbot'), env = prof)

b_buildmaster_cfg.addStep(PyFlakes, command=["pyflakes", 'buildmaster/master.cfg'])


c['builders'].append(
	{'name':'b_buildmaster_cfg', 'slavenames':['zen', 'bug'], 'builddir':'buildbot',
	'factory':b_buildmaster_cfg})


####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

from buildbot.status import html
c['status'].append(html.Waterfall(http_port=8010))

# from buildbot.status import mail
# c['status'].append(mail.MailNotifier(fromaddr="buildbot@localhost",
#                                      extraRecipients=["builds@example.com"],
#                                      sendToInterestedUsers=False))
#
# from buildbot.status import words
# c['status'].append(words.IRC(host="irc.example.com", nick="bb",
#                              channels=["#example"]))
#
# from buildbot.status import client
# c['status'].append(client.PBListener(9988))


####### DEBUGGING OPTIONS

# if you set 'debugPassword', then you can connect to the buildmaster with
# the diagnostic tool in contrib/debugclient.py . From this tool, you can
# manually force builds and inject changes, which may be useful for testing
# your buildmaster without actually commiting changes to your repository (or
# before you have a functioning 'sources' set up). The debug tool uses the
# same port number as the slaves do: 'slavePortnum'.

#c['debugPassword'] = "debugpassword"

# if you set 'manhole', you can ssh into the buildmaster and get an
# interactive python shell, which may be useful for debugging buildbot
# internals. It is probably only useful for buildbot developers. You can also
# use an authorized_keys file, or plain telnet.
#from buildbot import manhole
#c['manhole'] = manhole.PasswordManhole("tcp:9999:interface=127.0.0.1",
#                                       "admin", "password")

