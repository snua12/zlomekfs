<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>zlomekFS: cap.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="dir_21c430ab3b7001ae39034eae6f7edf71.html">zfsd</a></div>
<h1>cap.h File Reference</h1>Capability functions. <a href="#_details">More...</a>
<p>
<code>#include &quot;<a class="el" href="system_8h-source.html">system.h</a>&quot;</code><br>
<code>#include &lt;inttypes.h&gt;</code><br>
<code>#include &lt;stdio.h&gt;</code><br>
<code>#include &quot;<a class="el" href="pthread-wrapper_8h-source.html">pthread-wrapper.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="zfs-prot_8h-source.html">zfs-prot.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="fh_8h-source.html">fh.h</a>&quot;</code><br>

<p>
<a href="cap_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal__cap__def.html">internal_cap_def</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">In-memory capability structure.  <a href="structinternal__cap__def.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cap_8h.html#63147b95c187292a5ea654ca2dbc7f6e">CAP_RANDOM_LEN</a>&nbsp;&nbsp;&nbsp;16</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cap_8h.html#513da21c43b859afcaa0b4e8dd098d73">zfs_cap_undefine</a>(CAP)&nbsp;&nbsp;&nbsp;((CAP).flags = UINT32_MAX)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cap_8h.html#021dbb6973268bd4f31254452e1ec291">zfs_cap_undefined</a>(CAP)&nbsp;&nbsp;&nbsp;((CAP).flags == UINT32_MAX)</td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structinternal__cap__def.html">internal_cap_def</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cap_8h.html#3485ddae5766d84bc81290db40c845fd">internal_cap</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cap_8h.html#fee9a3cc7f0788532e544baf5b88bab4">internal_cap_lock</a> (unsigned int level, <a class="el" href="structinternal__cap__def.html">internal_cap</a> *icapp, <a class="el" href="structvolume__def.html">volume</a> *volp, <a class="el" href="structinternal__dentry__def.html">internal_dentry</a> *dentryp, <a class="el" href="structvirtual__dir__def.html">virtual_dir</a> *vdp, <a class="el" href="structzfs__cap__def.html">zfs_cap</a> *tmp_cap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cap_8h.html#c99317ee3cbde650023fb709f7affff1">internal_cap_unlock</a> (<a class="el" href="structvolume__def.html">volume</a> vol, <a class="el" href="structinternal__dentry__def.html">internal_dentry</a> dentry, <a class="el" href="structvirtual__dir__def.html">virtual_dir</a> vd)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structinternal__cap__def.html">internal_cap</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cap_8h.html#9960c0af05196128d866bbefbdca0584">internal_cap_lookup</a> (<a class="el" href="structzfs__cap__def.html">zfs_cap</a> *cap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cap_8h.html#bd92125beb330e39a1ef31818741d83f">destroy_unused_capabilities</a> (<a class="el" href="structinternal__fh__def.html">internal_fh</a> fh)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cap_8h.html#a8e3076b0e4be7d3491ac613f465f8af">get_capability</a> (<a class="el" href="structzfs__cap__def.html">zfs_cap</a> *cap, <a class="el" href="structinternal__cap__def.html">internal_cap</a> *icapp, <a class="el" href="structvolume__def.html">volume</a> *vol, <a class="el" href="structinternal__dentry__def.html">internal_dentry</a> *dentry, <a class="el" href="structvirtual__dir__def.html">virtual_dir</a> *vd, bool unlock_fh_mutex, bool delete_volume_p)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structinternal__cap__def.html">internal_cap</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cap_8h.html#0cb6693dca955aa50b37012d5b496626">get_capability_no_zfs_fh_lookup</a> (<a class="el" href="structzfs__cap__def.html">zfs_cap</a> *cap, <a class="el" href="structinternal__dentry__def.html">internal_dentry</a> dentry, uint32_t flags)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cap_8h.html#8be3fb9a73caf62d31b6244b64fe4a65">find_capability</a> (<a class="el" href="structzfs__cap__def.html">zfs_cap</a> *cap, <a class="el" href="structinternal__cap__def.html">internal_cap</a> *icapp, <a class="el" href="structvolume__def.html">volume</a> *vol, <a class="el" href="structinternal__dentry__def.html">internal_dentry</a> *dentry, <a class="el" href="structvirtual__dir__def.html">virtual_dir</a> *vd, bool delete_volume_p)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cap_8h.html#e09f5a41945b184cfa07227bda352992">find_capability_nolock</a> (<a class="el" href="structzfs__cap__def.html">zfs_cap</a> *cap, <a class="el" href="structinternal__cap__def.html">internal_cap</a> *icapp, <a class="el" href="structvolume__def.html">volume</a> *vol, <a class="el" href="structinternal__dentry__def.html">internal_dentry</a> *dentry, <a class="el" href="structvirtual__dir__def.html">virtual_dir</a> *vd, bool delete_volume_p)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cap_8h.html#d12fd51259c19e70bd46953b5c0cb289">put_capability</a> (<a class="el" href="structinternal__cap__def.html">internal_cap</a> cap, <a class="el" href="structinternal__fh__def.html">internal_fh</a> fh, <a class="el" href="structvirtual__dir__def.html">virtual_dir</a> vd)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cap_8h.html#769b227d645a6e4201b239468571d269">initialize_cap_c</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cap_8h.html#408e75686b4a1d0c06038963df330f14">cleanup_cap_c</a> (void)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Capability functions. 
<p>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="63147b95c187292a5ea654ca2dbc7f6e"></a><!-- doxytag: member="cap.h::CAP_RANDOM_LEN" ref="63147b95c187292a5ea654ca2dbc7f6e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CAP_RANDOM_LEN&nbsp;&nbsp;&nbsp;16          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Number of random bytes used to compute VERIFY. 
</div>
</div><p>
<a class="anchor" name="513da21c43b859afcaa0b4e8dd098d73"></a><!-- doxytag: member="cap.h::zfs_cap_undefine" ref="513da21c43b859afcaa0b4e8dd098d73" args="(CAP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zfs_cap_undefine          </td>
          <td>(</td>
          <td class="paramtype">CAP&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((CAP).flags = UINT32_MAX)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mark the ZFS capability CAP to be undefined. 
</div>
</div><p>
<a class="anchor" name="021dbb6973268bd4f31254452e1ec291"></a><!-- doxytag: member="cap.h::zfs_cap_undefined" ref="021dbb6973268bd4f31254452e1ec291" args="(CAP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define zfs_cap_undefined          </td>
          <td>(</td>
          <td class="paramtype">CAP&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((CAP).flags == UINT32_MAX)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true if the ZFS capability CAP is undefined. 
</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="3485ddae5766d84bc81290db40c845fd"></a><!-- doxytag: member="cap.h::internal_cap" ref="3485ddae5766d84bc81290db40c845fd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structinternal__cap__def.html">internal_cap_def</a>* <a class="el" href="structinternal__cap__def.html">internal_cap</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="408e75686b4a1d0c06038963df330f14"></a><!-- doxytag: member="cap.h::cleanup_cap_c" ref="408e75686b4a1d0c06038963df330f14" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cleanup_cap_c           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy data structures in CAP.C. 
</div>
</div><p>
<a class="anchor" name="bd92125beb330e39a1ef31818741d83f"></a><!-- doxytag: member="cap.h::destroy_unused_capabilities" ref="bd92125beb330e39a1ef31818741d83f" args="(internal_fh fh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void destroy_unused_capabilities           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinternal__fh__def.html">internal_fh</a>&nbsp;</td>
          <td class="paramname"> <em>fh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy all unused capabilities associated with file handle FH. 
</div>
</div><p>
<a class="anchor" name="8be3fb9a73caf62d31b6244b64fe4a65"></a><!-- doxytag: member="cap.h::find_capability" ref="8be3fb9a73caf62d31b6244b64fe4a65" args="(zfs_cap *cap, internal_cap *icapp, volume *vol, internal_dentry *dentry, virtual_dir *vd, bool delete_volume_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t find_capability           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structzfs__cap__def.html">zfs_cap</a> *&nbsp;</td>
          <td class="paramname"> <em>cap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__cap__def.html">internal_cap</a> *&nbsp;</td>
          <td class="paramname"> <em>icapp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvolume__def.html">volume</a> *&nbsp;</td>
          <td class="paramname"> <em>vol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a> *&nbsp;</td>
          <td class="paramname"> <em>dentry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvirtual__dir__def.html">virtual_dir</a> *&nbsp;</td>
          <td class="paramname"> <em>vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>delete_volume_p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find an internal capability CAP and store it to ICAPP. Store capability's volume to VOL, internal dentry DENTRY and virtual directory to VD. If DELETE_VOLUME_P is true and the volume should be deleted do not lookup the file handle and delete the volume if there are no file handles locked on it. 
</div>
</div><p>
<a class="anchor" name="e09f5a41945b184cfa07227bda352992"></a><!-- doxytag: member="cap.h::find_capability_nolock" ref="e09f5a41945b184cfa07227bda352992" args="(zfs_cap *cap, internal_cap *icapp, volume *vol, internal_dentry *dentry, virtual_dir *vd, bool delete_volume_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t find_capability_nolock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structzfs__cap__def.html">zfs_cap</a> *&nbsp;</td>
          <td class="paramname"> <em>cap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__cap__def.html">internal_cap</a> *&nbsp;</td>
          <td class="paramname"> <em>icapp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvolume__def.html">volume</a> *&nbsp;</td>
          <td class="paramname"> <em>vol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a> *&nbsp;</td>
          <td class="paramname"> <em>dentry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvirtual__dir__def.html">virtual_dir</a> *&nbsp;</td>
          <td class="paramname"> <em>vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>delete_volume_p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find an internal capability CAP and store it to ICAPP. Store capability's volume to VOL, internal dentry DENTRY and virtual directory to VD. If DELETE_VOLUME_P is true and the volume should be deleted do not lookup the file handle and delete the volume if there are no file handles locked on it. This function is similar to FIND_CAPABILITY but does not lock big locks. 
</div>
</div><p>
<a class="anchor" name="a8e3076b0e4be7d3491ac613f465f8af"></a><!-- doxytag: member="cap.h::get_capability" ref="a8e3076b0e4be7d3491ac613f465f8af" args="(zfs_cap *cap, internal_cap *icapp, volume *vol, internal_dentry *dentry, virtual_dir *vd, bool unlock_fh_mutex, bool delete_volume_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t get_capability           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structzfs__cap__def.html">zfs_cap</a> *&nbsp;</td>
          <td class="paramname"> <em>cap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__cap__def.html">internal_cap</a> *&nbsp;</td>
          <td class="paramname"> <em>icapp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvolume__def.html">volume</a> *&nbsp;</td>
          <td class="paramname"> <em>vol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a> *&nbsp;</td>
          <td class="paramname"> <em>dentry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvirtual__dir__def.html">virtual_dir</a> *&nbsp;</td>
          <td class="paramname"> <em>vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>unlock_fh_mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>delete_volume_p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an internal capability CAP and store it to ICAPP. Store capability's volume to VOL, internal file handle IFH and virtual directory to VD. Create a new internal capability if it does not exist. 
</div>
</div><p>
<a class="anchor" name="0cb6693dca955aa50b37012d5b496626"></a><!-- doxytag: member="cap.h::get_capability_no_zfs_fh_lookup" ref="0cb6693dca955aa50b37012d5b496626" args="(zfs_cap *cap, internal_dentry dentry, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinternal__cap__def.html">internal_cap</a> get_capability_no_zfs_fh_lookup           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structzfs__cap__def.html">zfs_cap</a> *&nbsp;</td>
          <td class="paramname"> <em>cap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a>&nbsp;</td>
          <td class="paramname"> <em>dentry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return an internal capability for ZFS capability CAP and internal dentry DENTRY. 
</div>
</div><p>
<a class="anchor" name="769b227d645a6e4201b239468571d269"></a><!-- doxytag: member="cap.h::initialize_cap_c" ref="769b227d645a6e4201b239468571d269" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_cap_c           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize data structures in CAP.C. 
</div>
</div><p>
<a class="anchor" name="fee9a3cc7f0788532e544baf5b88bab4"></a><!-- doxytag: member="cap.h::internal_cap_lock" ref="fee9a3cc7f0788532e544baf5b88bab4" args="(unsigned int level, internal_cap *icapp, volume *volp, internal_dentry *dentryp, virtual_dir *vdp, zfs_cap *tmp_cap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t internal_cap_lock           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__cap__def.html">internal_cap</a> *&nbsp;</td>
          <td class="paramname"> <em>icapp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvolume__def.html">volume</a> *&nbsp;</td>
          <td class="paramname"> <em>volp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a> *&nbsp;</td>
          <td class="paramname"> <em>dentryp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvirtual__dir__def.html">virtual_dir</a> *&nbsp;</td>
          <td class="paramname"> <em>vdp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structzfs__cap__def.html">zfs_cap</a> *&nbsp;</td>
          <td class="paramname"> <em>tmp_cap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lock dentry *DENTRYP on volume *VOLP with capability *ICAPP and virtual directory *VDP to level LEVEL. Store the local ZFS file handle to TMP_FH. 
</div>
</div><p>
<a class="anchor" name="9960c0af05196128d866bbefbdca0584"></a><!-- doxytag: member="cap.h::internal_cap_lookup" ref="9960c0af05196128d866bbefbdca0584" args="(zfs_cap *cap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinternal__cap__def.html">internal_cap</a> internal_cap_lookup           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structzfs__cap__def.html">zfs_cap</a> *&nbsp;</td>
          <td class="paramname"> <em>cap</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c99317ee3cbde650023fb709f7affff1"></a><!-- doxytag: member="cap.h::internal_cap_unlock" ref="c99317ee3cbde650023fb709f7affff1" args="(volume vol, internal_dentry dentry, virtual_dir vd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal_cap_unlock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvolume__def.html">volume</a>&nbsp;</td>
          <td class="paramname"> <em>vol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a>&nbsp;</td>
          <td class="paramname"> <em>dentry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvirtual__dir__def.html">virtual_dir</a>&nbsp;</td>
          <td class="paramname"> <em>vd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unlock dentry DENTRY and virtual directory VD. 
</div>
</div><p>
<a class="anchor" name="d12fd51259c19e70bd46953b5c0cb289"></a><!-- doxytag: member="cap.h::put_capability" ref="d12fd51259c19e70bd46953b5c0cb289" args="(internal_cap cap, internal_fh fh, virtual_dir vd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t put_capability           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinternal__cap__def.html">internal_cap</a>&nbsp;</td>
          <td class="paramname"> <em>cap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__fh__def.html">internal_fh</a>&nbsp;</td>
          <td class="paramname"> <em>fh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvirtual__dir__def.html">virtual_dir</a>&nbsp;</td>
          <td class="paramname"> <em>vd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decrease the number of users of capability CAP associated with file handle FH or virtual directory VD and destroy the capability when the number of users becomes 0. 
</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Aug 6 00:39:37 2010 for zlomekFS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.2 </small></address>
</body>
</html>
