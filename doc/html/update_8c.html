<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>zlomekFS: update.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="dir_21c430ab3b7001ae39034eae6f7edf71.html">zfsd</a></div>
<h1>update.c File Reference</h1>Functions for updating and reintegrating files. <a href="#_details">More...</a>
<p>
<code>#include &quot;<a class="el" href="system_8h-source.html">system.h</a>&quot;</code><br>
<code>#include &lt;inttypes.h&gt;</code><br>
<code>#include &lt;stdlib.h&gt;</code><br>
<code>#include &lt;string.h&gt;</code><br>
<code>#include &lt;sys/types.h&gt;</code><br>
<code>#include &lt;sys/stat.h&gt;</code><br>
<code>#include &lt;sys/time.h&gt;</code><br>
<code>#include &lt;fcntl.h&gt;</code><br>
<code>#include &lt;errno.h&gt;</code><br>
<code>#include &quot;<a class="el" href="pthread-wrapper_8h-source.html">pthread-wrapper.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="constant_8h-source.html">constant.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="update_8h-source.html">update.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="md5_8h-source.html">md5.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="memory_8h-source.html">memory.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="alloc-pool_8h-source.html">alloc-pool.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="queue_8h-source.html">queue.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="log_8h-source.html">log.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="random_8h-source.html">random.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="volume_8h-source.html">volume.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="fh_8h-source.html">fh.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="cap_8h-source.html">cap.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="varray_8h-source.html">varray.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="interval_8h-source.html">interval.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="zfs-prot_8h-source.html">zfs-prot.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="file_8h-source.html">file.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="dir_8h-source.html">dir.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="network_8h-source.html">network.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="journal_8h-source.html">journal.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="metadata_8h-source.html">metadata.h</a>&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#d837374ba80f4178e2b3d2f2855cf5a2">ZFS_SLOW_BUSY_DELAY</a>&nbsp;&nbsp;&nbsp;5</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">How long at least will the slow update worker sleep after aborted by ZFS_SLOW_BUSY.  <a href="#d837374ba80f4178e2b3d2f2855cf5a2"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#070edc4f16621981f4a856c1dfd27b76">get_blocks_for_updating</a> (<a class="el" href="structinternal__fh__def.html">internal_fh</a> fh, uint64_t start, uint64_t end, <a class="el" href="structvarray__def.html">varray</a> *blocks)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine, which blocks in specified part of the file need to be updated.  <a href="#070edc4f16621981f4a856c1dfd27b76"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#33a0ed40ca8d9d1fb994f0dedc6cac0f">update_file_clear_updated_tree_1</a> (<a class="el" href="structvolume__def.html">volume</a> vol, <a class="el" href="structinternal__dentry__def.html">internal_dentry</a> dentry, uint64_t version)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the tree of updated intervals and set version of dentry.  <a href="#33a0ed40ca8d9d1fb994f0dedc6cac0f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#fc3d32e50e797e78daee46bcebf07f31">update_file_clear_updated_tree</a> (<a class="el" href="structzfs__fh__def.html">zfs_fh</a> *fh, uint64_t version)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the tree of updated intervals and set version of file.  <a href="#fc3d32e50e797e78daee46bcebf07f31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#712b80b973f870932cbb8fa741d56795">truncate_local_file</a> (<a class="el" href="structvolume__def.html">volume</a> *volp, <a class="el" href="structinternal__dentry__def.html">internal_dentry</a> *dentryp, <a class="el" href="structzfs__fh__def.html">zfs_fh</a> *fh, uint64_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Truncate the local file according to the remote size but do not get rid of local modifications of the file.  <a href="#712b80b973f870932cbb8fa741d56795"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#d3c97f646655d5e965e3c279cb38f922">update_file_blocks_1</a> (<a class="el" href="structmd5sum__args__def.html">md5sum_args</a> *args, <a class="el" href="structzfs__cap__def.html">zfs_cap</a> *cap, <a class="el" href="structvarray__def.html">varray</a> *blocks, unsigned int *idx, bool slow)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update parts of file from remote file.  <a href="#d3c97f646655d5e965e3c279cb38f922"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#03d0d58bd98ce17acc4958ca72fa5626">update_file_blocks</a> (<a class="el" href="structzfs__cap__def.html">zfs_cap</a> *cap, <a class="el" href="structvarray__def.html">varray</a> *blocks, bool modified, bool slow)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update blocks of local file according to remote file.  <a href="#03d0d58bd98ce17acc4958ca72fa5626"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#03765e5efe8f67c34dc60fda614e4104">reintegrate_file_blocks</a> (<a class="el" href="structzfs__cap__def.html">zfs_cap</a> *cap, bool slow)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reintegrate modified blocks of local file CAP to remote file.  <a href="#03765e5efe8f67c34dc60fda614e4104"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#8c3a739e65554ced54ed933826f6c123">update_p</a> (<a class="el" href="structvolume__def.html">volume</a> *volp, <a class="el" href="structinternal__dentry__def.html">internal_dentry</a> *dentryp, <a class="el" href="structzfs__fh__def.html">zfs_fh</a> *fh, <a class="el" href="structfattr__def.html">fattr</a> *attr, bool fh_mutex_locked)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if and how the local file should be updated.  <a href="#8c3a739e65554ced54ed933826f6c123"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#acfec61c9a4b34fc36a60462a083072a">update_file</a> (<a class="el" href="structzfs__fh__def.html">zfs_fh</a> *fh, bool slowthread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fully update regular file with file handle FH.  <a href="#acfec61c9a4b34fc36a60462a083072a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#aea7cdd865f077cb639f4983e4f628e9">update_fh_if_needed</a> (<a class="el" href="structvolume__def.html">volume</a> *volp, <a class="el" href="structinternal__dentry__def.html">internal_dentry</a> *dentryp, <a class="el" href="structzfs__fh__def.html">zfs_fh</a> *fh, int what)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update generic file DENTRY with file handle FH on volume VOL if needed and wanted.  <a href="#aea7cdd865f077cb639f4983e4f628e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#d51a0b4039b35ba2caeb35402d04c4c8">update_fh_if_needed_2</a> (<a class="el" href="structvolume__def.html">volume</a> *volp, <a class="el" href="structinternal__dentry__def.html">internal_dentry</a> *dentryp, <a class="el" href="structinternal__dentry__def.html">internal_dentry</a> *dentry2p, <a class="el" href="structzfs__fh__def.html">zfs_fh</a> *fh, <a class="el" href="structzfs__fh__def.html">zfs_fh</a> *fh2, int what)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update generic file DENTRY on volume VOL if needed.  <a href="#d51a0b4039b35ba2caeb35402d04c4c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#be6f099b6a2fcc2abc9f8fecb5890202">update_cap_if_needed</a> (<a class="el" href="structinternal__cap__def.html">internal_cap</a> *icapp, <a class="el" href="structvolume__def.html">volume</a> *volp, <a class="el" href="structinternal__dentry__def.html">internal_dentry</a> *dentryp, <a class="el" href="structvirtual__dir__def.html">virtual_dir</a> *vdp, <a class="el" href="structzfs__cap__def.html">zfs_cap</a> *cap, bool put_cap, int what)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update generic file DENTRY on volume VOL associated with capability ICAP if needed.  <a href="#be6f099b6a2fcc2abc9f8fecb5890202"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#926f28e861dfa653d7f755dd1f17f652">delete_tree</a> (<a class="el" href="structinternal__dentry__def.html">internal_dentry</a> dentry, <a class="el" href="structvolume__def.html">volume</a> vol, bool destroy_dentry, bool journal_p, bool move_to_shadow_p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete file/subtree in place of file DENTRY on volume VOL.  <a href="#926f28e861dfa653d7f755dd1f17f652"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#dd5180f7532813987b3a4e7aab2c7324">delete_tree_name</a> (<a class="el" href="structinternal__dentry__def.html">internal_dentry</a> dir, <a class="el" href="structstring__def.html">string</a> *name, <a class="el" href="structvolume__def.html">volume</a> vol, bool destroy_dentry, bool journal_p, bool move_to_shadow_p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete file NAME in directory DIR on volume VOL.  <a href="#dd5180f7532813987b3a4e7aab2c7324"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#eb78b38470ce32884a294a51f52faab7">files_are_the_same</a> (<a class="el" href="structzfs__fh__def.html">zfs_fh</a> *dir_fh, <a class="el" href="structstring__def.html">string</a> *name, <a class="el" href="structfattr__def.html">fattr</a> *local_attr, <a class="el" href="structzfs__fh__def.html">zfs_fh</a> *remote_fh, <a class="el" href="structfattr__def.html">fattr</a> *remote_attr, bool *same)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if local and remote files are same.  <a href="#eb78b38470ce32884a294a51f52faab7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#117fdb28e2fd52ec5ad7aebefa80c2cd">synchronize_attributes</a> (<a class="el" href="structvolume__def.html">volume</a> *volp, <a class="el" href="structinternal__dentry__def.html">internal_dentry</a> *dentryp, <a class="el" href="structzfs__fh__def.html">zfs_fh</a> *fh, <a class="el" href="structfattr__def.html">fattr</a> *attr, bool local_changed, bool remote_changed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Synchronize attributes and metadata (including regular file's size) of local and remote file.  <a href="#117fdb28e2fd52ec5ad7aebefa80c2cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#2903310f18713917af9829e051301b99">create_local_fh</a> (<a class="el" href="structinternal__dentry__def.html">internal_dentry</a> dir, <a class="el" href="structstring__def.html">string</a> *name, <a class="el" href="structvolume__def.html">volume</a> vol, <a class="el" href="structzfs__fh__def.html">zfs_fh</a> *dir_fh, <a class="el" href="structzfs__fh__def.html">zfs_fh</a> *remote_fh, <a class="el" href="structfattr__def.html">fattr</a> *remote_attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create local generic file based on remote attributes.  <a href="#2903310f18713917af9829e051301b99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#192f5bfdab4a035288af788030500f0d">create_remote_fh</a> (<a class="el" href="structdir__op__res__def.html">dir_op_res</a> *res, <a class="el" href="structinternal__dentry__def.html">internal_dentry</a> dir, <a class="el" href="structstring__def.html">string</a> *name, <a class="el" href="structvolume__def.html">volume</a> vol, <a class="el" href="structzfs__fh__def.html">zfs_fh</a> *dir_fh, <a class="el" href="structfattr__def.html">fattr</a> *attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create remote generic file based on local attributes.  <a href="#192f5bfdab4a035288af788030500f0d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#a651587c18911d478989950a8eac0151">schedule_update_or_reintegration</a> (<a class="el" href="structvolume__def.html">volume</a> vol, <a class="el" href="structinternal__dentry__def.html">internal_dentry</a> dentry)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Schedule update or reintegration of a not yet enqueued regular file.  <a href="#a651587c18911d478989950a8eac0151"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#fca851a6baa4f62418a3023be7565c05">lookup_remote_dentry_in_the_same_place</a> (<a class="el" href="structdir__op__res__def.html">dir_op_res</a> *res, <a class="el" href="structzfs__fh__def.html">zfs_fh</a> *fh, <a class="el" href="structinternal__dentry__def.html">internal_dentry</a> *dentryp, <a class="el" href="structvolume__def.html">volume</a> *volp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lookup the remote file which is in the same place as the local file.  <a href="#fca851a6baa4f62418a3023be7565c05"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#34126cb6d7beb9bd0d291088bbd146dd">synchronize_file</a> (<a class="el" href="structvolume__def.html">volume</a> vol, <a class="el" href="structinternal__dentry__def.html">internal_dentry</a> dentry, <a class="el" href="structzfs__fh__def.html">zfs_fh</a> *fh, <a class="el" href="structfattr__def.html">fattr</a> *attr, int what, bool same_place)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Synchronize the local file with the remote file.  <a href="#34126cb6d7beb9bd0d291088bbd146dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#3d750f23c5ae2d66320c6f5cf96c5346">resolve_conflict_discard_local</a> (<a class="el" href="structzfs__fh__def.html">zfs_fh</a> *conflict_fh, <a class="el" href="structinternal__dentry__def.html">internal_dentry</a> local, <a class="el" href="structinternal__dentry__def.html">internal_dentry</a> remote, <a class="el" href="structvolume__def.html">volume</a> vol)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Discard changes to local file LOCAL which is in conflict with REMOTE on volume VOL.  <a href="#3d750f23c5ae2d66320c6f5cf96c5346"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#18bcb8f6f49657c49a5a34baa0c62ee3">resolve_conflict_discard_remote</a> (<a class="el" href="structzfs__fh__def.html">zfs_fh</a> *conflict_fh, <a class="el" href="structinternal__dentry__def.html">internal_dentry</a> local, <a class="el" href="structinternal__dentry__def.html">internal_dentry</a> remote, <a class="el" href="structvolume__def.html">volume</a> vol)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Discard changes to remote file REMOTE which is in conflict with LOCAL on volume VOL.  <a href="#18bcb8f6f49657c49a5a34baa0c62ee3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#d9a6c0040f592fdca647ae1c6134eeff">resolve_conflict_delete_local</a> (<a class="el" href="structdir__op__res__def.html">dir_op_res</a> *res, <a class="el" href="structinternal__dentry__def.html">internal_dentry</a> dir, <a class="el" href="structzfs__fh__def.html">zfs_fh</a> *dir_fh, <a class="el" href="structstring__def.html">string</a> *name, <a class="el" href="structzfs__fh__def.html">zfs_fh</a> *local_fh, <a class="el" href="structzfs__fh__def.html">zfs_fh</a> *remote_fh, <a class="el" href="structvolume__def.html">volume</a> vol)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resolve conflict by deleting local file.  <a href="#d9a6c0040f592fdca647ae1c6134eeff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#9f56b919ffd4b001fcba2a5d52b443a4">resolve_conflict_delete_remote</a> (<a class="el" href="structvolume__def.html">volume</a> vol, <a class="el" href="structinternal__dentry__def.html">internal_dentry</a> dir, <a class="el" href="structstring__def.html">string</a> *name, <a class="el" href="structzfs__fh__def.html">zfs_fh</a> *remote_fh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resolve conflict by deleting remote file NAME with file handle REMOTE_FH in directory DIR on volume VOL.  <a href="#9f56b919ffd4b001fcba2a5d52b443a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#6005411200a12efe387af995b3625b7a">update_dir</a> (<a class="el" href="structvolume__def.html">volume</a> vol, <a class="el" href="structinternal__dentry__def.html">internal_dentry</a> dir, <a class="el" href="structzfs__fh__def.html">zfs_fh</a> *fh, <a class="el" href="structfattr__def.html">fattr</a> *attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update the directory DIR on volume VOL with file handle FH, set attributes according to ATTR.  <a href="#6005411200a12efe387af995b3625b7a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#659ba098368fcbd49cf933b79e39f268">reintegrate_deleted_dir</a> (<a class="el" href="structdir__op__res__def.html">dir_op_res</a> *res, uint32_t vid, <a class="el" href="structjournal__entry__def.html">journal_entry</a> deleted_dir_entry)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reintegrate journal of deleted directory DIR_ENTRY on volume VID.  <a href="#659ba098368fcbd49cf933b79e39f268"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#9b2dc373f369b769e0e81addb8638a37">reintegrate_dir</a> (<a class="el" href="structvolume__def.html">volume</a> vol, <a class="el" href="structinternal__dentry__def.html">internal_dentry</a> dir, <a class="el" href="structzfs__fh__def.html">zfs_fh</a> *fh, <a class="el" href="structfattr__def.html">fattr</a> *attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reintegrate journal for directory DIR on volume VOL with file handle FH.  <a href="#9b2dc373f369b769e0e81addb8638a37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#3206db6ce423b4e20a7c1e2fb7711cdb">update</a> (<a class="el" href="structvolume__def.html">volume</a> vol, <a class="el" href="structinternal__dentry__def.html">internal_dentry</a> dentry, <a class="el" href="structzfs__fh__def.html">zfs_fh</a> *fh, <a class="el" href="structfattr__def.html">fattr</a> *attr, int how)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reintegrate or update generic file.  <a href="#3206db6ce423b4e20a7c1e2fb7711cdb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#a0cf7042a840e8936d0f331853c5f5a3">update_worker_init</a> (<a class="el" href="structthread__def.html">thread</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize update thread T.  <a href="#a0cf7042a840e8936d0f331853c5f5a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#afad1383e20a1acb871407cb3b3790fc">update_worker_cleanup</a> (void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cleanup update thread DATA.  <a href="#afad1383e20a1acb871407cb3b3790fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#3645d29d463f96be6e22c7d8b119580d">update_worker</a> (void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The main function of an update thread.  <a href="#3645d29d463f96be6e22c7d8b119580d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#69c89c73f1d26e04225ef65f949c7351">update_main</a> (ATTRIBUTE_UNUSED void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Main function of the main update thread.  <a href="#69c89c73f1d26e04225ef65f949c7351"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#6e55fb2c33d8aba365ce6cf0592ae2fb">update_start</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the mutexes and queues for updating, and create the <a class="el" href="update_8h.html#042a22003c0b9b8c3d97d4bc07a4f98c" title="Pool of update threads.">update_pool</a>.  <a href="#6e55fb2c33d8aba365ce6cf0592ae2fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#19341698513037bdd134d627755ff3b7">update_cleanup</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy <a class="el" href="update_8h.html#042a22003c0b9b8c3d97d4bc07a4f98c" title="Pool of update threads.">update_pool</a> and cleanup the mutexes and queues for updating.  <a href="#19341698513037bdd134d627755ff3b7"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structqueue__def.html">queue</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#a148194f9fdacbf90ab1965422718cfc">update_queue</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queue of file handles for updating or reintegrating.  <a href="#a148194f9fdacbf90ab1965422718cfc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static pthread_mutex_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#43a4cc01a3da1beb214263186d1c6225">update_queue_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mutex for <a class="el" href="update_8h.html#a148194f9fdacbf90ab1965422718cfc" title="Queue of file handles for updating or reintegrating.">update_queue</a>.  <a href="#43a4cc01a3da1beb214263186d1c6225"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structthread__pool__def.html">thread_pool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#042a22003c0b9b8c3d97d4bc07a4f98c">update_pool</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pool of update threads.  <a href="#042a22003c0b9b8c3d97d4bc07a4f98c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="structqueue__def.html">queue</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#6dbfc3efd6cadb25bb1bdb06aa72126c">update_slow_queue</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queue of file handles for slow updating or reintegrating.  <a href="#6dbfc3efd6cadb25bb1bdb06aa72126c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static pthread_mutex_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#679fb99ef8a4d636d093f3a850ee8449">update_slow_queue_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mutex for <a class="el" href="update_8c.html#6dbfc3efd6cadb25bb1bdb06aa72126c" title="Queue of file handles for slow updating or reintegrating.">update_slow_queue</a> and <a class="el" href="update_8c.html#fcd1f6319a60bb12e5d25c1cfce2e27d" title="Pointer to thread that is performing slow update.">slow_update_worker</a>.  <a href="#679fb99ef8a4d636d093f3a850ee8449"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="structthread__def.html">thread</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="update_8c.html#fcd1f6319a60bb12e5d25c1cfce2e27d">slow_update_worker</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to thread that is performing slow update.  <a href="#fcd1f6319a60bb12e5d25c1cfce2e27d"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Functions for updating and reintegrating files. 
<p>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="d837374ba80f4178e2b3d2f2855cf5a2"></a><!-- doxytag: member="update.c::ZFS_SLOW_BUSY_DELAY" ref="d837374ba80f4178e2b3d2f2855cf5a2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZFS_SLOW_BUSY_DELAY&nbsp;&nbsp;&nbsp;5          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
How long at least will the slow update worker sleep after aborted by ZFS_SLOW_BUSY. 
<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="2903310f18713917af9829e051301b99"></a><!-- doxytag: member="update.c::create_local_fh" ref="2903310f18713917af9829e051301b99" args="(internal_dentry dir, string *name, volume vol, zfs_fh *dir_fh, zfs_fh *remote_fh, fattr *remote_attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t create_local_fh           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstring__def.html">string</a> *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvolume__def.html">volume</a>&nbsp;</td>
          <td class="paramname"> <em>vol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structzfs__fh__def.html">zfs_fh</a> *&nbsp;</td>
          <td class="paramname"> <em>dir_fh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structzfs__fh__def.html">zfs_fh</a> *&nbsp;</td>
          <td class="paramname"> <em>remote_fh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfattr__def.html">fattr</a> *&nbsp;</td>
          <td class="paramname"> <em>remote_attr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create local generic file based on remote attributes. 
<p>
Create local generic file NAME in directory DIR on volume VOL with remote file REMOTE_FH and remote attributes REMOTE_ATTR. DIR_FH is a file handle of the directory. 
</div>
</div><p>
<a class="anchor" name="192f5bfdab4a035288af788030500f0d"></a><!-- doxytag: member="update.c::create_remote_fh" ref="192f5bfdab4a035288af788030500f0d" args="(dir_op_res *res, internal_dentry dir, string *name, volume vol, zfs_fh *dir_fh, fattr *attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t create_remote_fh           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdir__op__res__def.html">dir_op_res</a> *&nbsp;</td>
          <td class="paramname"> <em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstring__def.html">string</a> *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvolume__def.html">volume</a>&nbsp;</td>
          <td class="paramname"> <em>vol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structzfs__fh__def.html">zfs_fh</a> *&nbsp;</td>
          <td class="paramname"> <em>dir_fh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfattr__def.html">fattr</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create remote generic file based on local attributes. 
<p>
Create remote generic file NAME in directory DIR on volume VOL according to local attributes ATTR. DIR_FH is a file handle of the directory.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>res</em>&nbsp;</td><td>Contains remote file handle and attributes. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="926f28e861dfa653d7f755dd1f17f652"></a><!-- doxytag: member="update.c::delete_tree" ref="926f28e861dfa653d7f755dd1f17f652" args="(internal_dentry dentry, volume vol, bool destroy_dentry, bool journal_p, bool move_to_shadow_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t delete_tree           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a>&nbsp;</td>
          <td class="paramname"> <em>dentry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvolume__def.html">volume</a>&nbsp;</td>
          <td class="paramname"> <em>vol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>destroy_dentry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>journal_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>move_to_shadow_p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete file/subtree in place of file DENTRY on volume VOL. 
<p>
Uses <a class="el" href="dir_8h.html#2a93962a13067e0eb1e411c1327414ef">recursive_unlink</a> to delete the desired path.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>journal_p</em>&nbsp;</td><td>Add a journal entries to appropriate journals. Passed to <a class="el" href="dir_8h.html#2a93962a13067e0eb1e411c1327414ef">recursive_unlink</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>move_to_shadow_p</em>&nbsp;</td><td>Passed to <a class="el" href="dir_8h.html#2a93962a13067e0eb1e411c1327414ef">recursive_unlink</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>destroy_dentry</em>&nbsp;</td><td>Passed to <a class="el" href="dir_8h.html#2a93962a13067e0eb1e411c1327414ef">recursive_unlink</a> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="dd5180f7532813987b3a4e7aab2c7324"></a><!-- doxytag: member="update.c::delete_tree_name" ref="dd5180f7532813987b3a4e7aab2c7324" args="(internal_dentry dir, string *name, volume vol, bool destroy_dentry, bool journal_p, bool move_to_shadow_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t delete_tree_name           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstring__def.html">string</a> *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvolume__def.html">volume</a>&nbsp;</td>
          <td class="paramname"> <em>vol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>destroy_dentry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>journal_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>move_to_shadow_p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete file NAME in directory DIR on volume VOL. 
<p>
Uses <a class="el" href="dir_8h.html#2a93962a13067e0eb1e411c1327414ef">recursive_unlink</a> to delete the desired path.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>journal_p</em>&nbsp;</td><td>Add a journal entries to appropriate journals. Passed to <a class="el" href="dir_8h.html#2a93962a13067e0eb1e411c1327414ef">recursive_unlink</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>move_to_shadow_p</em>&nbsp;</td><td>Passed to <a class="el" href="dir_8h.html#2a93962a13067e0eb1e411c1327414ef">recursive_unlink</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>destroy_dentry</em>&nbsp;</td><td>Passed to <a class="el" href="dir_8h.html#2a93962a13067e0eb1e411c1327414ef">recursive_unlink</a> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="eb78b38470ce32884a294a51f52faab7"></a><!-- doxytag: member="update.c::files_are_the_same" ref="eb78b38470ce32884a294a51f52faab7" args="(zfs_fh *dir_fh, string *name, fattr *local_attr, zfs_fh *remote_fh, fattr *remote_attr, bool *same)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t files_are_the_same           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structzfs__fh__def.html">zfs_fh</a> *&nbsp;</td>
          <td class="paramname"> <em>dir_fh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstring__def.html">string</a> *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfattr__def.html">fattr</a> *&nbsp;</td>
          <td class="paramname"> <em>local_attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structzfs__fh__def.html">zfs_fh</a> *&nbsp;</td>
          <td class="paramname"> <em>remote_fh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfattr__def.html">fattr</a> *&nbsp;</td>
          <td class="paramname"> <em>remote_attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>same</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if local and remote files are same. 
<p>
If the local file NAME in directory DIR_FH is the same as remote file REMOTE_FH set SAME to true and return ZFS_OK. Otherwise delete NAME and its subtree from directory DIR_FH and set SAME to false. Use local attributes LOCAL_ATTR and remote attributes REMOTE_ATTR for comparing the files. 
</div>
</div><p>
<a class="anchor" name="070edc4f16621981f4a856c1dfd27b76"></a><!-- doxytag: member="update.c::get_blocks_for_updating" ref="070edc4f16621981f4a856c1dfd27b76" args="(internal_fh fh, uint64_t start, uint64_t end, varray *blocks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void get_blocks_for_updating           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinternal__fh__def.html">internal_fh</a>&nbsp;</td>
          <td class="paramname"> <em>fh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvarray__def.html">varray</a> *&nbsp;</td>
          <td class="paramname"> <em>blocks</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine, which blocks in specified part of the file need to be updated. 
<p>
Get blocks of file FH from interval [START, END) which need to be updated and store them to BLOCKS. 
</div>
</div><p>
<a class="anchor" name="fca851a6baa4f62418a3023be7565c05"></a><!-- doxytag: member="update.c::lookup_remote_dentry_in_the_same_place" ref="fca851a6baa4f62418a3023be7565c05" args="(dir_op_res *res, zfs_fh *fh, internal_dentry *dentryp, volume *volp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t lookup_remote_dentry_in_the_same_place           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdir__op__res__def.html">dir_op_res</a> *&nbsp;</td>
          <td class="paramname"> <em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structzfs__fh__def.html">zfs_fh</a> *&nbsp;</td>
          <td class="paramname"> <em>fh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a> *&nbsp;</td>
          <td class="paramname"> <em>dentryp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvolume__def.html">volume</a> *&nbsp;</td>
          <td class="paramname"> <em>volp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lookup the remote file which is in the same place as the local file. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>res</em>&nbsp;</td><td>Buffer for result of directory operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fh</em>&nbsp;</td><td>File handle of the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dentryp</em>&nbsp;</td><td>Dentry of the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>volp</em>&nbsp;</td><td>Volume which the file is on. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="659ba098368fcbd49cf933b79e39f268"></a><!-- doxytag: member="update.c::reintegrate_deleted_dir" ref="659ba098368fcbd49cf933b79e39f268" args="(dir_op_res *res, uint32_t vid, journal_entry deleted_dir_entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t reintegrate_deleted_dir           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdir__op__res__def.html">dir_op_res</a> *&nbsp;</td>
          <td class="paramname"> <em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structjournal__entry__def.html">journal_entry</a>&nbsp;</td>
          <td class="paramname"> <em>deleted_dir_entry</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reintegrate journal of deleted directory DIR_ENTRY on volume VID. 
<p>
Use RES for lookups. 
</div>
</div><p>
<a class="anchor" name="9b2dc373f369b769e0e81addb8638a37"></a><!-- doxytag: member="update.c::reintegrate_dir" ref="9b2dc373f369b769e0e81addb8638a37" args="(volume vol, internal_dentry dir, zfs_fh *fh, fattr *attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t reintegrate_dir           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvolume__def.html">volume</a>&nbsp;</td>
          <td class="paramname"> <em>vol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structzfs__fh__def.html">zfs_fh</a> *&nbsp;</td>
          <td class="paramname"> <em>fh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfattr__def.html">fattr</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reintegrate journal for directory DIR on volume VOL with file handle FH. 
<p>
Update version of remote directrory in ATTR. 
</div>
</div><p>
<a class="anchor" name="03765e5efe8f67c34dc60fda614e4104"></a><!-- doxytag: member="update.c::reintegrate_file_blocks" ref="03765e5efe8f67c34dc60fda614e4104" args="(zfs_cap *cap, bool slow)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t reintegrate_file_blocks           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structzfs__cap__def.html">zfs_cap</a> *&nbsp;</td>
          <td class="paramname"> <em>cap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>slow</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reintegrate modified blocks of local file CAP to remote file. 
<p>
Function for performing the actual reintegration work.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cap</em>&nbsp;</td><td>Capability of the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slow</em>&nbsp;</td><td>Determines a slow reintegration, checks for slow connections usage and aborts if there are other pending requests. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d9a6c0040f592fdca647ae1c6134eeff"></a><!-- doxytag: member="update.c::resolve_conflict_delete_local" ref="d9a6c0040f592fdca647ae1c6134eeff" args="(dir_op_res *res, internal_dentry dir, zfs_fh *dir_fh, string *name, zfs_fh *local_fh, zfs_fh *remote_fh, volume vol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t resolve_conflict_delete_local           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdir__op__res__def.html">dir_op_res</a> *&nbsp;</td>
          <td class="paramname"> <em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structzfs__fh__def.html">zfs_fh</a> *&nbsp;</td>
          <td class="paramname"> <em>dir_fh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstring__def.html">string</a> *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structzfs__fh__def.html">zfs_fh</a> *&nbsp;</td>
          <td class="paramname"> <em>local_fh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structzfs__fh__def.html">zfs_fh</a> *&nbsp;</td>
          <td class="paramname"> <em>remote_fh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvolume__def.html">volume</a>&nbsp;</td>
          <td class="paramname"> <em>vol</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resolve conflict by deleting local file. 
<p>
Resolve conflict by deleting local file NAME with local file handle LOCAL_FH and remote file handle REMOTE_FH in directory DIR with file handle DIR_FH on volume VOL. Store the info about deleted file into RES. 
</div>
</div><p>
<a class="anchor" name="9f56b919ffd4b001fcba2a5d52b443a4"></a><!-- doxytag: member="update.c::resolve_conflict_delete_remote" ref="9f56b919ffd4b001fcba2a5d52b443a4" args="(volume vol, internal_dentry dir, string *name, zfs_fh *remote_fh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t resolve_conflict_delete_remote           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvolume__def.html">volume</a>&nbsp;</td>
          <td class="paramname"> <em>vol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstring__def.html">string</a> *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structzfs__fh__def.html">zfs_fh</a> *&nbsp;</td>
          <td class="paramname"> <em>remote_fh</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resolve conflict by deleting remote file NAME with file handle REMOTE_FH in directory DIR on volume VOL. 
<p>

</div>
</div><p>
<a class="anchor" name="3d750f23c5ae2d66320c6f5cf96c5346"></a><!-- doxytag: member="update.c::resolve_conflict_discard_local" ref="3d750f23c5ae2d66320c6f5cf96c5346" args="(zfs_fh *conflict_fh, internal_dentry local, internal_dentry remote, volume vol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t resolve_conflict_discard_local           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structzfs__fh__def.html">zfs_fh</a> *&nbsp;</td>
          <td class="paramname"> <em>conflict_fh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a>&nbsp;</td>
          <td class="paramname"> <em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a>&nbsp;</td>
          <td class="paramname"> <em>remote</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvolume__def.html">volume</a>&nbsp;</td>
          <td class="paramname"> <em>vol</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Discard changes to local file LOCAL which is in conflict with REMOTE on volume VOL. 
<p>
CONFLICT_FH is a file handle of the cnflict directory containing these two files. 
</div>
</div><p>
<a class="anchor" name="18bcb8f6f49657c49a5a34baa0c62ee3"></a><!-- doxytag: member="update.c::resolve_conflict_discard_remote" ref="18bcb8f6f49657c49a5a34baa0c62ee3" args="(zfs_fh *conflict_fh, internal_dentry local, internal_dentry remote, volume vol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t resolve_conflict_discard_remote           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structzfs__fh__def.html">zfs_fh</a> *&nbsp;</td>
          <td class="paramname"> <em>conflict_fh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a>&nbsp;</td>
          <td class="paramname"> <em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a>&nbsp;</td>
          <td class="paramname"> <em>remote</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvolume__def.html">volume</a>&nbsp;</td>
          <td class="paramname"> <em>vol</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Discard changes to remote file REMOTE which is in conflict with LOCAL on volume VOL. 
<p>
CONFLICT_FH is a file handle of the cnflict directory containing these two files. 
</div>
</div><p>
<a class="anchor" name="a651587c18911d478989950a8eac0151"></a><!-- doxytag: member="update.c::schedule_update_or_reintegration" ref="a651587c18911d478989950a8eac0151" args="(volume vol, internal_dentry dentry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void schedule_update_or_reintegration           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvolume__def.html">volume</a>&nbsp;</td>
          <td class="paramname"> <em>vol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a>&nbsp;</td>
          <td class="paramname"> <em>dentry</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Schedule update or reintegration of a not yet enqueued regular file. 
<p>
The scheduling happens only for volumes that are currently connected and if some threads in <a class="el" href="update_8h.html#042a22003c0b9b8c3d97d4bc07a4f98c" title="Pool of update threads.">update_pool</a> are running. If the file is on slow connected volume and there is a <a class="el" href="update_8c.html#fcd1f6319a60bb12e5d25c1cfce2e27d" title="Pointer to thread that is performing slow update.">slow_update_worker</a> thread running, it's put into <a class="el" href="update_8c.html#6dbfc3efd6cadb25bb1bdb06aa72126c" title="Queue of file handles for slow updating or reintegrating.">update_slow_queue</a>. Otherwise, it's put into <a class="el" href="update_8h.html#a148194f9fdacbf90ab1965422718cfc" title="Queue of file handles for updating or reintegrating.">update_queue</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vol</em>&nbsp;</td><td>Volume the file is on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dentry</em>&nbsp;</td><td>The dentry of the file. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="117fdb28e2fd52ec5ad7aebefa80c2cd"></a><!-- doxytag: member="update.c::synchronize_attributes" ref="117fdb28e2fd52ec5ad7aebefa80c2cd" args="(volume *volp, internal_dentry *dentryp, zfs_fh *fh, fattr *attr, bool local_changed, bool remote_changed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t synchronize_attributes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvolume__def.html">volume</a> *&nbsp;</td>
          <td class="paramname"> <em>volp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a> *&nbsp;</td>
          <td class="paramname"> <em>dentryp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structzfs__fh__def.html">zfs_fh</a> *&nbsp;</td>
          <td class="paramname"> <em>fh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfattr__def.html">fattr</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>local_changed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>remote_changed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Synchronize attributes and metadata (including regular file's size) of local and remote file. 
<p>
Synchronize attributes of local file with provided attributes of remote file. The attributes synchronized are: modetype, uid, gid, size (for regular files).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>volp</em>&nbsp;</td><td>Volume of the local file. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dentryp</em>&nbsp;</td><td>Internal dentry of the local file. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fh</em>&nbsp;</td><td>ZFS file handle of the local file </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>attr</em>&nbsp;</td><td>Attributes of the remote file. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>local_changed</em>&nbsp;</td><td>The local attributes got changed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>remote_changed</em>&nbsp;</td><td>The remote attributes got changed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="34126cb6d7beb9bd0d291088bbd146dd"></a><!-- doxytag: member="update.c::synchronize_file" ref="34126cb6d7beb9bd0d291088bbd146dd" args="(volume vol, internal_dentry dentry, zfs_fh *fh, fattr *attr, int what, bool same_place)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t synchronize_file           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvolume__def.html">volume</a>&nbsp;</td>
          <td class="paramname"> <em>vol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a>&nbsp;</td>
          <td class="paramname"> <em>dentry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structzfs__fh__def.html">zfs_fh</a> *&nbsp;</td>
          <td class="paramname"> <em>fh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfattr__def.html">fattr</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>what</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>same_place</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Synchronize the local file with the remote file. 
<p>
The function synchronizes metadata (attributes and size) if it's needed, creates conflict if there is one. If the master version changed (without creating conflict), local metadata is updated and updated tree cleared. Updating and reintegrating is only scheduled, not performed instantly in here.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vol</em>&nbsp;</td><td>Volume which the file is on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dentry</em>&nbsp;</td><td>Dentry of the file. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fh</em>&nbsp;</td><td>File handle of the file. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>attr</em>&nbsp;</td><td>Remote attributes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>what</em>&nbsp;</td><td>What should be updated if needed. Bitwise-or combination of <a class="el" href="fh_8h.html#eca2f9dacee337a556efbcd6ec6b1706">IFH_UPDATE</a> for file/dir contents update, <a class="el" href="fh_8h.html#f241099b7d2ef2f0d2bb2bc8239e493b">IFH_REINTEGRATE</a> for reintegration and <a class="el" href="fh_8h.html#293ee415797bb76a692ead8a2d9f506e">IFH_METADATA</a> for metadata (mode, uid, gid), including file size and master version for regular files. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>same_place</em>&nbsp;</td><td>True if the remote attributes are for the file in the same place as the local file. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="712b80b973f870932cbb8fa741d56795"></a><!-- doxytag: member="update.c::truncate_local_file" ref="712b80b973f870932cbb8fa741d56795" args="(volume *volp, internal_dentry *dentryp, zfs_fh *fh, uint64_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t truncate_local_file           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvolume__def.html">volume</a> *&nbsp;</td>
          <td class="paramname"> <em>volp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a> *&nbsp;</td>
          <td class="paramname"> <em>dentryp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structzfs__fh__def.html">zfs_fh</a> *&nbsp;</td>
          <td class="paramname"> <em>fh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Truncate the local file according to the remote size but do not get rid of local modifications of the file. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>volp</em>&nbsp;</td><td>Volume which the file is on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dentryp</em>&nbsp;</td><td>Dentry of the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fh</em>&nbsp;</td><td>File handle of the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Remote size of the file. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3206db6ce423b4e20a7c1e2fb7711cdb"></a><!-- doxytag: member="update.c::update" ref="3206db6ce423b4e20a7c1e2fb7711cdb" args="(volume vol, internal_dentry dentry, zfs_fh *fh, fattr *attr, int how)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t update           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvolume__def.html">volume</a>&nbsp;</td>
          <td class="paramname"> <em>vol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a>&nbsp;</td>
          <td class="paramname"> <em>dentry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structzfs__fh__def.html">zfs_fh</a> *&nbsp;</td>
          <td class="paramname"> <em>fh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfattr__def.html">fattr</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>how</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reintegrate or update generic file. 
<p>
Reintegrate or update generic file DENTRY on volume VOL with file handle FH and remote file attributes ATTR.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>how</em>&nbsp;</td><td>What should be updated if needed. Bitwise-or combination of <a class="el" href="fh_8h.html#eca2f9dacee337a556efbcd6ec6b1706">IFH_UPDATE</a> for file/dir contents update, <a class="el" href="fh_8h.html#f241099b7d2ef2f0d2bb2bc8239e493b">IFH_REINTEGRATE</a> for reintegration and <a class="el" href="fh_8h.html#293ee415797bb76a692ead8a2d9f506e">IFH_METADATA</a> for metadata (mode, uid, gid), including file size and master version for regular files. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="be6f099b6a2fcc2abc9f8fecb5890202"></a><!-- doxytag: member="update.c::update_cap_if_needed" ref="be6f099b6a2fcc2abc9f8fecb5890202" args="(internal_cap *icapp, volume *volp, internal_dentry *dentryp, virtual_dir *vdp, zfs_cap *cap, bool put_cap, int what)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t update_cap_if_needed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinternal__cap__def.html">internal_cap</a> *&nbsp;</td>
          <td class="paramname"> <em>icapp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvolume__def.html">volume</a> *&nbsp;</td>
          <td class="paramname"> <em>volp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a> *&nbsp;</td>
          <td class="paramname"> <em>dentryp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvirtual__dir__def.html">virtual_dir</a> *&nbsp;</td>
          <td class="paramname"> <em>vdp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structzfs__cap__def.html">zfs_cap</a> *&nbsp;</td>
          <td class="paramname"> <em>cap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>put_cap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>what</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update generic file DENTRY on volume VOL associated with capability ICAP if needed. 
<p>
Do WHAT we are asked to do. 
</div>
</div><p>
<a class="anchor" name="19341698513037bdd134d627755ff3b7"></a><!-- doxytag: member="update.c::update_cleanup" ref="19341698513037bdd134d627755ff3b7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void update_cleanup           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy <a class="el" href="update_8h.html#042a22003c0b9b8c3d97d4bc07a4f98c" title="Pool of update threads.">update_pool</a> and cleanup the mutexes and queues for updating. 
<p>

</div>
</div><p>
<a class="anchor" name="6005411200a12efe387af995b3625b7a"></a><!-- doxytag: member="update.c::update_dir" ref="6005411200a12efe387af995b3625b7a" args="(volume vol, internal_dentry dir, zfs_fh *fh, fattr *attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t update_dir           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvolume__def.html">volume</a>&nbsp;</td>
          <td class="paramname"> <em>vol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structzfs__fh__def.html">zfs_fh</a> *&nbsp;</td>
          <td class="paramname"> <em>fh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfattr__def.html">fattr</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update the directory DIR on volume VOL with file handle FH, set attributes according to ATTR. 
<p>

</div>
</div><p>
<a class="anchor" name="aea7cdd865f077cb639f4983e4f628e9"></a><!-- doxytag: member="update.c::update_fh_if_needed" ref="aea7cdd865f077cb639f4983e4f628e9" args="(volume *volp, internal_dentry *dentryp, zfs_fh *fh, int what)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t update_fh_if_needed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvolume__def.html">volume</a> *&nbsp;</td>
          <td class="paramname"> <em>volp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a> *&nbsp;</td>
          <td class="paramname"> <em>dentryp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structzfs__fh__def.html">zfs_fh</a> *&nbsp;</td>
          <td class="paramname"> <em>fh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>what</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update generic file DENTRY with file handle FH on volume VOL if needed and wanted. 
<p>
Uses <a class="el" href="update_8c.html#8c3a739e65554ced54ed933826f6c123" title="Determine if and how the local file should be updated.">update_p()</a> to determine what should be updated and performs the intersetion of the result and WHAT via <a class="el" href="update_8c.html#3206db6ce423b4e20a7c1e2fb7711cdb" title="Reintegrate or update generic file.">update()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>what</em>&nbsp;</td><td>What should be updated if needed. Bitwise-or combination of <a class="el" href="fh_8h.html#eca2f9dacee337a556efbcd6ec6b1706">IFH_UPDATE</a> for file/dir contents update, <a class="el" href="fh_8h.html#f241099b7d2ef2f0d2bb2bc8239e493b">IFH_REINTEGRATE</a> for reintegration and <a class="el" href="fh_8h.html#293ee415797bb76a692ead8a2d9f506e">IFH_METADATA</a> for metadata (mode, uid, gid), including file size and master version for regular files. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d51a0b4039b35ba2caeb35402d04c4c8"></a><!-- doxytag: member="update.c::update_fh_if_needed_2" ref="d51a0b4039b35ba2caeb35402d04c4c8" args="(volume *volp, internal_dentry *dentryp, internal_dentry *dentry2p, zfs_fh *fh, zfs_fh *fh2, int what)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t update_fh_if_needed_2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvolume__def.html">volume</a> *&nbsp;</td>
          <td class="paramname"> <em>volp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a> *&nbsp;</td>
          <td class="paramname"> <em>dentryp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a> *&nbsp;</td>
          <td class="paramname"> <em>dentry2p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structzfs__fh__def.html">zfs_fh</a> *&nbsp;</td>
          <td class="paramname"> <em>fh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structzfs__fh__def.html">zfs_fh</a> *&nbsp;</td>
          <td class="paramname"> <em>fh2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>what</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update generic file DENTRY on volume VOL if needed. 
<p>
DENTRY and DENTRY2 are locked before and after this macro. DENTRY2 might be deleted in update. Do WHAT we are asked to do. 
</div>
</div><p>
<a class="anchor" name="acfec61c9a4b34fc36a60462a083072a"></a><!-- doxytag: member="update.c::update_file" ref="acfec61c9a4b34fc36a60462a083072a" args="(zfs_fh *fh, bool slowthread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t update_file           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structzfs__fh__def.html">zfs_fh</a> *&nbsp;</td>
          <td class="paramname"> <em>fh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>slowthread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fully update regular file with file handle FH. 
<p>
The main file updating function of <a class="el" href="update_8c.html#3645d29d463f96be6e22c7d8b119580d" title="The main function of an update thread.">update_worker</a>. Determines what should be updated and performs it. Handles the connection status change of volume master of the file. Reschedules the file for further updating if it couldn't finish it.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fh</em>&nbsp;</td><td>File handle (taken from <a class="el" href="update_8h.html#a148194f9fdacbf90ab1965422718cfc" title="Queue of file handles for updating or reintegrating.">update_queue</a> or <a class="el" href="update_8c.html#6dbfc3efd6cadb25bb1bdb06aa72126c" title="Queue of file handles for slow updating or reintegrating.">update_slow_queue</a>) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slowthread</em>&nbsp;</td><td>Determines if the thread is slow updater. If the file is on volume with different speed, it's resolved. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="03d0d58bd98ce17acc4958ca72fa5626"></a><!-- doxytag: member="update.c::update_file_blocks" ref="03d0d58bd98ce17acc4958ca72fa5626" args="(zfs_cap *cap, varray *blocks, bool modified, bool slow)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t update_file_blocks           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structzfs__cap__def.html">zfs_cap</a> *&nbsp;</td>
          <td class="paramname"> <em>cap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvarray__def.html">varray</a> *&nbsp;</td>
          <td class="paramname"> <em>blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>modified</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>slow</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update blocks of local file according to remote file. 
<p>
Prepares the md5sum arguments for <a class="el" href="update_8c.html#d3c97f646655d5e965e3c279cb38f922" title="Update parts of file from remote file.">update_file_blocks_1</a> and calls it.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cap</em>&nbsp;</td><td>Capability of the local file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blocks</em>&nbsp;</td><td>Blocks to be updated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>modified</em>&nbsp;</td><td>Flag saying the local file has been modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slow</em>&nbsp;</td><td>Just passed to <a class="el" href="update_8c.html#d3c97f646655d5e965e3c279cb38f922" title="Update parts of file from remote file.">update_file_blocks_1</a> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d3c97f646655d5e965e3c279cb38f922"></a><!-- doxytag: member="update.c::update_file_blocks_1" ref="d3c97f646655d5e965e3c279cb38f922" args="(md5sum_args *args, zfs_cap *cap, varray *blocks, unsigned int *idx, bool slow)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t update_file_blocks_1           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmd5sum__args__def.html">md5sum_args</a> *&nbsp;</td>
          <td class="paramname"> <em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structzfs__cap__def.html">zfs_cap</a> *&nbsp;</td>
          <td class="paramname"> <em>cap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvarray__def.html">varray</a> *&nbsp;</td>
          <td class="paramname"> <em>blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>slow</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update parts of file from remote file. 
<p>
The core function for updating file contents from remote file. Used either for updating part of file that user requested, or for all blocks not updated yet, via background update thread. Each block is first checked if it's really different from remote file, by md5 hash comparing. May be called from slow update worker thread, it will check for slow connections usage before time consuming remote functions, and eventually abort updating.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cap</em>&nbsp;</td><td>Capability of file to be updated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blocks</em>&nbsp;</td><td>List of blocks to update. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>args</em>&nbsp;</td><td>List of blocks for md5 comparing. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>idx</em>&nbsp;</td><td>Number of block to start searching from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slow</em>&nbsp;</td><td>Determines if it should check for requests pending on slow lines and abort if there are some. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fc3d32e50e797e78daee46bcebf07f31"></a><!-- doxytag: member="update.c::update_file_clear_updated_tree" ref="fc3d32e50e797e78daee46bcebf07f31" args="(zfs_fh *fh, uint64_t version)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t update_file_clear_updated_tree           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structzfs__fh__def.html">zfs_fh</a> *&nbsp;</td>
          <td class="paramname"> <em>fh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>version</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear the tree of updated intervals and set version of file. 
<p>
Wrapper for <a class="el" href="update_8c.html#33a0ed40ca8d9d1fb994f0dedc6cac0f" title="Clear the tree of updated intervals and set version of dentry.">update_file_clear_updated_tree_1</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fh</em>&nbsp;</td><td>File handle of the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>version</em>&nbsp;</td><td>New version of the file. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="33a0ed40ca8d9d1fb994f0dedc6cac0f"></a><!-- doxytag: member="update.c::update_file_clear_updated_tree_1" ref="33a0ed40ca8d9d1fb994f0dedc6cac0f" args="(volume vol, internal_dentry dentry, uint64_t version)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t update_file_clear_updated_tree_1           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvolume__def.html">volume</a>&nbsp;</td>
          <td class="paramname"> <em>vol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a>&nbsp;</td>
          <td class="paramname"> <em>dentry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>version</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear the tree of updated intervals and set version of dentry. 
<p>
Used when new version detected on master node, to update whole file again. Changes file's local and master version in metadata and updated tree.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>version</em>&nbsp;</td><td>New version to set as local for the file and master_version in metadata. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="69c89c73f1d26e04225ef65f949c7351"></a><!-- doxytag: member="update.c::update_main" ref="69c89c73f1d26e04225ef65f949c7351" args="(ATTRIBUTE_UNUSED void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void* update_main           </td>
          <td>(</td>
          <td class="paramtype">ATTRIBUTE_UNUSED void *&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Main function of the main update thread. 
<p>
This is the main thread in <a class="el" href="update_8h.html#042a22003c0b9b8c3d97d4bc07a4f98c" title="Pool of update threads.">update_pool</a>. It regulates number of threads there, gets file handles from <a class="el" href="update_8h.html#a148194f9fdacbf90ab1965422718cfc" title="Queue of file handles for updating or reintegrating.">update_queue</a>, passes them into one idle thread's data and wakes up that thread via raising its semaphore. 
</div>
</div><p>
<a class="anchor" name="8c3a739e65554ced54ed933826f6c123"></a><!-- doxytag: member="update.c::update_p" ref="8c3a739e65554ced54ed933826f6c123" args="(volume *volp, internal_dentry *dentryp, zfs_fh *fh, fattr *attr, bool fh_mutex_locked)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int update_p           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvolume__def.html">volume</a> *&nbsp;</td>
          <td class="paramname"> <em>volp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal__dentry__def.html">internal_dentry</a> *&nbsp;</td>
          <td class="paramname"> <em>dentryp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structzfs__fh__def.html">zfs_fh</a> *&nbsp;</td>
          <td class="paramname"> <em>fh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfattr__def.html">fattr</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>fh_mutex_locked</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine if and how the local file should be updated. 
<p>
Get the attributes from remote file and compare them with attributes of local dentry, return what should be updated.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>attr</em>&nbsp;</td><td>For returning the determined remote attributes.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Bitwise-or</em>&nbsp;</td><td>combination of <a class="el" href="fh_8h.html#eca2f9dacee337a556efbcd6ec6b1706">IFH_UPDATE</a> for file/dir contents update, <a class="el" href="fh_8h.html#f241099b7d2ef2f0d2bb2bc8239e493b">IFH_REINTEGRATE</a> for reintegration and <a class="el" href="fh_8h.html#293ee415797bb76a692ead8a2d9f506e">IFH_METADATA</a> for metadata (mode, uid, gid), including file size and master version for regular files.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="update_8h.html#4ee1026de0a6ec4670c67d687fd27b40" title="Check whether we should update a generic file.">UPDATE_P</a> <p>
<a class="el" href="update_8h.html#2630c17ca8a44d638f8750a4217d5043" title="Check whether we should reintegrate a generic file.">REINTEGRATE_P</a> <p>
<a class="el" href="update_8h.html#d6e3397d3472faa9518123b238388fa0" title="Have local or remote metadata/attributes (mode, UID and GID, size and master version)...">METADATA_CHANGE_P</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6e55fb2c33d8aba365ce6cf0592ae2fb"></a><!-- doxytag: member="update.c::update_start" ref="6e55fb2c33d8aba365ce6cf0592ae2fb" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool update_start           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the mutexes and queues for updating, and create the <a class="el" href="update_8h.html#042a22003c0b9b8c3d97d4bc07a4f98c" title="Pool of update threads.">update_pool</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="3645d29d463f96be6e22c7d8b119580d"></a><!-- doxytag: member="update.c::update_worker" ref="3645d29d463f96be6e22c7d8b119580d" args="(void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void* update_worker           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The main function of an update thread. 
<p>
Normal update threads get their file handles passed from thread performing <a class="el" href="update_8c.html#69c89c73f1d26e04225ef65f949c7351" title="Main function of the main update thread.">update_main()</a>, which also regulates them and lets them run by raising their semaphore. With the file handle got, they perform update. When a thread becomes slow_updater, it's the only one doing that so it can get file handles from the <a class="el" href="update_8c.html#6dbfc3efd6cadb25bb1bdb06aa72126c" title="Queue of file handles for slow updating or reintegrating.">update_slow_queue</a> itself. It's no longer regulated by update_pool because it appears as busy to it all the time. When the <a class="el" href="update_8c.html#6dbfc3efd6cadb25bb1bdb06aa72126c" title="Queue of file handles for slow updating or reintegrating.">update_slow_queue</a> becames empty, the slow updater converts back to normal updater and goes idle. 
</div>
</div><p>
<a class="anchor" name="afad1383e20a1acb871407cb3b3790fc"></a><!-- doxytag: member="update.c::update_worker_cleanup" ref="afad1383e20a1acb871407cb3b3790fc" args="(void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void update_worker_cleanup           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cleanup update thread DATA. 
<p>

</div>
</div><p>
<a class="anchor" name="a0cf7042a840e8936d0f331853c5f5a3"></a><!-- doxytag: member="update.c::update_worker_init" ref="a0cf7042a840e8936d0f331853c5f5a3" args="(thread *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void update_worker_init           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structthread__def.html">thread</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize update thread T. 
<p>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="fcd1f6319a60bb12e5d25c1cfce2e27d"></a><!-- doxytag: member="update.c::slow_update_worker" ref="fcd1f6319a60bb12e5d25c1cfce2e27d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structthread__def.html">thread</a>* <a class="el" href="update_8c.html#fcd1f6319a60bb12e5d25c1cfce2e27d">slow_update_worker</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pointer to thread that is performing slow update. 
<p>
Protected by <a class="el" href="update_8c.html#679fb99ef8a4d636d093f3a850ee8449" title="Mutex for update_slow_queue and slow_update_worker.">update_slow_queue_mutex</a> 
</div>
</div><p>
<a class="anchor" name="042a22003c0b9b8c3d97d4bc07a4f98c"></a><!-- doxytag: member="update.c::update_pool" ref="042a22003c0b9b8c3d97d4bc07a4f98c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structthread__pool__def.html">thread_pool</a> <a class="el" href="update_8h.html#042a22003c0b9b8c3d97d4bc07a4f98c">update_pool</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pool of update threads. 
<p>

</div>
</div><p>
<a class="anchor" name="a148194f9fdacbf90ab1965422718cfc"></a><!-- doxytag: member="update.c::update_queue" ref="a148194f9fdacbf90ab1965422718cfc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structqueue__def.html">queue</a> <a class="el" href="update_8h.html#a148194f9fdacbf90ab1965422718cfc">update_queue</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Queue of file handles for updating or reintegrating. 
<p>
Protected by <a class="el" href="update_8c.html#43a4cc01a3da1beb214263186d1c6225" title="Mutex for update_queue.">update_queue_mutex</a>. File handles are processed by threads in <a class="el" href="update_8h.html#042a22003c0b9b8c3d97d4bc07a4f98c" title="Pool of update threads.">update_pool</a> 
</div>
</div><p>
<a class="anchor" name="43a4cc01a3da1beb214263186d1c6225"></a><!-- doxytag: member="update.c::update_queue_mutex" ref="43a4cc01a3da1beb214263186d1c6225" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_mutex_t <a class="el" href="update_8c.html#43a4cc01a3da1beb214263186d1c6225">update_queue_mutex</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mutex for <a class="el" href="update_8h.html#a148194f9fdacbf90ab1965422718cfc" title="Queue of file handles for updating or reintegrating.">update_queue</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="6dbfc3efd6cadb25bb1bdb06aa72126c"></a><!-- doxytag: member="update.c::update_slow_queue" ref="6dbfc3efd6cadb25bb1bdb06aa72126c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structqueue__def.html">queue</a> <a class="el" href="update_8c.html#6dbfc3efd6cadb25bb1bdb06aa72126c">update_slow_queue</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Queue of file handles for slow updating or reintegrating. 
<p>
Protected by <a class="el" href="update_8c.html#679fb99ef8a4d636d093f3a850ee8449" title="Mutex for update_slow_queue and slow_update_worker.">update_slow_queue_mutex</a>. File handles are processed by one thread from <a class="el" href="update_8h.html#042a22003c0b9b8c3d97d4bc07a4f98c" title="Pool of update threads.">update_pool</a>, referenced by <a class="el" href="update_8c.html#fcd1f6319a60bb12e5d25c1cfce2e27d" title="Pointer to thread that is performing slow update.">slow_update_worker</a>. 
</div>
</div><p>
<a class="anchor" name="679fb99ef8a4d636d093f3a850ee8449"></a><!-- doxytag: member="update.c::update_slow_queue_mutex" ref="679fb99ef8a4d636d093f3a850ee8449" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_mutex_t <a class="el" href="update_8c.html#679fb99ef8a4d636d093f3a850ee8449">update_slow_queue_mutex</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mutex for <a class="el" href="update_8c.html#6dbfc3efd6cadb25bb1bdb06aa72126c" title="Queue of file handles for slow updating or reintegrating.">update_slow_queue</a> and <a class="el" href="update_8c.html#fcd1f6319a60bb12e5d25c1cfce2e27d" title="Pointer to thread that is performing slow update.">slow_update_worker</a>. 
<p>

</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Aug 6 00:39:38 2010 for zlomekFS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.2 </small></address>
</body>
</html>
