<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>zlomekFS: File updating and reintegration in ZFS.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<h1><a class="anchor" name="file-updating">File updating and reintegration in ZFS.</a></h1><h2>Introduction</h2>
<p>
File updating and reintegration (or synchronization in general) means propagating the changes between local cached file and the same file on volume master (remote node). These changes are: <ul>
<li>
file attributes and metadata (mode, uid, gid, size and master version) - synchronized by <a class="el" href="update_8c.html#117fdb28e2fd52ec5ad7aebefa80c2cd" title="Synchronize attributes and metadata (including regular file's size) of local and...">synchronize_attributes()</a> </li>
<li>
data in file changed on remote node that need fetching to local node (update) - handled by <a class="el" href="update_8c.html#3206db6ce423b4e20a7c1e2fb7711cdb" title="Reintegrate or update generic file.">update()</a> and <a class="el" href="update_8c.html#acfec61c9a4b34fc36a60462a083072a" title="Fully update regular file with file handle FH.">update_file()</a>, which call <a class="el" href="update_8c.html#03d0d58bd98ce17acc4958ca72fa5626" title="Update blocks of local file according to remote file.">update_file_blocks()</a> </li>
<li>
data in file changed on local node that need to be sent to remote node (reintegration) - handled also by <a class="el" href="update_8c.html#3206db6ce423b4e20a7c1e2fb7711cdb" title="Reintegrate or update generic file.">update()</a> and <a class="el" href="update_8c.html#acfec61c9a4b34fc36a60462a083072a" title="Fully update regular file with file handle FH.">update_file()</a>, which call <a class="el" href="update_8c.html#03765e5efe8f67c34dc60fda614e4104" title="Reintegrate modified blocks of local file CAP to remote file.">reintegrate_file_blocks()</a> </li>
</ul>
This synchronization can be done synchronously, for example when opening directory by <a class="el" href="file_8c.html#cdda7514c08404d56b10105f08bb610f" title="Open file handle FH with open flags FLAGS and return capability in CAP.">zfs_open()</a>, everything gets synchronized, when opening file by <a class="el" href="file_8c.html#cdda7514c08404d56b10105f08bb610f" title="Open file handle FH with open flags FLAGS and return capability in CAP.">zfs_open()</a>, only metadata is synchronized. File contents of regular files can be scheduled via <a class="el" href="update_8c.html#a651587c18911d478989950a8eac0151" title="Schedule update or reintegration of a not yet enqueued regular file.">schedule_update_or_reintegration()</a> and then updated and reintegrated on background by threads in <a class="el" href="update_8h.html#042a22003c0b9b8c3d97d4bc07a4f98c" title="Pool of update threads.">update_pool</a> via <a class="el" href="update_8c.html#acfec61c9a4b34fc36a60462a083072a" title="Fully update regular file with file handle FH.">update_file()</a> or synchronously, when user reads/writes them, via <a class="el" href="update_8c.html#3206db6ce423b4e20a7c1e2fb7711cdb" title="Reintegrate or update generic file.">update()</a>. The background updating/reintegration is different for volumes, whose volume master is node connected via fast connection, and for volume masters with slow connection. This is determined by measuring latency when connecting to the volume master.<p>
<h2>Changes in background updating/reintegration for slowly connected volumes</h2>
<p>
Formerly, there were no background operations allowed for such volumes. The reason was to prevent these operations from congesting the node's connection, thus slowing down other, more interactive operations, like listing and walking through directories. But sometimes user doesn't need the connectivity for anything else, and it would be nice to get new/changed files integrated to remote master, or fully updated in local cache for future use. So the background synchronisation is now enabled for slow volumes too. But it's important to monitor connection usage and hold the background operations in favour of the interactive ones. The solution used here presumes that all slowly connected volumes are slow because of one common bottleneck (for example user connected via GPRS on his notebook has slow connection to every remote volume). Thus, the monitored value is total number of requests being sent/waiting for or getting response on all slow connected volumes, stored and managed by <a class="el" href="network_8h.html#9528d09825e9e042f5444b59106ea84f" title="Number of pending slow requests.">pending_slow_reqs_count</a> and its condvar and mutex. The background integration for slow volumes is done by one special thread from the update pool, which pauses its operation when it detects this number being above zero. This favours interactive operations on slow connected volumes, but it doesn't prevent ZFS from slowing down other applications's connection. Because it would be difficult to determine when ZFS could use the line or not, it's up to user to shape ZFS's bandwith for his needs, for example by ZFS's default listening port.<p>
<h2>Other changes/bugfixes to file synchronisation</h2>
<p>
The first change is about file sizes. Previously, each new physical file created (locally or remotely) by synchronising directory content, had size of zero bytes, regardless of the opposite side's size. Then the size grew as the file was being updated or reintegrated, until it was fully done. Subsequent changes to file size also weren't visible for the other side until actual updating/reintegration of data. This was inconvenient for stat() operations performed on such files, because they didn't reflect size that the user should really see. And after mmap() support was added, it wasn't even possible to read data from such file, because reads using kernel page cache don't try to read more data if they see file size being lower (zero). The solution is that during file creation (<a class="el" href="update_8c.html#2903310f18713917af9829e051301b99" title="Create local generic file based on remote attributes.">create_local_fh()</a> and <a class="el" href="update_8c.html#192f5bfdab4a035288af788030500f0d" title="Create remote generic file based on local attributes.">create_remote_fh()</a>) and attributes synchronisation (<a class="el" href="update_8c.html#117fdb28e2fd52ec5ad7aebefa80c2cd" title="Synchronize attributes and metadata (including regular file's size) of local and...">synchronize_attributes()</a>), opposite side's file size is used to ftruncate() the local underlying physical file, shrinking or preallocating it (with zeroes). The kernel module can then see the proper size of files, and so can the user.<p>
The second change (or bugfix) is about the <a class="el" href="update_8c.html#34126cb6d7beb9bd0d291088bbd146dd" title="Synchronize the local file with the remote file.">synchronize_file()</a> function. It gets called in <a class="el" href="file_8c.html#cdda7514c08404d56b10105f08bb610f" title="Open file handle FH with open flags FLAGS and return capability in CAP.">zfs_open()</a> to synchronize with remote file, so the user gets actual version of the file. But the effects of master version being increased weren't dealt properly here, and under certain (race) conditions the newer version on volume master was ignored and old local version was being read without a way to invoke updating. Now there's a <a class="el" href="update_8c.html#33a0ed40ca8d9d1fb994f0dedc6cac0f" title="Clear the tree of updated intervals and set version of dentry.">update_file_clear_updated_tree_1()</a> call in such situation, which fixes it. The <a class="el" href="update_8c.html#a651587c18911d478989950a8eac0151" title="Schedule update or reintegration of a not yet enqueued regular file.">schedule_update_or_reintegration()</a> call was also moved to the end of this function, when the metadata are already synchronized and no conflict was created. As a small optimisation, <a class="el" href="file_8c.html#cdda7514c08404d56b10105f08bb610f" title="Open file handle FH with open flags FLAGS and return capability in CAP.">zfs_open()</a> doesn't request regular file background reintegration no more, only updating, because local changes should be reintegrated after file gets closed, while having local data updated before we need them is always convenient. <hr size="1"><address style="text-align: right;"><small>Generated on Fri Aug 6 00:39:38 2010 for zlomekFS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.2 </small></address>
</body>
</html>
