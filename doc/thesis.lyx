#LyX 1.4.4 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass article
\language english
\inputencoding latin2
\fontscheme default
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\end_header

\begin_body

\begin_layout Title
Regression Testing For zlomekFS
\end_layout

\begin_layout Author
Jiri Zouhar
\end_layout

\begin_layout Abstract
Something very smart it is, young adept.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
Motivation
\end_layout

\begin_layout Subsection
Goals
\end_layout

\begin_layout Standard
Extend the existing zlomekFS implementation by introducing a regression
 testing framework.
 The framework should be capable of submitting both predefined and random
 workload to the filesystem and, either by comparing the results with the
 same operations performed over another filesystem, or by some other appropriate
 means, identify filesystem errors.
 The identification of an error should contain both a minimal sequence of
 steps necessary to reproduce the error, and the debugging protocol excerpt
 relevant to the error.
 The framework should include support for generating the debugging protocol
 and changing the network conditions.
\end_layout

\begin_layout Standard
Make all the developer documentation an integral part of the zlomekFS project
 using appropriate tools such as DoxyGen.
\end_layout

\begin_layout Subsection
Structure of the Thesis
\end_layout

\begin_layout Section
Filesystem testing
\end_layout

\begin_layout Standard
Filesystem can be seen as many things and thus it can be tested from at
 least the same number points of view.
 
\end_layout

\begin_layout Paragraph
Specification testing
\end_layout

\begin_layout Standard
We could look on filesystem as a specification of way how to store data
 and associated metedata on some storage media.
 In this case we can ask if the structures are sufficient for accessing
 the data, if the specfication cover all eventual operations that should
 be availible and if the transistions are sane.
 testy od stolu, pouze jednou
\end_layout

\begin_layout Paragraph
Api conformity
\end_layout

\begin_layout Standard
Some filesystems don't focus on the way how to store data on media but how
 to make them accessible.
 Well known group of such filesystems are network filesystems.
 They suppose that some other filesystem do the storage and they specify
 only the way how they will be accessible remotely and put some restrictions
 on the filesystem behaviour.
 In this case we test the particular implementations if they are conform
 to the specification.
 stabilni iface / protokol
\end_layout

\begin_layout Paragraph
Functional testing
\end_layout

\begin_layout Standard
implementation
\end_layout

\begin_layout Standard
Filesystems have many things in common with normal pieces of code such as
 server or desktop applications.
 But in the means of tesing there is big problem in simulating normal enviroment
 for filesystems.
 This is caused by their low level nature and could be one of key reasons
 why most of the test suites are designed as black box testing.
\end_layout

\begin_layout Standard
is the one we will be doing.
\end_layout

\begin_layout Standard
The most desired feature on testing framework is ease of use tightly coupled
 with automation.
 To achieve this, the tests have to be written in understandable format,
 close to the tested code.
 By the meaning of regression testing, they have to be runned automatically,
 in scheduled periods (defined by amouth of time or changes), the results
 must be collected and presented in readable format somewhere.
\end_layout

\begin_layout Standard
For tracing the code execution, there may be some tracing tools and logging
 tools.
 They have to have minimal footprint and collect as much information as
 possible.
 Their output must be formatted in way compatible with the automation framework
 and with the presentation tool too, if possible.
\end_layout

\begin_layout Standard
The output of tests could be accompanied with some state information from
 the time of failure.
 This can be achieved by using some snapshoting tool which may or may not
 support resuming.
 
\end_layout

\begin_layout Standard
For filesystem testing, it is hard to find good testing patterns, which
 will cover all cases, which can occur.
 So it is good idea to have some random workload generator, which can randomly
 exercise the filesystem.
 The problem with this approach is, that outputs of such testing tends to
 be very big and only a small portion of them is related to the occured
 error.
 To allow random testing and avoid the unwanted side efects, some pruning
 algorithm has to be used.
 The reruns of tests may use the snapshots, if the method used for snapshoting
 make the resume possible.
\end_layout

\begin_layout Standard
As the ZloFS is multi-threaded, distributed filesystem, the suite should
 have some support or at least extensibility to allow control or simulation
 of distributed enviroment.
\end_layout

\begin_layout Paragraph
Benchmarking
\end_layout

\begin_layout Standard
Are tests which should answer the question 
\begin_inset Quotes eld
\end_inset

how long it will take
\begin_inset Quotes erd
\end_inset

 for every operation we could do with filesystem.
 They measure the performance of specific implementation in conjunction
 with given setup assuming the implementation is sane and doesn't do any
 invalid shortcuts.
 Their goal is to compare more implementations or filesystems.
 This thesis won't consider this type of tests, because there is only one
 implementation of ZFS.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
Format
\end_layout

\begin_layout Standard
native, scripting, misc, xml, behavior-prot, 
\end_layout

\begin_layout Subsection
Logging, tracing
\end_layout

\begin_layout Paragraph
Models
\end_layout

\begin_layout Standard
When an error is detected in software, developer need to have as much informatio
n about the failure as possible.
 What occured is nice to know but without more details about the run is
 in most cases useless.
 Therefore developers uses logging and tracing to get some useful information
 about the particular run.
\end_layout

\begin_layout Standard
By tracing we will mean storing information about call sequence in the program,
 by logging we will mean saving information about data changes and additional
 notes about states of system inserted by developers.
 In most cases we join this two features for simplicity to one tool.
 
\end_layout

\begin_layout Standard
The simpliest logging tool used is printing messages to output.
 Printing may provide the information needed, but it suffer by not having
 centrallized control of what has to be printed.
 This leads to excessive logging in which is hard to find a usefull information
 and if we want to avoid this, it force us to changing the code on many
 places.
 
\end_layout

\begin_layout Standard
So the next logical step is to send logging messages to some centralized
 facility accompanied by importance of the message.
 The importance levels are in most cases directly given in advance.
 Then it is possible to change the amount of information centrally and even
 redirect the messages to other destination than output.
\end_layout

\begin_layout Standard
When simple distinguishment by importance is not enough then more advanced
 logging facilities comes with tagging of messages.
 The tags could be flat or of arbitrary structure.
 This allows better filtering of messages of special types.
\end_layout

\begin_layout Standard
Other approach to logging is to have more than one centrallized logger.
 In this case the loggers have frequently producer - consumer based architecture
 and are organized to dynamically created hierarchy.
 This ease goal of having different output locations for different types
 of messages.
 On the other hand, the architecture is not so easy to understand for anybody
 who might contribute to the code.
 Moreover, with more people participating on development, it is nearly impossibl
e to keep the hierarchy of producers and consumers used in application sane.
 
\end_layout

\begin_layout Standard
The last approach to logging and tracing is something called 
\begin_inset Quotes eld
\end_inset

aspect oriented programing
\begin_inset Quotes erd
\end_inset

.
 In this case the logging is not present in code itself but it is separated
 as independent concern to aspect - logical definition what and where has
 to be logged.
 
\end_layout

\begin_layout Paragraph
Pitfalls
\end_layout

\begin_layout Standard
Even if a adequate logging facility is used to debug the software it can
 leads to problems when used under some automated stress testing.
 The amouth of output logs will eventually gets too big for the storage
 capacity or at least for the potential reader of them.
 So the automation tool must be able to communicate with the logging facility
 and in some way dynamically change the amouth of output according the needs.
 This must be tuned so the biggest possible portion of unrelated logs is
 thrown away but the crucial information for debugging is preserved for
 failure as the failure could be hard to repeat.
\end_layout

\begin_layout Standard
There is one more reason that may be considered for muting the logging output.
 The reason is that logging could slow the application down and make some
 synchronization primitive which could prevent some collisions to appear.
 
\end_layout

\begin_layout Standard
Problem with synchronization could be solved by design of logging facility.
 The logger must be designed in way that create separated resources for
 every concurrently running entity.
 Then The only effect done by the logger is slowdown of creation of new
 
\begin_inset Quotes eld
\end_inset

threads
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
To check how much logging slows down a ordinary application, some measurement
 was done.
 For testing was used threaded session server accessible by network from
 the SUCKS 
\begin_inset LatexCommand \cite{SUCKS}

\end_inset

project.
 The logging facility was simple centralizet logger with pre-definet log
 levels alternated so it measures the time spent by logging.
 Tests consists of pre-defined workload both valid and invalid requests.
 Output was time spent by the application, time spent by logging and characters
 printed.
 Test cycle was coposet of one run of all tests for every log level and
 log target.
 After finishing the cycle starts again.
 This had been running for approximately thirty hours on two platforms:
\end_layout

\begin_layout Enumerate
intel centrino with core2duo cpu set to static frequency of 1Ghz with 2GB
 memory (most unused) running kernel 2.6.20.1 x86_64.
 
\end_layout

\begin_layout Enumerate
motorola ppc MPC8241 (177 bogomips) with 128MB memory running kernel 2.4.32
\end_layout

\begin_layout Standard
Both platforms behave equally, the only difference was in speed.
 
\end_layout

\begin_layout Standard
Some failures in software are hardly reproducible.
 In this cases we want to store 
\end_layout

\begin_layout Standard
monolog, log4x, syslog, printf, aspectj
\end_layout

\begin_layout Standard
simple printing, centralized printing, producers / consumers, aspect oriented,
 matrix based
\end_layout

\begin_layout Subsection
Presentation layer
\end_layout

\begin_layout Standard
web, log, app
\end_layout

\begin_layout Subsection
Random workload generation
\end_layout

\begin_layout Subsection
Pruning output
\end_layout

\begin_layout Subsection
Checkpointing
\end_layout

\begin_layout Subsection
Distributed testing
\end_layout

\begin_layout Subsection
Sandboxing
\end_layout

\begin_layout Subsection
Automation
\end_layout

\begin_layout Subsection
Filesystem test patterns
\end_layout

\begin_layout Paragraph
fstest
\end_layout

\begin_layout Paragraph
fsx
\end_layout

\begin_layout Paragraph
solaris
\end_layout

\begin_layout Paragraph
ltp
\end_layout

\begin_layout Section
The test suite architecture
\end_layout

\begin_layout Subsection
Used tools
\end_layout

\begin_layout Paragraph
Web result presentation
\end_layout

\begin_layout Paragraph
Logging
\end_layout

\begin_layout Paragraph
Build bot
\end_layout

\begin_layout Paragraph
Documentation
\end_layout

\begin_layout Paragraph
Coding standard
\end_layout

\begin_layout Section
Implementation details
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \bibtex[plain]{references}

\end_inset


\end_layout

\end_body
\end_document
