#LyX 1.5.3 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass book
\begin_preamble
\newcommand{\textstylecode}[1]{
 \begin{quote}
  \texttt{#1}
 \end{quote}
}

\newenvironment{codeblock}{
\begin{quote}
\begin{ttfamily}}{
\end{ttfamily}
\end{quote}
}

\usepackage{listings}
\usepackage{varioref}
\end_preamble
\language english
\inputencoding latin2
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize 12
\spacing single
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 3.5cm
\topmargin 3cm
\rightmargin 3.5cm
\bottommargin 5cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Regression Testing For zlomekFS
\end_layout

\begin_layout Author
Jiri Zouhar
\end_layout

\begin_layout Standard
ZlomekFS is distributed file system aimed to transparent sharing of directory
 trees.
 
\end_layout

\begin_layout Standard
This thesis sumarizes actual methods used for software testing, debugging
 and bug tracing.
 Where applicable, emphasis is put on specific application of these methods
 on filesystems.
 
\end_layout

\begin_layout Standard
On basis of this the actual system for ZlomekFS is considered and build.
 System consists of six parts.
\end_layout

\begin_layout Standard
Unit testing framework for C code, providing automatic test discovery and
 minimalistic api.
\end_layout

\begin_layout Standard
Logging facility with C and python interface, using message importance and
 concern for filtering.
 The logger is remotelly controllable.
\end_layout

\begin_layout Standard
Workload generator which can generate random test sequence.
 Rules for random workload can be defined by tests content and dependency
 graph describing order constrains.
 Failed sequences can be saved for later reproduction.
 The generator can try to find the shortest path to repoduce error.
\end_layout

\begin_layout Standard
Test controlling and reporting framework.
 This part controls test execution, prepares sane environment, executes
 tests and collects data for further failure investigation.
\end_layout

\begin_layout Standard
Test result repository with user interface where test results are stored.
\end_layout

\begin_layout Standard
Continouous integration server which triggers events and runs automatic
 builds.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Standard
Main motivation I had for this thesis was my wish to learn more about linux
 kernel internals.
 I have used linux from year 1997 but when it have come to writing kernel
 module or to fix problems with kernel compilation.
 Moreover ZlomekFS seemed to be interesting filesystem for which I could
 find usage.
 
\end_layout

\begin_layout Standard
I was interested in quality assurance too.
 Methods how to secure that program will 
\emph on
just work
\emph default
 and programs that 
\emph on
just works
\emph default
 were my enthusiasm long before I started to write this thesis.
 
\end_layout

\begin_layout Standard
With this is related testing and 
\emph on
extreme programming 
\emph default
methods such as test driven development and continuous integration.
 This thesis have offered chance to apply these principes on non-trivial
 project.
\end_layout

\begin_layout Section
Goals
\end_layout

\begin_layout Standard
Extend the existing zlomekFS implementation by introducing a regression
 testing framework.
 The framework should be capable of submitting both predefined and random
 workload to the filesystem and, either by comparing the results with the
 same operations performed over another filesystem, or by some other appropriate
 means, identify filesystem errors.
 The identification of an error should contain both a minimal sequence of
 steps necessary to reproduce the error, and the debugging protocol excerpt
 relevant to the error.
 The framework should include support for generating the debugging protocol
 and changing the network conditions.
\end_layout

\begin_layout Standard
Make all the developer documentation an integral part of the zlomekFS project
 using appropriate tools such as DoxyGen.
\end_layout

\begin_layout Section
Structure of the Thesis
\end_layout

\begin_layout Standard
second - what goes on, current practices
\end_layout

\begin_layout Standard
third - what we use
\end_layout

\begin_layout Standard
fourth - how we use it
\end_layout

\begin_layout Standard
fifth - how it have crashed
\end_layout

\begin_layout Standard
apendix - removed due to appendicitis
\end_layout

\begin_layout Chapter
Filesystem testing
\end_layout

\begin_layout Section
Test types
\end_layout

\begin_layout Standard
Filesystem can be seen as many things and thus it can be tested from at
 least the same number points of view.
 
\end_layout

\begin_layout Subsection
Specification testing
\end_layout

\begin_layout Standard
We could look on filesystem as on specification of way how to store data
 and associated metedata on storage media.
 In this case we can ask if the structures are sufficient for accessing
 stored data, if the specfication covers all eventual operations that should
 be availible and if the transistions are sane.
 Specification testing is done only once at the begining.
\end_layout

\begin_layout Subsection
Api conformity
\end_layout

\begin_layout Standard
Some filesystems don't focus on the way how to store data on media but how
 to make them accessible.
 Well known group of such filesystems are network filesystems.
 They suppose that some other filesystem do the storage and they specify
 only the way how data will be accessible remotely and put some restrictions
 on the filesystem behaviour.
 In this case we test the particular implementations if they are conform
 to the specification.
 stabilni iface / protokol
\end_layout

\begin_layout Subsection
Functional testing
\end_layout

\begin_layout Standard
Filesystems have many things in common with normal pieces of code such as
 server or desktop applications.
 But in the means of tesing there is big problem in simulating normal enviroment
 for filesystems.
 This is caused by their low level nature and could be one of key reasons
 why most of the test suites are designed as black box testing.
\end_layout

\begin_layout Standard
is the one we will be doing.
\end_layout

\begin_layout Standard
The most desired feature on testing framework is ease of use tightly coupled
 with automation.
 To achieve this, the tests have to be written in understandable format,
 close to the tested code.
 By the meaning of regression testing, they have to be runned automatically,
 in scheduled periods (defined by amouth of time or changes), the results
 must be collected and presented in readable format somewhere.
\end_layout

\begin_layout Standard
For tracing the code execution, there may be some tracing tools and logging
 tools.
 They have to have minimal footprint and collect as much information as
 possible.
 Their output must be formatted in way compatible with the automation framework
 and with the presentation tool too, if possible.
\end_layout

\begin_layout Standard
The output of tests could be accompanied with some state information from
 the time of failure.
 This can be achieved by using some snapshoting tool which may or may not
 support resuming.
 
\end_layout

\begin_layout Standard
For filesystem testing, it is hard to find good testing patterns, which
 will cover all cases, which can occur.
 So it is good idea to have some random workload generator, which can randomly
 exercise the filesystem.
 The problem with this approach is, that outputs of such testing tends to
 be very big and only a small portion of them is related to the occured
 error.
 To allow random testing and avoid the unwanted side efects, some pruning
 algorithm has to be used.
 The reruns of tests may use the snapshots, if the method used for snapshoting
 make the resume possible.
\end_layout

\begin_layout Standard
As the ZloFS is multi-threaded, distributed filesystem, the suite should
 have some support or at least extensibility to allow control or simulation
 of distributed enviroment.
\end_layout

\begin_layout Subsection
Benchmarking
\end_layout

\begin_layout Standard
Are tests which should answer the question 
\begin_inset Quotes eld
\end_inset

how long it will take
\begin_inset Quotes erd
\end_inset

 for every operation we could do with filesystem.
 They measure the performance of specific implementation in conjunction
 with given setup assuming the implementation is sane and doesn't do any
 invalid shortcuts.
 Their goal is to compare more implementations or filesystems.
 This thesis won't consider this type of tests, because there is only one
 implementation of ZFS.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Test format
\end_layout

\begin_layout Standard
When tests are expected to be executed manually, then the format could vary.
 On the other hand, when they have to be executed automatically, then for
 every format there must be support in all components of the test suite.
 Because of this there is tendency to minimize number of formats.
 
\end_layout

\begin_layout Standard
The basic choice is to write tests in native language of the application.
 Sometimes there is support for inlining tests to normal code with some
 flags saying 
\begin_inset Quotes eld
\end_inset

this is test code, it should be runned when testing
\begin_inset Quotes erd
\end_inset

.
 This allow tests as close to code as possible.
 It is ideal for short tests of functionality of separated parts (objects,
 libraries, etc).
 
\end_layout

\begin_layout Standard
For automated testing are often used scripting languages to write either
 control logic or whole thing including tests.
 Scripting languages are ideal for the logic because of their flexibility.
 The reason for writing tests in the same languate goo is that it could
 be easier integrated in that way.
\end_layout

\begin_layout Standard
Another possibility is to have tests in some proper format.
 This offer possibility of having the format very suitable for the needs
 of particular software, but this bring disadvantage of having to change
 the format every time a lag is found in specification or a new requirement
 is found.
\end_layout

\begin_layout Standard
Some testing tools uses configuration (tests) in xml or xml with embedded
 code.
 Main reason for using xml is option of using external tools for editing
 or xml-based transformation.
 On other hand, xml is very unsuitable format for hand written code and
 the DTD of configuration is often hard to understand too.
\end_layout

\begin_layout Standard
For component based systems is often used model checking or behaviour protocols.
 For this approach, there is some meta-language for defining actions and
 requirements of interfaces and some logic algebra to define states and
 conditions which must hold.
 It is usefull for checking the design of whole application, but there is
 speed issues when using behaviour protocols for checking larger or complex
 systems.
\end_layout

\begin_layout Section
Unit based testing frameworks
\end_layout

\begin_layout Standard
Unit testing is based on Kent Beck's testing pattern 
\begin_inset LatexCommand cite
key "Simple_Smalltalk_Testing"

\end_inset

.
\end_layout

\begin_layout Standard
Common principes of unit testing are very simple:
\newline

\end_layout

\begin_layout Standard
Every 
\series bold
test case
\series default
 is executed separately, 
\emph on
test case
\emph default
 have common interface (in object based languages presented as common super
 class).
 The run should be independent on other 
\emph on
test cases
\emph default
.
\end_layout

\begin_layout Standard

\emph on
Test case
\emph default
 may have 
\series bold
fixtures
\series default
 - methods to set up environment before test and clean up after test.
 These methods are very often called 
\emph on
setup
\emph default
 and 
\emph on
teardown
\emph default
.
 
\emph on
Teardown
\emph default
 method is executed regardless of result of test.
\end_layout

\begin_layout Standard
Expected problem in test is called 
\series bold
failure
\series default
, non anticipated problem is called 
\series bold
error.
\end_layout

\begin_layout Standard
There is 
\series bold
common method of testing
\series default
 if expectations hold.
 In smalltalk by using 
\emph on
should
\emph default
 and 
\emph on
shouldnt
\emph default
 blocks, in 
\begin_inset Quotes eld
\end_inset

modern
\begin_inset Quotes erd
\end_inset

 languages by using 
\emph on
asserts
\emph default
.
 When expectation doesn't hold it is called 
\emph on
failure
\emph default
.
 
\emph on
Errors
\emph default
 are mostly represented by 
\emph on
exceptions
\emph default
.
\end_layout

\begin_layout Standard

\series bold
Result
\series default
 of test is a 
\emph on
result
\emph default
 object.
\end_layout

\begin_layout Standard

\emph on
Test cases
\emph default
 are agreagated to 
\series bold
test suites
\series default
 that can be aggregated too.
 
\end_layout

\begin_layout Standard
All 
\emph on
test cases 
\emph default
in 
\emph on
test suite
\emph default
 are 
\series bold
run recursivelly
\series default
 by calling 
\emph on
run 
\emph default
on root 
\emph on
test suite
\emph default
.
 Returned value is aggregated 
\emph on
Result
\emph default
 object.
\end_layout

\begin_layout Standard
Unit testing should be 
\series bold
automated
\series default
, independent on human interaction.
\end_layout

\begin_layout Standard
Other features:
\newline

\end_layout

\begin_layout Standard
Many unit testing frameworks offer more elaborated tests structuring and
 state handling (
\emph on
fixtures
\emph default
).
 Very often tests can be aggregated to classes with common setup and teardown
 methods that are run before and after every test.
 
\end_layout

\begin_layout Standard
Moreover there can be additional 
\emph on
fixture levels
\emph default
 for all code units (depending on programing language these can be 
\emph on
class level fixtures
\emph default
, 
\emph on
module level fixtures
\emph default
, 
\emph on
package level fixtures
\emph default
, etc.).
 
\emph on
Setup_
\emph default
 code is run before entering particular block and 
\emph on
teardown_
\emph default
 code is run after leaving particular block of tests (for example setup_class
 is run before running tests in class and teardown_class is run after all
 tests have run.
 Around every single test may be setup_method and teardown_method fixtures).
 Note that this could break the independency requirement.
\end_layout

\begin_layout Standard
Best practices:
\newline

\end_layout

\begin_layout Standard
Unit testing is mostly used for
\emph on
 testing 
\emph default
s
\emph on
mall pieces of code 
\emph default
and thus use cases are mostly very fast and simple.
\end_layout

\begin_layout Standard
Unit testing is very often used to watch for regressions so all tests should
 be executed periodically by some automation tool.
\end_layout

\begin_layout Standard
There should be 100% code coverage done by unit tests.
 Every function (method) shoud have at least one test case, class should
 have test suite as counterpart.
 
\end_layout

\begin_layout Standard
Implementations:
\newline

\end_layout

\begin_layout Standard
There is at least one unit testing framework for every programming language
 (see 
\begin_inset LatexCommand cite
key "xUnit"

\end_inset

 for short list).
 We will focus mainly to these which are C or Python based.
\end_layout

\begin_layout Standard

\series bold
JUnit
\series default
 
\begin_inset LatexCommand cite
key "JUnit"

\end_inset

 is unit testing for java.
 This framework is interesting just by it's author: 
\emph on
Kent Beck
\emph default
, guru of unit testing.
 Have standard features as test level fixtures, assert methods and aggregation.
 In last version (JUnit 4) there were added class level fixtures, timeouts
 for tests, expect exception annotation and requirement of inheriting from
 TestCase was removed.
 It is not part of standard distribution.
\end_layout

\begin_layout Standard
Python has 
\series bold
Unittest 
\begin_inset LatexCommand cite
key "unittest"

\end_inset


\series default
 as it's standard (called 
\emph on
PyUnit
\emph default
 
\begin_inset LatexCommand cite
key "PyUnit"

\end_inset

 before integration to python standard distribution).
 The api is strongly object oriented, tests must inherit from TestCase class,
 override specific methods and test with defined methods of TestCase.
 Doesn't offer more levels of fixtures.
 It is very pure reimplemenatation of Kent Beck's original smalltalk framework.
\end_layout

\begin_layout Standard

\series bold
Py.test 
\begin_inset LatexCommand cite
key "PyTest"

\end_inset


\series default
 is alternative python unit testing framework.
 It is part of 
\emph on
py.lib
\emph default
 library 
\begin_inset LatexCommand cite
key "PyLib"

\end_inset

, has fixtures support on all levels, doesn't need to inherit from superclass
 but has fixed naming convention instead.
 Use standard python assert clause to test for failures, handle exceptions
 as errors.
 Moreover, py.test has automated find-run-collect tool for searching for
 tests in directory trees.
 Test classes can be marked as conditionally 
\emph on
disabled
\emph default
 depending on generic boolean expressions.
 This library has support for generator methods which allows to yield 
\begin_inset Quotes eld
\end_inset

more
\begin_inset Quotes erd
\end_inset

 tests easily.
 Py.test most interesting feature is ease of use.
 It is possible to just write function with 
\begin_inset Quotes eld
\end_inset

test
\begin_inset Quotes erd
\end_inset

 in name and py.test will collect it, run and if there is failure or error,
 the output and backtrace will be printed in readable format.
 Py.test can also take big advantage from py.lib which offers distributed
 execution through py.execnet etc.
 Whole py.lib is written to be easy to use but in current implementation
 with trade off configurability.
 Note should be taken, that py.lib was developed as grant project and after
 grant expiration there were little of improvement in project.
\end_layout

\begin_layout Standard
Another unit testing framework for python is 
\series bold
Nose 
\begin_inset LatexCommand cite
key "Nose"

\end_inset


\series default
.
 Offers backward compatibility to standard 
\emph on
unittest
\emph default
, some compatibility with 
\emph on
py.test
\emph default
 library and try to mimic 
\emph on
py.test
\emph default
 without 
\begin_inset Quotes eld
\end_inset

magic
\begin_inset Quotes erd
\end_inset

.
 Nose provide all features of unittest, moreover it implements py.test's
 all level fixtures, tests doesn't need to inherit from superclass, has
 automated find-run-collect tool a use generators.
 In addition, Nose is very configurable, it has inbuild support for changing
 naming conventions, tests can have flags and it is possible to define expressio
ns which tests should be run according to flags.
 Nose has extensible api with plugin support.
 There are for example plugins for profiling, doctest, code coverage, etc.
 
\end_layout

\begin_layout Standard
Curiosity among unit testing frameworks is 
\series bold
MinUnit
\series default
 
\begin_inset LatexCommand cite
key "MinUnit"

\end_inset

, which is C based and consist only from three lines of code (two macros
 and one deffinition).
 Doesn't offer much, just assert - print message block.
\end_layout

\begin_layout Standard

\series bold
CUnit for Dr.Ando
\series default
 
\begin_inset LatexCommand cite
key "CUnitForAndo"

\end_inset

claims to be easy to use C based unit testing framework inspirated by 
\emph on
cppunit-x 
\emph default
(Interesting piece of code documented in Japanese).
 In fact it is just another framework which lacks fixtures and offer just
 test counting beyond 
\emph on
MinUnit.
\end_layout

\begin_layout Standard

\series bold
Simple C++ Testing framework
\series default
 
\begin_inset LatexCommand cite
key "simplectest"

\end_inset

 is written whole as macros and have somehow weird syntax.
 Offers basic assertions and testSuites.
 There is no need to write main listing all tests but this is achieved by
 wrapping all tests to macros START_TESTS and END_TESTS.
 So tests must be written in one big chunk.
 Again, tests files must be compiled and runned by hand.
 Runs equally in pure C and C++ environment.
\end_layout

\begin_layout Standard

\series bold
CxxTest
\series default
 
\begin_inset LatexCommand cite
key "CxxTest"

\end_inset

 is C++ based and all tests have to be wrapped to test suite Classes.
 This framework has assertions, fixtures and handle exceptions.
 Automated collection is done by python script (but simplified C++ gramatic
 is used).
 May have problems when linking with pure C based code.
 CxxTest have support for mocking global functions but this support works
 on base of calling functions in separate namespace, so it is not pure mock
 and code have to be modified to use mocked functions.
\end_layout

\begin_layout Standard

\series bold
CppTest 
\series default

\begin_inset LatexCommand cite
key "CppTest"

\end_inset

 is another C++ based unit test framework.
 Has basic features such as assertions, fixtures and test suites.
 Beyond this, CppTest is capable of handling and formating output and offers
 api for writing output formatters (TextOutput, CompilerOutput and HtmlOutput
 formatters implemented).
 As for CxxTest, pure C sources must be modified (add extern C {} block)
 to run under CppTest.
\end_layout

\begin_layout Standard

\series bold
CUnit
\series default
 
\begin_inset LatexCommand cite
key "CUnit"

\end_inset

 is C based still C++ compatible supports assertions, suites, test counting,
 has global registry, more user interfaces (for running tests), but no automatic
 collection and output handling.
\end_layout

\begin_layout Standard

\series bold
GUnit 
\series default

\begin_inset LatexCommand cite
key "gunit"

\end_inset

 is another unit testing framework.
 Uses GTK+ libraries (for almost anything).
 Supports assertions, suites and fixtures, has gnome and hildon (embedded)
 gui and dedicated logging facility.
 Doesn't offer discovery, however compiles suites as dynamically loadable
 libraries.
\end_layout

\begin_layout Standard

\series bold
RCUnit
\series default
 
\begin_inset LatexCommand cite
key "RCUNIT"

\end_inset

 supports assertions, suites (called modules), fixtures, has own logging
 facility, tests can be disabled.
 RCUnit has defined interface for writing output handlers, html and plain
 text handlers are implemented.
\end_layout

\begin_layout Standard

\series bold
Cutee
\series default
 
\begin_inset LatexCommand cite
key "cutee"

\end_inset

 tends to be as simple as possible.
 Thus supports only assertions, no fixtures or suites.
 Tests are collected automatically yet files with tests must be listed in
 Makefile.
\end_layout

\begin_layout Standard

\series bold
Check
\series default
 
\begin_inset LatexCommand cite
key "Check"

\end_inset

 provides assertions, suites and simple fixtures.
 Forks every test in separate process, can handle timeouts, output can be
 printed in plaintext or xml.
 Has no build or collect helpers thus adding test is very annoying.
\end_layout

\begin_layout Standard

\series bold
CuTest
\series default
 
\begin_inset LatexCommand cite
key "Cutest"

\end_inset

 from basic features provides assertions and suites.
 Has scripted tool for executable generation.
\end_layout

\begin_layout Section
Logging, tracing
\begin_inset LatexCommand label
name "sub:Logging,-tracing"

\end_inset


\end_layout

\begin_layout Subsection
Models
\end_layout

\begin_layout Standard
When an error is detected in software, developer needs to have as much informati
on about the failure as possible.
 What occured is nice to know but in most cases useless without without
 more details about the run.
 Therefore developers use logging and tracing to get some useful information
 about the particular run.
\end_layout

\begin_layout Standard
Tracing we mean storing information about call sequence in the program,
 by logging we mean saving information about data changes or notes about
 states of system inserted by developer.
 In most cases this features are provided by one tool.
\end_layout

\begin_layout Standard
The simpliest logging tool used is insertion of 
\series bold
direct message prints
\series default
.
 Printing may provide the information needed, but it suffer by not having
 centralized control of what has to be printed.
 This leads to excessive logging, in which is hard to find a usefull information
, and if we want to avoid this it force us to changing the code on many
 places.
\end_layout

\begin_layout Standard
So the next logical step is to send logging messages (accompanied by importance
 level) to some 
\series bold
centralized facility
\series default
.
 The importance levels are in most cases directly given in advance.
 Providing this it is possible to change the amount of information centraly
 and even redirect the messages to distinct places.
\end_layout

\begin_layout Standard
When simple distinguishment by importance is not enough then more advanced
 logging facilities comes with 
\series bold
tagging of messages
\series default
.
 Tags could be flat or of arbitrary structure.
 This allow better filtering of messages of special types.
 
\end_layout

\begin_layout Standard
Other approach to logging is to have more than one logger.
 In this case the tool has frequently 
\series bold
producer - consumer
\series default
 based architecture and loggers are organized to dynamically created hierarchy.
 This ease goal of having different output locations for different types
 of messages.
 On the other hand, the architecture is not so easy to understand for anybody
 who might contribute to the code.
 Moreover, with more people participating on development, it is nearly impossibl
e to keep the hierarchy of producers and consumers used in application sane.
 
\end_layout

\begin_layout Standard
The last approach to logging and tracing is called 
\series bold

\begin_inset Quotes eld
\end_inset

aspect oriented programing
\series default

\begin_inset Quotes erd
\end_inset

.
 In this case the logging is not present in code itself but it is separated
 as independent concern to aspect - logical definition what and where has
 to be logged.
 
\end_layout

\begin_layout Subsection
Pitfalls
\end_layout

\begin_layout Standard
Even if a adequate logging facility is used to debug the software, there
 can arise problems when the facility is used under some automated stress
 testing.
 The amouth of output logs will eventually gets too big for storage capacity
 or at least for the potential reader to deal with.
 So the automation tool must be able to communicate with the logging facility
 and in some way dynamically change the amouth of output according to needs.
 This must be tuned so the biggest possible portion of unrelated logs is
 thrown away but the crucial information for debugging is preserved for
 failure as the failure could be hard to repeat.
\end_layout

\begin_layout Standard
There is one more reason that may be considered for muting logging output.
 The reason is that logging could slow the application down.
 To check how much logging slows down a ordinary application, some measurements
 were done.
 
\end_layout

\begin_layout Standard
For testing was used real application - session server from the SUCKS 
\begin_inset LatexCommand cite
key "SUCKS"

\end_inset

project.
 The session server was threaded and accessible by network.
 Logging facility was simple centralized logger with pre-definet log levels.
 Logger was alternated so it measures time spent by logging.
 Tests consisted of pre-defined workload, output was time spent by whole
 application, time spent in logging and characters printed.
 Test cycle was composet of one run of all tests for every log level and
 log target.
 After finishing the cycle starts again.
 This had been running for approximately thirty hours on two platforms:
\end_layout

\begin_layout Enumerate
intel centrino with core2duo cpu set to static frequency of 1Ghz with 2GB
 memory (most unused) running kernel 2.6.20.1 x86_64.
 
\end_layout

\begin_layout Enumerate
motorola ppc MPC8241 (177 bogomips) with 128MB memory running kernel 2.4.32
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename logSums.png
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Logging load
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Both platforms behaved equally, the only difference was in speed (we must
 consider, that motorola was connected by network and all console prints
 must went through ssh).
 From results we can see that all logging targets had the same footprint
 and the only 
\begin_inset Quotes eld
\end_inset

slow
\begin_inset Quotes erd
\end_inset

 target was console write.
 For non-blocking targets, the slowdown was in hundereths of per cent for
 all log levels and the difference between no logging and full logging was
 only one hundereth of per cent.
\end_layout

\begin_layout Standard
So when we don't need to read the output of application online we can log
 everything, having as target some circular buffer which can be flushed
 to file only when error occured.
 Filtering can be done afterwards by user.
 Another finding is that the logging footprint is in half made of checks
 if something has to be logged or not and to minimalize slowdown, logging
 must be entirely deleted in compile time.
 Problem with this is that it makes changes to code, thus to binary image
 too and this changes can lead to different behavior of erroneous code,
 so the bug could be unreproducible with different logging level.
\end_layout

\begin_layout Standard
Other problem which can arise with logging is that logging can act as synchroniz
ation primitive which could prevent some collisions to appear.
 Problem with synchronization can be solved by design of logging facility.
 The logger must be designed in way that create separated resources for
 every concurrently running entity in advance and then the only effect done
 by the logger is slowdown of creation of new 
\begin_inset Quotes eld
\end_inset

threads
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section
Presentation layer
\begin_inset LatexCommand label
name "sub:Presentation-layer"

\end_inset


\end_layout

\begin_layout Standard
Usual test run produce outputs of many types, begining with standart outputs,
 going on with filesystem changes and debug logs and even including state
 snapshots, core dumps etc.
 These are data of very different types.
 The goal is to present them to user in usable way with structure that can
 be easilly understood and through ways which are accessible from as much
 enviroments as possible.
\end_layout

\begin_layout Subsubsection
Raw data
\end_layout

\begin_layout Standard
The easiest way to present results is to leave them as they are produced
 by application and test suite.
 When this approach is used the raw data are often made vaailable for downloadin
g through simple protocol such as FTP or some remote access.
 Raw data hold always full information, don't suffer by ano losses from
 transformations.
 On the other hand raw data are often platform dependent and may have to
 be interpreted on the system that produced them.
 The data should be in standart format to allow readability by external
 tools.
\end_layout

\begin_layout Subsection
Web interface
\end_layout

\begin_layout Standard
Dynamic web pages are nowadays very used way of presentation as they are
 relatively easy to write.
 Web pages have big advantage in accessibility - nearly every computer have
 web prowser installed and people are used to get information through these.
 On the other hand web pages can hardly display some debug outputs such
 as core dumps and other binary data.
 In this case data should be downloadable for reading through external tools.
 Interaction with web is little bit slower than with local application and
 user comfort is also worst.
\end_layout

\begin_layout Subsection
Special application
\end_layout

\begin_layout Standard
Even raw data must be interpreted by application to be presented in readable
 form.
 When there aren't appropriate general tools, they should be written as
 part of test suite.
 The fact that they must be written is one big disadvantage by itself.
 Full featured interpreter of debug data with presentation layer may consist
 of the same amouth of work as test suite itself.
 Moreover requirements and dependencies of such application could be non-trivial
 and platform independency is hardly to achieve with this approach.
 The big pro of special application is that as written specially for a suite
 it should fits very well the needs.
\end_layout

\begin_layout Section
Random workload generation
\end_layout

\begin_layout Standard
must be generated from small test units (meta tests, atoms).
 Depending on subject tested atoms are either defined by tradition (basic
 operations that can be made on subject tested) or small well defined tests.
 It is sometimes wanted to group some atoms to create new (bigger) atom.
 In ideal case run of a beta test doesn't change state of subject tested.
 But this type of atoms can test only stateless sysatems and operations
 which are less errorneous and not so big candidates for regresion testing
 as statefull systems are.
 For statefull systems (and metat tests) there should be method how to define
 and check states and legal transistions.
 Simple method to allow this is to give to tester some way to define pre-
 and post- run hooks that can initialize state, check transistion and posibly
 do cleanup after test.
 While approach with pre and post run hooks is simple yet powerfull, there
 is one issue connected to it.
 In this system tester can use statefull tests but in trade of possible
 waste of resources.
 When test expected some state different that in which system is, it must
 either made a state change (non trivial operation out of test scope) or
 silently pass without testing and let the system run other test.
 More spohisticated system for resolving state-fullness is to give tester
 tool to define allowet transistions between tests.
 Transistions are often given by graph (edges can be allowed transistions
 or vice versa).
 
\end_layout

\begin_layout Standard
Sometimes it may be desirable to give some preferences (what should be tested).
 For random workload this means either binary switching tests on and off
 or giving preferences in percentage.
 When state-fullnes is not solved or solved by pre- and post- hooks, precentage
 is connected to tests.
 When transistions are used, precentage can be either for tests (implicit
 edges) or for transistions.
\end_layout

\begin_layout Standard
Length of continuous random workload can be simple defined as:
\end_layout

\begin_layout Itemize
number of tests (min, max, mean)
\end_layout

\begin_layout Itemize
time (resources) used
\end_layout

\begin_layout Itemize
by transistions to end point
\end_layout

\begin_layout Standard
When user preferences are given system itself is oten simple automata running
 on satatefull graph.
\end_layout

\begin_layout Section
Pruning output
\end_layout

\begin_layout Standard
When long test (or random test) fails we don't know which step has caused
 the failure, so we need test outputs (debugging info) to locate the bug.
 On the other hand output from long and random tests can be huge and most
 of it may be useless.
 The goal of pruning output is to provide enough information to find the
 bug and at the same time hide useless balast.
 Basically we can divide outputs to developer written log messages, system
 state snapshots (memory dums, FS state, etc).
 The second type is more resources consuming, but easy searchable by hand.
 So as storage capacity is cheap, we can simply leave all snapshots or limit
 space used by constant and delete old snapshots.
 As for logs the problem was described in chapter !!! logging !!!.
 When logging doesn't slow application down and doesn't change behaviour,
 the best approach is to log all, store all (or last X) and provide tool
 for filtering and searching logs.
 With this approach we can be sure that no crucial information was lost
 by heuristic prunning.
 In special cases lice low resource platforms (without storage, extremly
 slow, etc) where we can't afford wasting, some heuristic must be used.
 For system state this can be last state before recognizing failure and
 state after.
 For logs there can be more approaches which can be divided to 
\end_layout

\begin_layout Itemize
on-time prunning - test suite changes log level of application according
 to probability of failure.
 The question is, how it should know.
\end_layout

\begin_layout Itemize
afterwards - log level is constant for test run, logs are stored to cyclic
 buffer.
 When failure occurs, test suite will trim the buffer to store just usefull
 information.
\end_layout

\begin_layout Itemize
re-run - tests are runned with logging on minimal level.
 When failure occur, test suite will rerun the test with more logging 
\begin_inset Quotes eld
\end_inset

around
\begin_inset Quotes erd
\end_inset

 the failure, possibly skiping some parts of test (as for random generated
 workload).
\end_layout

\begin_layout Section
Checkpointing
\begin_inset LatexCommand label
name "sub:Checkpointing"

\end_inset


\end_layout

\begin_layout Standard
As some failures are hardly reproducible, developer wants as much information
 about the faulty run as possible.
 Sometimes logs are not sufficient and state of application in time of failure
 is needed.
 That's why some snapshoting support might be usefull.
 
\end_layout

\begin_layout Standard
Moreover, as the runs to failure could be very long, the test suite may
 try to repeat just short parts of them or skip some steps to find the shortest
 possible run to bring about the bug.
 For reruns is best, when the second run has the same start conditions.
 The snapshots (checkopoints) can help with it by resuming from stored state
 (if possible).
\end_layout

\begin_layout Standard
There are many projects trying to create full featured checkpoint / resume
 support for applications.
 They can be divided in two groups: userspace only tools and kernel-based
 tools.
 The main problem among them is, that none of them have full support for
 every resource an application could use.
 The most frequently missing features are suspend / resume support for:
 networking, devices, threads, signal handlers, shm, shared objects.
 Some of them (BCLR 
\begin_inset LatexCommand cite
key "BLCR"

\end_inset

, CryptoPID 
\begin_inset LatexCommand cite
key "cryptoPID"

\end_inset

, Chpox 
\begin_inset LatexCommand cite
key "chpox"

\end_inset

) seems to have everything needed, but for the price of many constraints
 and dependencies.
 
\end_layout

\begin_layout Standard
Other possibility, which solve the matter of sandboxing too is to use some
 virtualization tool and run application (not necessarilly test suite) inside
 virtual machine.
 Nowadays there is many virtualization tools with support for snapshoting
 (for ex.
 openVZ 
\begin_inset LatexCommand cite
key "openVZ"

\end_inset

, Vmware 
\begin_inset LatexCommand cite
key "Vmware"

\end_inset

, Xen 
\begin_inset LatexCommand cite
key "Xen"

\end_inset

, Qemu 
\begin_inset LatexCommand cite
key "Qemu"

\end_inset

).
 However, working with virtualization is fairly complicated and we can't
 test hardware dependent issues on them.
\end_layout

\begin_layout Standard
The last and easiest possibility is to use just snapshoting without resume
 and save the snapshots in some easy to read format.
 For this we can use for example GDB gcore 
\begin_inset LatexCommand cite
key "gcore"

\end_inset

 command (which creates gdb core dumps) to pause and snapshot the application.
\end_layout

\begin_layout Section
Continuous integration
\end_layout

\begin_layout Standard
Existence of tests is not enough to provide stable developement cyclus.
 For stability of project it is vital to test it for errors (run tests)
 as often as possible, preferably after each change (commit).
 The approach when changes are often merged into 
\emph on
mainline
\emph default
 is called 
\series bold
Continuous integration
\series default
 (good overview of this method is in 
\begin_inset LatexCommand cite
key "Continuous_integration"

\end_inset

).
 To achieve regular tests it is convenient to use some tool (server) which
 automates the process.
 There is no need to develop own system as there are many proprietal solution
 and even more opensource solutions.
 It is interesting how many organizations deploy their own systems (for
 example Mozilla Foundation uses Tinderbox 
\begin_inset LatexCommand cite
key "Tinderbox"

\end_inset

, Redhat has Frysk 
\begin_inset LatexCommand cite
key "Frysk"

\end_inset

, ThoughWorks has 
\begin_inset LatexCommand cite
key "Cruise_Control"

\end_inset

.
 Apache foundation even two projects - Continuum 
\begin_inset LatexCommand cite
key "Continuum"

\end_inset

 and Gump 
\begin_inset LatexCommand cite
key "Gump"

\end_inset

 - that is only from opensourced projects).
 It is obvious why it is this way: core features of continuous integration
 server are easy to write and after some time when more features are needed,
 project may be bound to integration server so tightly that it is nearly
 impossible to switch to another system.
\end_layout

\begin_layout Subsection
Automation
\end_layout

\begin_layout Standard
Best approach to achieve stable build and check cycle is to automate it.
 Some projects use manually driven systems but there are hazard of human
 failure (developer could omit tests, forgot about them or ignore them at
 all).
\end_layout

\begin_layout Standard
Commonly are used two approaches to achieve automated build and check:
\end_layout

\begin_layout Standard
First is to use some post 
\series bold
commit hooks
\series default
 (we assume that version control system is used) which executes tests or
 launch separate process to execute them on background.
 This approach can ensure that no wrong code gets into repository - commit
 that won't pass all tests can be rejected.
 Running all tests can be relatively long lasting task and therefore environment
 is rarely set to execute all tests before commit and more commonly commit
 is delayed only after vital tests pass.
 More in-deep checking tests are executed afterwards in stand-alone process.
 Implementation is often bound to one version control system.
\end_layout

\begin_layout Standard
Other option is don't check validity in commit hooks but use 
\series bold
independent service
\series default
 which monitors state of repository and runs tests either for every change
 (commit) or on regular basis (night builds).
 Benefits of this approach are that it doesn't slow down commits and tools
 using this approach have frequently more features and better configurability.
 These solutions are generally independent on version control system (support
 for distinct version control systems are provided by plugins) but sometimes
 use hooks to get alert upon change.
\end_layout

\begin_layout Standard
Often this combination is used:
\end_layout

\begin_layout Itemize
pre-commit hooks are used to enforce repository rules and coding conventions
\end_layout

\begin_layout Itemize
separate service builds project (upon commit or nightly) and executes all
 tests checking if change breaks something
\end_layout

\begin_layout Standard
Because one of steps should be building the source there sould be support
 for build system used by project.
 Again, many tools are plugin based and have plugins for most common build
 systems used.
 Particular set depends on aim of tool.
\end_layout

\begin_layout Standard
Pure commit driven environment when commit is delayed after all tests had
 passed doesn't need presentation layer at all, there is just the error
 message send to commiter.
 But as this variant is rare, nearly all automation systems have 
\series bold
presentation
\series default
 layer.
 The complexity vary from simple text (html) file statically served by web
 server to rich database backed gui.
 Standard tools offer html overview and detail pages, tools bound to specific
 environment usually provide gui for that environment.
 Very often there are email or instant messaging notifiers too.
 If there are other output than test count and results, it tends to be plain
 text, sometimes there are output format readable by applications.
\end_layout

\begin_layout Subsection
Distributed testing
\begin_inset LatexCommand label
name "sub:Distributed-testing"

\end_inset


\end_layout

\begin_layout Standard
Testing doesn't need to be run on the same machine as control service.
 When tests run elsewhere we call it distributed testing.
 In some cases it is possible to run many separate machines each running
 separate build and check service achieving nearly the same result.
 But managing such system is huge overhead and collecting results is non
 trivial too.
\end_layout

\begin_layout Standard
There can be many reasons for distributing:
\newline

\end_layout

\begin_layout Standard
It is crucial do distribute testing for 
\series bold
multiplatform applications
\series default
.
 Bad code can behave badly only on one of target platforms and therefore
 testing on only one platform can left errors undiscovered.
 In this case distributed testing is the only way to cover specifics of
 all platforms.
\end_layout

\begin_layout Standard
Some tests or projects could be 
\series bold
dangerous
\series default
 to system itself or the project is part of base system.
 These should run them in separation of production system in some sort of
 sandbox.
 As virtualization is nowadays easy to deploy, the best way (and in case
 of base system parts the only way) to sandbox project tests in virtual
 machine.
 This must be considered as distributed testing too because the comunication
 with virtual machine must be done in the same way as if the virtual machine
 were in other network.
 There are in general less security barriers between the host machine and
 guest machine but it don't affect the connection method itself.
\end_layout

\begin_layout Standard
Another reason for running tests on other machine can be 
\series bold
resource consumption
\series default
.
 As the control system should be visible to wide network (at least the presentat
ion layer) it is frequently run on production server which hosts other applicati
ons too.
 In this case it is not good idea to slow down or even block whole system
 by tests.
 Again tests are given to another machine to execute.
\end_layout

\begin_layout Standard
Sometimes tests takes long 
\series bold
time
\series default
 to complete.
 Then it is convenient to spread tests over more machines each running only
 part of tests.
 By this we achieve shorter build and check cycle.
\end_layout

\begin_layout Standard
Distribution can be acchieved by:
\newline

\end_layout

\begin_layout Standard
Sending commands through remote terminal.
 For example on unix data could be copied to target machine by scp, tests
 executed through ssh and results again retrieved through scp.
 This is the easiest way used in simple cases where no synchronization or
 overview is needed.
 Data in general doesn't need to be delivered through the same way as commands.
 Client can fetch them himself upon test command, or there can be shared
 network storage where control server should put data for tests.
\end_layout

\begin_layout Standard
Most common way to connect control server with machines executing tests
 (sometimes called slaves or bots) is to use remote procedure call.
 As remote procedure call we mean not only RPC but any method that allows
 us to call procedures on remote system.
 There are many rpc tools such as RPC, CORBA, dcom, python twisted, py.execnet,
 etc.
\end_layout

\begin_layout Standard
Older systems tends to use e-mail communication.
 It consists of specially formatted messages sent between master and clients.
 This approach has many drawbacks as security problems, frangibility and
 non-deterministic behaviour.
\end_layout

\begin_layout Standard
Sometimes own methods for communication is used, that mimic remote procedure
 call by sending raw data within special protocol.
\end_layout

\begin_layout Section
Sandboxing
\end_layout

\begin_layout Standard
When tests need more privileges over hosting environment or the tested component
 itself is part of operating system there is big probability that running
 tests can broke anything.
 In this case they must be executed in so called sandbox.
 It is either part of system with restricted access to some resources or
 whole separate system.
 Obviously there must be possibility to restore easilly previous state of
 sandbox after breakage from test.
 
\end_layout

\begin_layout Standard
When choosing sandboxing method to use other requirements must be considered
 too.
 
\end_layout

\begin_layout Standard
As we described in 
\begin_inset LatexCommand prettyref
reference "sub:Logging,-tracing"

\end_inset

, execution logs are crucial to track failure (bug) found by automated testing.
 Therefore it should be possible to get logs (and other data) from sandbox
 at least after failure but prefferably to send them back to master straight
 upon generation.
 This is more logger feature, but to use it the sandbox must allow communication
 with outside.
\end_layout

\begin_layout Standard
When testing is distributed (see 
\begin_inset LatexCommand prettyref
reference "sub:Distributed-testing"

\end_inset

) it should be considered to use the remote machine as sandbox too.
 Again, there should be method to easilly restore state of whole remote
 machine after breakage from test.
 Note that this would be problematic with real (non-virtualized) hosts.
\end_layout

\begin_layout Standard
In 
\begin_inset LatexCommand prettyref
reference "sub:Checkpointing"

\end_inset

 we have analysed problem of providing information about test state to developer.
 If sandbox is represented by full operating system then checkpointing of
 whole sandbox would be in most cases big overhead.
 Still it should be taken into account in some cases.
 One case where sandbox snapshots may be convenient is when test depends
 heavily on system state or changes system state.
 Then without system snapshot some information to track failure may be missing.
 Other case when full snapshots may be generated is when test has caused
 system failure (therefore normal snapshots can't be created).
\end_layout

\begin_layout Section
Filesystem test patterns
\end_layout

\begin_layout Subsection
FSX
\begin_inset LatexCommand label
name "sub:FSX"

\end_inset


\end_layout

\begin_layout Standard
Originally written by Avadis Tevanian, Jr.
 for Apple Computer, Inc.
 and other bsd-style operationg systems.
 There are more versions used but the main part stay the same 
\begin_inset LatexCommand cite
key "FSX"

\end_inset

.
\end_layout

\begin_layout Standard
Test consists of single source file written in C, compilable on most Unix
 based operating systems.
 Test operates on one file, does loop with random operation in every cycle
 - one of read, write, truncate, close and open, map read and map write.
 Memory mapped operations can be disabled.
 Checks in FSX are made by comparison of write buffer and data read, additional
 check of file size is made too.
 Failure report from FSX is dump of operation sequence and buffer dump.
\end_layout

\begin_layout Subsection
LTP
\end_layout

\begin_layout Standard
Linux testing project 
\begin_inset LatexCommand cite
key "LTP"

\end_inset

 is collection of test suites for linux operating system internals.
 The part dedicated to filesystems contains previously mentioned FSX (
\begin_inset LatexCommand prettyref
reference "sub:FSX"

\end_inset

) and own filesystem testing scripts.
 There are both types of tests: predefined loops with random arguments (file
 sizes, etc) and stress tests consisting of random sequences of operations.
 There is vast amouth of operations implemented.
 Log contains arguments to tests.
\end_layout

\begin_layout Subsection
Mongo
\end_layout

\begin_layout Standard
Mongo benchmark 
\begin_inset LatexCommand cite
key "Mongo"

\end_inset

 is test program written in perl, aimed to linux filesystem performance
 and functionality testing (developed by reiserfs team).
 Is very tightly coupled with standard tools and filesystem usage.
 Does everything from mkfs, through mount to clasic operations.
 The version examined was mainly benchmarking tool, there were no checks
 if things goes well, just if they goes.
\end_layout

\begin_layout Subsection
OpenSolaris ZFS / NFSv4 Test Suite
\end_layout

\begin_layout Standard
Very exhaustive test suite for filesystems 
\begin_inset LatexCommand cite
key "OpenSolarisZFS"

\end_inset

.
 There is two sets of tests: one for NFSv4 and one for ZFS, but the techniques
 used in them are the same.
 Just ZFS test suite have extra stress tests.
\end_layout

\begin_layout Standard
System is Makefile driven with default targets, tests are generally shell
 scripts (ksh) with few compiled support programs and tests.
 Testing is deterministic, cleanup is done after set of tests (directory).
 Errors are printed to stderr.
 
\end_layout

\begin_layout Standard
What should be noted is the coverage of these tests, there are tests for
 nearly every operation possible even for zones, acl or redundancy.
 In zfs there are simple stress tests too - predefined loops with configurable
 length.
\end_layout

\begin_layout Chapter
The test suite architecture
\end_layout

\begin_layout Section
Programming language
\end_layout

\begin_layout Standard
Since ZlomekFS tends to be multiplatform and support more operating systems
 (currently only linux is supported) we need language which runs on any
 platform and at least under UNIX-like operating systems.
 For testing the language should be flexible enough but on other hand since
 we will be testing file system, speed must be considered too.
 Last but not least need is that the language sould allow integration with
 existing code.
\end_layout

\begin_layout Standard
Because of this criteria 
\series bold
python 
\series default

\begin_inset LatexCommand cite
key "Python"

\end_inset

 was chosen as main programing language for driving component.
 Since python can integrate with most compiled languages, not all components
 must be written in python.
 Performance critical parts and integration libraties are writen in ZlomekFS
 native language - 
\series bold
C
\series default
.
\end_layout

\begin_layout Section
Used tools
\end_layout

\begin_layout Subsection

\series bold
Testing environment
\end_layout

\begin_layout Standard
For very specific purpose of testing distributed file system we have found
 no existing solution.
 Instead of develop new system it was decided to tweak existing some existing
 tool (if possible) to fit our needs.
 From general purpose testing tools written in python 
\series bold
Nose
\series default
 
\begin_inset LatexCommand cite
key "Nose"

\end_inset

 was found as the most suitable for our needs.
 Moreover every feature that we need and nose doesn't implement can be delivered
 as plugin for nose within modifiing nose core code.
 Nose plugin architecture was found as flexible enough for further extending
 of test suite too.
\end_layout

\begin_layout Subsection
Continuous integration
\end_layout

\begin_layout Standard
When choosing tools for continuous integration, we consider only opensource
 projects with reliable comunity around it.
 Specially deeper investigation were made on Cruise Control 
\begin_inset LatexCommand cite
key "Cruise_Control"

\end_inset

, Continuum 
\begin_inset LatexCommand cite
key "Continuum"

\end_inset

, Gump 
\begin_inset LatexCommand cite
key "Gump"

\end_inset

, Cabie 
\begin_inset LatexCommand cite
key "Cabie"

\end_inset

, Tinderbox 
\begin_inset LatexCommand cite
key "Tinderbox"

\end_inset

, Frysk 
\begin_inset LatexCommand cite
key "Frysk"

\end_inset

and Buildbot 
\begin_inset LatexCommand cite
key "BuildBot"

\end_inset

.
\end_layout

\begin_layout Standard
We use 
\series bold
buildbot
\series default
 
\begin_inset LatexCommand cite
key "BuildBot"

\end_inset

 as continuous integration server.
 
\end_layout

\begin_layout Standard
It was chosen for these reasons:
\end_layout

\begin_layout Itemize
Compatibility with our build system.
 Buildbot can use shell comnmands and python code as build steps.
 It can do output parsing for configure, make and gcc output too.
\end_layout

\begin_layout Itemize
It is small and easy to deploy.
 There is no need to write big xml configuration files to run 
\emph on
hello world
\emph default
, buildbot code is relativelly small and easy to read.
\end_layout

\begin_layout Itemize
Written in python.
 Since whole Buildbot is written in python, we can easilly integrate it
 with other tools used in project (as they are written in python too).
\end_layout

\begin_layout Itemize
Extendable architecture.
 Buildbot parts are written as objects, so it is possible to inherit from
 them and tweak behaviour according our needs.
\end_layout

\begin_layout Itemize
Support for distributed testing.
 As ZlomekFS is intended to run on multiple architectures (and in future
 possibly on multiple operating systems) the support for distributed testing
 is essential.
\end_layout

\begin_layout Itemize
Active development.
 Buildbot is often used and has active comunity which ensures that it will
 be maintained in future too.
\end_layout

\begin_layout Subsection
Web result presentation and result repository
\end_layout

\begin_layout Standard
Test results in buildbot are presented as textual output from commands.
 This is not enough from two reasons: when failure or error is found, the
 textual output may be messy.
 Bigger problem is, that it can't provide enough information and binary
 data can't be provided in this way at all.
\end_layout

\begin_layout Standard
So there was need for another way to represent test results.
 Since test outputs can contain binrary data (snapshots, core dumps, filesystem
 state, etc), the presentation layer should be able to distinguish several
 types of data and present them according type.
 As data and information for test run are related to each other we decided
 to use database driven storage.
 
\end_layout

\begin_layout Standard
The solution which fits our needs best was 
\series bold
Django 
\series default

\begin_inset LatexCommand cite
key "Django"

\end_inset

.
 It is written in python, offers object oriented database abstraction layer,
 web pages generating tools.
 It's configuration format is pure python, so it is easy to integrate it
 with other parts of project.
\end_layout

\begin_layout Subsection
Logging
\end_layout

\begin_layout Standard
We need logger with this features:
\end_layout

\begin_layout Itemize
it can be controlled externally
\end_layout

\begin_layout Itemize
it has simple still full featured interface
\end_layout

\begin_layout Itemize
it has to have implementations in both languages in which is written test
 suite and zfs 
\end_layout

\begin_layout Itemize
the output has to be in parseable and user readable format
\end_layout

\begin_layout Standard
This enforces us to write 
\series bold
new logger
\series default
, which suits best the needs.
 From models, we can't use aspect oriented logging as there is no implementation
 of aspects for both languages (and moreover it will be big requirement
 for developers to use aspects).
 The producer-consumer model seems to be too complicated as there will be
 large and non-homogenous group of developers working on zlomek fs.
\end_layout

\begin_layout Standard
So the logger will be centralized, with some sort of tagging with fast evaluatio
n.
 The output will be redirectable to some sort of shared resource (shm, network
 socket) which can be used and controlled by test suite.
 The format of written log for failure may be preferably readable by some
 GUI or web based reader such as Chainsaw 
\begin_inset LatexCommand cite
key "Chainsaw"

\end_inset

, if not possible, user readable output should be used.
\end_layout

\begin_layout Subsection
C based unit testing
\end_layout

\begin_layout Standard
All existing C based unit testing tools have one of two major problems (or
 both).
 
\end_layout

\begin_layout Itemize
Many tools are very complicated and writing simple test for 
\begin_inset Quotes eld
\end_inset

a + b
\begin_inset Quotes erd
\end_inset

 could take five minutes to do in them.
 
\end_layout

\begin_layout Itemize
No one of C based unit testing tools have automatic test discovery.
 Thus tests must be listed somewhere and collected manually (even in case
 of hierarchies).
 The best that some of them have is heuristic search by grep or other tool
 using non complete C syntax.
\end_layout

\begin_layout Standard
We think about external complicated tools as non-trivial for integration
 to project and writing of simple C based unit testing is trivial, we choose
 to implement our own C based unit testing library.
 Moreover we manage to implement automatic test discovery based on elf binary
 format.
\end_layout

\begin_layout Subsection
Documentation
\end_layout

\begin_layout Standard
For documenting C code 
\series bold
Doxygen
\series default
 
\begin_inset LatexCommand cite
key "Doxygen"

\end_inset

 was chosen.
 Main argument was that ZlomekFS is documented in Doxygen, secondary Doxygen
 is nowadays nearly standard tool for documenting C code.
\end_layout

\begin_layout Standard
For Python code, Doxygen has some support, but the support is problematic,
 needs usage of imput filters such as Doxypy 
\begin_inset LatexCommand cite
key "Doxypy"

\end_inset

 and even then results are not ideal.
 
\end_layout

\begin_layout Standard
There is standard docstring format for python 
\begin_inset LatexCommand cite
key "PEP257"

\end_inset

, but it doesn't support more than plain-text formating.
 
\end_layout

\begin_layout Standard
Another option is to use some non-standard documentation tools for python
 (most of them are listed in PEP256 
\begin_inset LatexCommand cite
key "PEP256"

\end_inset

).
 Their problems are mainly listed in mentioned PEP256.
\end_layout

\begin_layout Standard
Finally, 
\series bold
reStructuredText Docstring Format
\series default
 
\begin_inset LatexCommand cite
key "PEP258,reStructuredText"

\end_inset

 was chosen.
 Main reason was that Nose 
\begin_inset LatexCommand cite
key "Nose"

\end_inset

 uses this format, secondary reStructuredText is easy readable in 
\series bold
Pydoc 
\begin_inset LatexCommand cite
key "Pydoc"

\end_inset


\series default
 output and there is html formating tools too.
\end_layout

\begin_layout Chapter
Implementation details
\end_layout

\begin_layout Section
ZlomekFS changes
\end_layout

\begin_layout Subsection
Logging
\end_layout

\begin_layout Standard
Original message printing system (two levels, hardcoded values) was switched
 to 
\series bold
new logger
\series default
 (
\emph on
Syplog
\emph default
) developed specially for ZlomekFS.
 
\end_layout

\begin_layout Standard
Logger supports eleven 
\series bold
log levels
\series default
.
 Log level is 32bit unsigned integer (typedef), log levels are defined by
 macro constants (from LOG_EMERG to LOG_LOOPS).
 There is conversion function available to convert log levels to user-readable
 strings.
\end_layout

\begin_layout Standard
For concern separation logger distinguish 
\series bold
facilities
\series default
.
 Facilites are disjunct one-bit flags which can be ORed.
 Log message can be labeled as belonging to any number of facilities.
 Again, there is conversion function to convert facilityes to user-readable
 strings.
\end_layout

\begin_layout Standard
Log levels can be used to 
\series bold
filter
\series default
 what types of messages (of which importance) should be recorded and which
 should be discarded.
 Both log level and facility set can be regulated in runtime.
\end_layout

\begin_layout Standard

\series bold
Output
\series default
 from logger can be written to file or shared memory, api is open for extension
 such as socket write.
 Format of output files can be user readable strings or raw memory dumps.
 For all formats and output targets there is both writer and reader support,
 so transformation between formats is trivial.
\end_layout

\begin_layout Standard

\series bold
Settings
\series default
 is read in format of program arguments (array of string with given array
 size).
 Logger ignores unknown options, so direct configuration from command line
 is possible (and currently used).
\end_layout

\begin_layout Standard
For 
\series bold
integration
\series default
 with external driving component (Nose testing environment) there is 
\series bold
D-bus
\series default
 control api.
 Both log level and facility set is adjustable through D-bus.
 For further integration there is full-featured python wrapper for syplog
 generated by swig.
\end_layout

\begin_layout Standard
Log level and facility list can be 
\series bold
extended
\series default
 by listing constants for new log levels and facilities in header files.
 Output formats and targets are defined by static structures holding pointers
 to functions with specified behaviour.
 New formats and targets can be provided by implementing given function
 set and providing description structure.
 For further reference please read doxygen documentation of
\emph on
 Syplog
\emph default
 library.
\end_layout

\begin_layout Subsection
Control component
\end_layout

\begin_layout Standard
The driving component needs to know in which state ZlomekFS daemon is (starting,
 running, terminating).
 To acomodate this need 
\series bold
D-bus
\series default
 listener was added to zfsd.
\end_layout

\begin_layout Standard
The D-bus component of ZlomekFS consists of two parts:
\end_layout

\begin_layout Itemize
D-bus provider - state-full service which manages initialization of D-bus,
 listening loop and termination of D-bus connection.
 Doesn't serve messages.
\end_layout

\begin_layout Itemize
D-bus message handlers.
 Set of functions describing zfsd specifics - naming and signal handlers.
\end_layout

\begin_layout Standard

\series bold
Integration
\series default
 of this two components with zfsd daemon is following: On begining, zfsd
 creates and inicializes D-bus provider handler (structure).
 Then, it registers zfsd D-bus message handlers by calling 
\emph on
dbus_provider_add_listener
\emph default
.
 Currently, the syplog D-bus service is implemented in way compatible with
 zfsd D-bus provider.
 Thus another 
\emph on
dbus_provider_add_listener
\emph default
 is called for syplog service.
 After all needed listeners are registered, zfsd calls 
\emph on
dbus_provider_start
\emph default
.
 This starts new thread which listens for messages and forwards them to
 registered handlers.
 Finally, when zfsd is terminating, 
\emph on
dbus_provider_end 
\emph default
is called.
\end_layout

\begin_layout Standard
For future there are plans for
\series bold
 remote zfsd control
\series default
 mechanism.
 Main intention of it should be to allow user initiated synchronizations,
 mode changes (slow connection, fast connection) etc.
 These should be implemented either as another set of message handlers or
 by extending current message handlers.
\end_layout

\begin_layout Standard
As the test driving component is written in python, there is 
\series bold
python client module
\series default
 for this api too.
 Client module is automatically generated by swig so there should not be
 problems upon extending the service.
\end_layout

\begin_layout Section
Testing environment
\end_layout

\begin_layout Standard
All tests should be executed under 
\series bold
Nose
\series default
.
 Settings for plugins can be given by command line options, but prefered
 way is to store them as 
\series bold
environment variable
\series default
s.
 Environment variables are used to pass values between components too.
 This way is used to ensure all test runs within one batch run will be reported
 properly.
 To ease repeated runs with the same configuration, support for 
\series bold
profiles
\series default
 is implemented.
 If environment variable 
\emph on
PROFILE_NAME
\emph default
 is found, system tries to load module with given name and read environment
 variables from it.
 
\end_layout

\begin_layout Standard
If 
\series bold
zfsReportPlugin 
\series default
is enabled, results are reported to django driven 
\series bold
TestResultStorage
\series default
.
 Settings for it is read from module which name is in environment variable
\series bold
\emph on
 
\series default
DJANGO_SETTINGS_MODULE.

\emph default
 Default place for it is TestResultStorage.settings (on most systems in /usr/lib/
python/site-packages/TestResultStorage/settings.py).
\end_layout

\begin_layout Subsection
ZfsTest
\end_layout

\begin_layout Standard
Zfsd control from python is implemented in ZfsProxy.
 This class provides methods for starting zfsd, status queries, syplog control,
 sane zfsd terminating and locked daemon killing.
 
\end_layout

\begin_layout Standard
Normal 
\series bold
zfs tests
\series default
 should inherit from class ZfsTest which implements basic fixtures for zfs.
 New daemon is started for every test to run.
\end_layout

\begin_layout Standard

\series bold
Stress test
\series default
 classes listing meta tests should inherit from class ZfsStressTest which
 runs all tests on single instance of zfsd.
\end_layout

\begin_layout Standard
multi-thread
\end_layout

\begin_layout Standard
distributed
\end_layout

\begin_layout Subsection
Failure state data
\end_layout

\begin_layout Standard
ZfsProxy class sets environment for zfsd to create core dump upon crash.
 If crash is recognized, this core dump is collected and appended to snapshot.
 If zfsd is running while snapshot is created core dump of running process
 is created instead.
\end_layout

\begin_layout Standard
When test fails or error is detected, 
\series bold
snapshotPlugin
\series default
 creates snapshot of predefined components.
 Snapshot plugin can be configured to create snapshots before tests and
 after successfull tests too but while zfsd core dump has more than 150Mb
 it takes non-trivial amouth of time to create it.
\end_layout

\begin_layout Paragraph
By default snapshot will consists of:
\end_layout

\begin_layout Itemize
snapshot of zfs cache (filesystem)
\end_layout

\begin_layout Itemize
snapshot of filesystem to which comparisons are made
\end_layout

\begin_layout Itemize
zfsd log output
\end_layout

\begin_layout Itemize
test instance
\end_layout

\begin_layout Itemize
ZfsProxy instance
\end_layout

\begin_layout Itemize
zfsd core dump
\end_layout

\begin_layout Itemize
python exception and backtrace (if any)
\end_layout

\begin_layout Standard
Developer can specifi any 
\series bold
further data
\series default
 to include to snapshots by overriding test 
\emph on
snapshot
\series bold
 
\series default
\emph default
method.
 Method gets 
\emph on
SnapshotDescription
\emph default
 instance as argument.
 
\emph on
SnapshotDescriptio
\emph default
n has methods for appending primitive types, python objects, files and directori
es.
 Every entry in snapshot have unique name, type and description.
 Primitive types are stored in memory, bigger data on disk.
 For purpose of reporting snapshot can be packed into single file which
 contains both data and their descriptions.
\end_layout

\begin_layout Subsection
Reporting and result repository
\end_layout

\begin_layout Standard
Test results are stored in 
\series bold
mysql database
\series default
 to which access is provided through 
\series bold
django
\series default
 api.
 Settings are stored in TestResultStorage/settings.py and should be synchronized
 between master and any slave reporting to master.
\end_layout

\begin_layout Standard
Small data (textual information, return codes, etc) are stored in database.
 Big data such as snapshots are stored on disk.
 Every file has to have entry in database where it's relation to test run
 is stored.
 
\series bold
File transfer
\series default
 between slave and master must be handled externally.
 Prefered method how to handle this is map storage directory (for example
 /var/lib/TestResultStorage/data) between master and slave by NFS in case
 of separate hosts or by method provided by virtualization software if master
 and slave are virtualized on the same machine.
\end_layout

\begin_layout Standard
Django stores objects as rows in tables, one table for one class (plus some
 indices and many-to-many relation tables).
 We use TestRun class for information about one run of single test, TestRunData
 class to hold auxiliary information for (mostly failed) tests - backtraces,
 exceptions, file names of snapshots.
 Set of TestRuns that were executed together are connected by BatchRun object
 which holds common attributes such as machine that executes tests, branch,
 revision and profile.
 Projects and profile information are represented as foreign key to tables
 Project and ProfileInfo because they repeats a lot.
\end_layout

\begin_layout Standard
In 
\series bold
Nose
\series default
 reporting of test results is wrapped in 
\series bold
ReportProxy
\series default
 class which holds BatchRun information and generates and commits TestRun
 objects into database.
 Nose integration is done by 
\series bold
zfsReportPlugin
\series default
.
 This plugin implemnts startTest hook for test duration measurements and
 addFailure, addError and addSuccess hooks to catch and report test results.
 When there is a unhandled system error (python Exception), it is cought
 by outer try-except block and reported to database too.
\end_layout

\begin_layout Standard
Result repository has dynamic 
\series bold
web interface
\series default
 which consists of tests and batches listing pages (with simple filtering
 options), detail pages for test run and batch run and project list page.
 If snapshot is available for test run, it can be downloaded from test run
 detail page.
 Older results can be deleted from administration inteface.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
Options
\end_layout

\begin_layout Standard
Test sets can be 
\series bold
filtered
\series default
 in three ways:
\end_layout

\begin_layout Itemize
by passing to executable only files (modules, classes, tests) that should
 be run (disables search)
\end_layout

\begin_layout Itemize
by nose.attrib plugin.
 User can define expression that must evaluate to true for given test attributes.
 For example expression '
\emph on
not disabled
\emph default
' will discard tests where 
\emph on
test.disabled
\emph default
 evaluates to True.
 Tests loaded from saved path bypasses this filtering.
\end_layout

\begin_layout Itemize
by name regular expressions.
 By default, test name must match regular expression 
\emph on
(?:^|[
\backslash

\backslash
b_
\backslash

\backslash
./-])[Tt]est).
 
\emph default
But this expression is configurable through 
\emph on
NOSE_TESTMATCH
\emph default
 environment variable.
\end_layout

\begin_layout Standard

\series bold
ZfsConfig 
\series default
plugin provides user-definable configs straight to tests.
 List of configuration files (in defined format) can be passed to plugin.
 Plugin will read them, convert to python object and pass this object to
 all tests.
\end_layout

\begin_layout Standard
To handle 
\series bold
deadlocks 
\series default
and unfinite loops both in zfsd and malformed test, there is 
\series bold
\emph on
timed
\emph default
 decorator
\series default
, by which can be set timeout for test and handler function to execute while
 time runs out.Current implementation of handler will send SIGABRT to zfsd
 causing termination with core dump generated.
\end_layout

\begin_layout Subsection
Random workload generation
\end_layout

\begin_layout Standard
Generation of random workload to file system (stress tests) is done by 
\series bold
zfsStressGenerator 
\series default
plugin.
 User must define so called 
\emph on
meta-tests
\emph default
, basic operation from which workload will consists.
 Random workload is generated by graph walk.
 By default full graph with even edge scores will be used, but user can
 define dependency graph by himself.
\end_layout

\begin_layout Standard

\series bold
Format
\series default
 for meta-test is identical with normal test, meta-tests intended to be
 used together must be listed in one test class (as python has multiple
 inheritance allowed, this should not be problem).
 
\end_layout

\begin_layout Standard
If there are 
\series bold
dependencies between tests
\series default
 (such as that open test should run before read test), they can be defined
 by graph.
 Graph format is python dictionary, where key is meta-test name and value
 is list of oriented edges originating in the meta-test.
 Edge is defined by target meta-test and by it's score.
 Score is arbitrary positive number, bigger number means bigger probability
 to use that edge.
\end_layout

\begin_layout Standard
Meta-test chain will be terminated if meta-test with no successor is hit,
 or terminating probability can be defined.
 Hard 
\series bold
length
\series default
 
\series bold
limit 
\series default
of meta-test chain can be defined by plugin option.
\end_layout

\begin_layout Standard
If random workload test fails, the path which causes failure is saved into
 file for further usage.
 By default, 
\series bold
saved paths
\series default
 aren't commited into repository but it can be enabled to do so.
 ZfsStressGenerator plugin can try to
\series bold
 strip failed tests
\series default
 to see, if shorter test sequence would cause failure too.
 Actual algorithm to strip sequences is shortest path between first meta-test
 and the failing meta-test.
\end_layout

\begin_layout Subsection
Extendability
\end_layout

\begin_layout Standard
Extending tests should be pretty straightforward.
 As python is object oriented language, inheritance should be used.
 
\end_layout

\begin_layout Standard
If new features are needed on the level of driving component (Nose), they
 should be delivered as new plugins.
 Plugins are nearly independent, but the ordering of their execution should
 be preserved.
 Excution order is given by their 
\emph on
score
\emph default
 attribute ascending.
\end_layout

\begin_layout Section
C test
\end_layout

\begin_layout Standard
For unit testing of C source code 
\series bold
Zen-unit
\series default
 library was developed.
 
\end_layout

\begin_layout Standard
Library has very minimalistic api consisting of single file with four defines:
\end_layout

\begin_layout Enumerate

\series bold
ZEN_TEST
\series default
 macro used to declare test header
\end_layout

\begin_layout Enumerate

\series bold
ZEN_ASSERT
\series default
 to test conditions in tests
\end_layout

\begin_layout Enumerate

\series bold
PASS
\series default
 which is value that should be returnded from passing tests.
\end_layout

\begin_layout Enumerate

\series bold
FAIL
\series default
 which is value that should be returned from failing tests.
 
\end_layout

\begin_layout Standard
where 
\emph on
FAIL
\emph default
 is recomended, but any return value different from 
\emph on
PASS
\emph default
 is considered as failed test.
\end_layout

\begin_layout Standard
Searching for tests is made using libelf, tests are looked for in dyntab
 and symtab of binary and all linked libraries.
 Shared libraries can be tested by 
\emph on
LD_PRELOAD
\emph default
 to 
\emph on
zentest
\emph default
 binary.
\end_layout

\begin_layout Standard
There were more options to use for test collection:
\end_layout

\begin_layout Itemize
user listed tests in some type of #ifdef declared main.
 This doesn't remove the need of listing and moreover create some dificulties
 in main source file.
\end_layout

\begin_layout Itemize
to use full C grammar to search for tests in source files and to generate
 main file.
 This remove need of listing tests, but requires full C parser.
\end_layout

\begin_layout Itemize
to use some C preprocessor to generate simply parsable overview (xml) and
 generate test list from them.
 This posibility was not fully explored but was considered far more complicated
 that binary format based discovery.
\end_layout

\begin_layout Standard
For integration with nose we use output parsing.
 We have considered generation of test lists or test libraries (through
 swig) but we found it to be redundant overhead.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
The big picture
\end_layout

\begin_layout Section
Build system
\end_layout

\begin_layout Standard
Original ZlomekFS build system (make) was switched to 
\series bold
automake
\series default
 due to problems on 64bit systems with library directories (lib vs lib64).
 Hence for C based components 
\series bold
autoconf
\series default
, 
\series bold
automake
\series default
 and 
\series bold
libtool
\series default
 are used, for python based components 
\series bold
setuptools
\series default
 are used with make wrapper for better compatibility with other tools.
\end_layout

\begin_layout Standard
Target audience of both ZlomekFS and regresion testing framework uses mainly
 
\series bold
Redhat
\series default
 or 
\series bold
Fedora
\series default
 based systems.
 To ease installation and upgrades it was decided to provide automatic build
 targets for 
\series bold
RPM
\series default
 packages.
 For other systems, .tar.gz source packages can be generated.
\end_layout

\begin_layout Subsection
Standard targets
\end_layout

\begin_layout Standard
All components understands following make targets:
\end_layout

\begin_layout Itemize
all - build all binaries and libraries
\end_layout

\begin_layout Itemize
doc - build documentation
\end_layout

\begin_layout Itemize
dist - build .tar.gz source package
\end_layout

\begin_layout Itemize
rpm - build all available rpm packages (source, doc, binary)
\end_layout

\begin_layout Itemize
clean - remove generated data
\end_layout

\begin_layout Itemize
test - run available tests
\end_layout

\begin_layout Section
Buildbot configuration
\end_layout

\begin_layout Standard
Buildbot is configured to create builder for every component on every host.
 Thanks to build system unification, build step sequence is equal for all
 components it goes update - build - test - make rpm - install - upload.
 
\end_layout

\begin_layout Standard
Change source is svn polling, schedulers are configured to wait some time
 after change before builder is run.
 
\end_layout

\begin_layout Standard
Test driving (Nose) was included in way, that doesn't need external configuratio
n, only django needs to have 
\emph on
DJANGO_SETTINGS_MODULE
\emph default
 present in environment, so it is exported in start time of buildbot.
\end_layout

\begin_layout Chapter
Conclusion
\end_layout

\begin_layout Standard
goals fullfilment
\newline
Goal of this thesis was to extend existing ZlomekFS implementat
ion and implement regression testing framework.
 After exploration of ZlomekFS there were clear need of logging facility
 and remote state discovery to allow reliable testing.
 From research done on related projects we decided to create new logger
 and made status information available through d-bus.
\end_layout

\begin_layout Standard
As regression testing framework we have used existing solution - Nose.
 Under it it is possible to write tests with both approaches.
 As example there is implementation of one test which identify filesystem
 errors by deviations of implicit filesystem behaviour and implementation
 of one test which identify filesystem errors by comparison with other (reliable
) filesystem.
\end_layout

\begin_layout Standard
By plugin we provide posibility to generate random workload to filesystem
 which can be constrained to valid sequences only.
 Plugin can prune sequence to find minimal sequence needed to reproduce
 the error.
 
\end_layout

\begin_layout Standard
Snapshoting plugin offer chance to have as much state information and protocol
 for tracing and debuging the problem which have caused the problem.
 Current implementation provides core dump of daemon, log files, sequence
 which have caused the error, cache content, comparison file system (if
 used) snapshot and python component state.
 This snapshot plugin can include most of possible data types that can be
 required when debugging and thus tester can easilly define other data to
 include to snapshots.
\end_layout

\begin_layout Standard
Changing network conditions is currently not possible but through d-bus
 interface there is possibility to change behaviour of filesystem (offline,
 slow connection, full speed) directly without need of network control.
 For filesystem state change, network conditions were evaluated as problematic
 tool to work with.
 When there will be need to provide network protocol robustness testing,
 it will need use sofisticated external tool which is beyond scope of this
 thesis.
\end_layout

\begin_layout Standard
Developer documentation for C code was written in DoxyGen and there are
 build target for generating html documentation available (moreover RPM
 packages with documentation can be build too).
 For python we use language provided __doc__ attributes with predefined
 syntax.
\end_layout

\begin_layout Standard
It is possible to use this system for testing of any other filesystem.
 Especially in case of userspace based filesystem the modification needed
 will be only change of daemon binary and settings (which will be obviously
 different).
 If filesystem will have kernel component (especially in case of full kernel
 based filesystems) there will be need of 
\emph on
kdump
\emph default
 integration for snapshoting state of filesystem in case of failure.
 According our informations it is currently the only project for testing
 filesystem capable of storing step sequence for reproducing error and snapshoti
ng state of filesystem.
 Other projects found in this area consists from random workload generator
 and checker that will only report that failure has happened, but without
 any further specification what have caused the failure.
\end_layout

\begin_layout Standard
real usage - we found some bugs (size, deadlock)
\end_layout

\begin_layout Standard
author word - it was fun :(
\end_layout

\begin_layout Chapter
Apendix
\end_layout

\begin_layout Section
Coding conventions
\end_layout

\begin_layout Subsection*
C based code
\end_layout

\begin_layout Standard
For code in C, original formating from ZlomekFS was adopted.
\end_layout

\begin_layout Standard

\series bold
Identifiers
\series default
 ah are in lower case, words separated by underscore.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset

uint32_t log_level;
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Defines
\series default
 (macros) are in upper case, words separated by underscore.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset

#define MY_MACRO_CONSTANT 5
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Typedefs 
\series default
are in lower case with suffix 
\emph on
_t
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset

typedef uint32_t fibheapkey_t;
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Braces around code block
\series default
 should be on new lines, indentation level as previous code.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
syp_error set_log_level (logger target, log_level_t level) 
\end_layout

\begin_layout Standard
{ 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
target->log_level = level;
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
return NOERR; 
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Braces around function arguments
\series default
 sould be separated from function name by one space, if argument list is
 multiline, ending brace should be right after last argument (on same line).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
syp_error send_uint32_by_function (uint32_t data, 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
syp_error (*function)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
(int, uint32_t, const struct sockaddr *, socklen_t),
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
const char * ip, uint16_t port);
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I
\series bold
ndentation
\series default
 should be two spaces per level.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
syp_error dbus_disconnect(DBusConnection ** connection) 
\end_layout

\begin_layout Standard
{
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
if (connection == NULL)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
return ERR_BAD_PARAMS; 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
if (*connection == NULL) 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
return ERR_NOT_INITIALIZED;
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
dbus_bus_release_name (*connection, 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
SYPLOG_DEFAULT_DBUS_SOURCE, NULL);
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
dbus_connection_unref(*connection);
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
*connection = NULL;
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
return NOERR; 
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Operators 
\series default
should be separated from arguments by one space on both sides.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset

file_position\InsetSpace ~
+=\InsetSpace ~
bytes_written;
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Comments 
\series default
have one space between comment makr and comment text.
 They are on line before code they are describing.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
/*!\InsetSpace ~
Structure holding logger state and configuration.\InsetSpace ~
*/
\end_layout

\begin_layout Standard
typedef struct logger_def 
\end_layout

\begin_layout Standard
{ 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
///\InsetSpace ~
input - output medium definition struct
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
struct medium_def printer;
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Filenames 
\series default
consisting from more words should have dash between words.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset

control-protocol.h
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Python code
\end_layout

\begin_layout Standard
For code in python, formatting from Nose 
\begin_inset LatexCommand cite
key "Nose"

\end_inset

 was adopted.
\end_layout

\begin_layout Standard

\series bold
Identifiers
\series default
 ah are in CamelCase, class names with first letter in upper case, instance
 names with first letter in lower case.
\end_layout

\begin_layout Standard
I
\series bold
ndentation
\series default
 should be four spaces per level.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
class DependencyGraph(object):
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
graph = None 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
currentNode = None 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
randomGenerator = SystemRandom()
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
def equals(self, graph):
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
return self.graph == graph.graph and 
\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
self.currentNode == graph.currentNode 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
def initRandomStartNode(self): 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
self.restart(self.randomGenerator.choice(self.graph.keys()))
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Braces around function arguments
\series default
 sould be right after function name.
 
\end_layout

\begin_layout Standard

\series bold
Arguments
\series default
 should be separated by one space.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
def testLocal(self,\InsetSpace ~
empty):
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
assert self.buildGraphsAndCompare(reference = self.nonUniformGraph,
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
buildMethod = GraphBuilder.USE_LOCAL,
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
methods = self.nonUniformMethods)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Operators 
\series default
should be separated from arguments by one space on both sides.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset

file_position\InsetSpace ~
+=\InsetSpace ~
bytes_written;
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Documentation comments 
\series default
should have one space between comment makr and comment text.
 They should be on line after element they are describing.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
def isMetaClass (self, cls):
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
"""\InsetSpace ~
Tests if class is meta class (should contain meta tests)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
:Parameters:
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
cls: class object to check
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
:Return: 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
True if is metaclass, False otherwise
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
"""
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Code comments
\series default
 should have one space between comment mark and comment text.
 They should be on line before code they are describing.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
def countNiceElements(list):
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
""" Count elements which are nice :) """
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
count = 0
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
for element in list:
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
if isNice(element):
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
count += 1
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
return count
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Installation
\end_layout

\begin_layout Standard
This guide is based on new Fedora 8 installation, installation to other
 systems may be different.
 In example, we have buildmaster on IP 192.168.16.253, buildslave on IP 192.168.16.252
 and development system on IP 192.168.16.128.
 We assume that buildslave has basic developement packages (such as gcc)
 installed.
\end_layout

\begin_layout Subsection
Buildmaster
\end_layout

\begin_layout Standard
Create user account under which buildbot will run on buildmaster.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset

useradd -d /home/buildmaster -s /bin/bash buildmaster
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then, install external packages and tools.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
yum install buildbot python-sqlite2 mysql-server\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
MySQL-python screen
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Install TestResultStorage.
 Django in version version 0.97 (pre) is required.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset

rpm -ivh python-django-snapshot-*.rpm TestResultStorage-*.rpm
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Set mysql to start on boot and start it.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
/sbin/chkconfig mysqld on
\end_layout

\begin_layout Standard
/etc/init.d/mysqld start
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Change root password for mysql.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
/usr/bin/mysqladmin -u root password 'secret'
\end_layout

\begin_layout Standard
/usr/bin/mysqladmin -u root -h 192.168.16.253 password 'secret'
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Create database for TestResultStorage.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
echo '
\end_layout

\begin_layout Standard
CREATE DATABASE trs character set utf8;
\end_layout

\begin_layout Standard
GRANT all ON trs.* TO nose@localhost IDENTIFIED BY 'secret';
\end_layout

\begin_layout Standard
GRANT all ON trs.* TO nose@192.168.16.252 IDENTIFIED BY 'secret';
\end_layout

\begin_layout Standard
GRANT all ON trs.* TO nose@192.168.16.128 IDENTIFIED BY 'secret';
\end_layout

\begin_layout Standard
FLUSH PRIVILEGES;
\end_layout

\begin_layout Standard
'| mysql --user=root --password=secret
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Setup TestResultStorage to use local mysql database with right credentials
 (
\begin_inset LatexCommand prettyref
reference "fig:settings_py_master"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
DATABASE_ENGINE = 'mysql' 
\end_layout

\begin_layout Standard
DATABASE_NAME = 'trs'
\end_layout

\begin_layout Standard
DATABASE_USER = 'nose'
\end_layout

\begin_layout Standard
DATABASE_PASSWORD = 'secret' 
\end_layout

\begin_layout Standard
DATABASE_HOST = 'localhost'
\end_layout

\begin_layout Standard
DATABASE_PORT = '' 
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:settings_py_master"

\end_inset


\begin_inset Caption

\begin_layout Standard
TestResultStorage/settings.py (buildmaster)
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Create TestResultStorage tables.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
cd /usr/lib/python2.5/site-packages/TestResultStorage
\end_layout

\begin_layout Standard
python manage.py syncdb
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Checkout (export) buildmaster's configuration
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
su buildmaster
\end_layout

\begin_layout Standard
cd /home/buildmaster
\end_layout

\begin_layout Standard
svn export\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
http://shiva.ms.mff.cuni.cz/svn/zzzzzfs/branches/zouhar/buildbot/buildmaster\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
zlomekfs
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Setup buildmaster to allow client connections and to start www server on
 right port (
\begin_inset LatexCommand prettyref
reference "fig:master_cfg"

\end_inset

, 
\begin_inset LatexCommand prettyref
reference "fig:buildbot_tac_master"

\end_inset

).
 Note that if svn url or branching schema changes, they should be tweaked
 too.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
WAIT_BEFORE_BUILD = 1
\newline

\end_layout

\begin_layout Standard
c['slaves'] = [BuildSlave("bug", "secret"),
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
BuildSlave("zen", "secret")]
\end_layout

\begin_layout Standard
c['slavePortnum'] = "tcp:9989"
\newline

\end_layout

\begin_layout Standard
c['projectName'] = 'ZlomekFS'
\end_layout

\begin_layout Standard
c['projectURL'] = 'http://dsrg.mff.cuni.cz/~ceres/prj/zlomekFS'
\newline

\end_layout

\begin_layout Standard
c['buildbotURL'] = 'http://192.168.16.253:8010'
\newline

\end_layout

\begin_layout Standard
svnurl = 'https://shiva.ms.mff.cuni.cz/svn/zzzzzfs'
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:master_cfg"

\end_inset


\begin_inset Caption

\begin_layout Standard
master.cfg
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
basedir = r'/home/buildmaster/zlomekfs'
\end_layout

\begin_layout Standard
configfile = r'master.cfg' 
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:buildbot_tac_master"

\end_inset


\begin_inset Caption

\begin_layout Standard
buildbot.tac (master)
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Set buildbot to start on boot, for example by adding crontab entry (
\begin_inset LatexCommand prettyref
reference "fig:buildmaster_cron"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
@reboot make start -C /home/buildmaster/zlomekfs
\end_layout

\begin_layout Standard
@reboot screen -d -m -S\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
TestResultStorage python\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
/usr/lib/python2.5/site-packages/TestResultStorage/manage.py\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
runserver 192.168.16.253:8020 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:buildmaster_cron"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
buildmaster.cron
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Start buildmaster.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset

make start -C /home/buildmaster/zlomekfs 
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Open ports 3306, 8010, 9989 (or other, if setting in master.cfg is different)
 on firewall.
 Rules below are only examples, they should be pernament (for example written
 in /etc/sysconfig/iptables).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
/sbin/iptables -A RH-Firewall-1-INPUT -m state --state NEW\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
-m tcp -p tcp --dport 8010 -j ACCEPT
\end_layout

\begin_layout Standard
/sbin/iptables -A RH-Firewall-1-INPUT -m state --state NEW\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
-m tcp -p tcp --dport 9989 -j ACCEPT
\end_layout

\begin_layout Standard
/sbin/iptables -A RH-Firewall-1-INPUT -m state --state NEW\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
-m tcp -p tcp --dport 3306 --source 192.168.16.0/24 -j ACCEPT
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is all except for file transfers.
 If you want to use nfs for file transfers, read nfs configuration below.
\end_layout

\begin_layout Standard
Set data directory to be exported (
\begin_inset LatexCommand ref
reference "fig:exports"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
/var/lib/TestResultStorage/data 
\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
192.168.16.252(fsid=0,rw,root_squash,sync)\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
192.168.16.128(fsid=0,rw,root_squash,sync)
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:exports"

\end_inset


\begin_inset Caption

\begin_layout Standard
/etc/exports
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Tell portmap to allow connections to services (
\begin_inset LatexCommand ref
reference "fig:hosts_allow"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
portmap: 192.168.16.128 , 192.168.16.252
\end_layout

\begin_layout Standard
lockd: 192.168.16.128 , 192.168.16.252
\end_layout

\begin_layout Standard
rquotad: 192.168.16.128 , 192.168.16.252
\end_layout

\begin_layout Standard
mountd: 192.168.16.128 , 192.168.16.252
\end_layout

\begin_layout Standard
statd: 192.168.16.128 , 192.168.16.252
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:hosts_allow"

\end_inset


\begin_inset Caption

\begin_layout Standard
/etc/hosts.allow
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Set mount daemon to use specific port - needed for firewall settings (
\begin_inset LatexCommand ref
reference "fig:sysconfig_nfs"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
MOUNTD_PORT=32773
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:sysconfig_nfs"

\end_inset


\begin_inset Caption

\begin_layout Standard
/etc/sysconfig/nfs
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Open ports on firewall.
 Note that you must make this rules pernament for example through 
\emph on
system-config-firewall
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
/sbin/iptables -A RH-Firewall-1-INPUT -m state --state NEW\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
-m tcp -p tcp --dport 2049 -j ACCEPT
\end_layout

\begin_layout Standard
/sbin/iptables -A RH-Firewall-1-INPUT -m state --state NEW\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
-m udp -p udp --dport 2049 -j ACCEPT
\end_layout

\begin_layout Standard
/sbin/iptables -A RH-Firewall-1-INPUT -m state --state NEW\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
-m tcp -p tcp --dport 111 -j ACCEPT
\end_layout

\begin_layout Standard
/sbin/iptables -A RH-Firewall-1-INPUT -m state --state NEW\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
-m udp -p udp --dport 111 -j ACCEPT
\end_layout

\begin_layout Standard
/sbin/iptables -A RH-Firewall-1-INPUT -m state --state NEW\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
-m udp -p udp --dport 32773 -j ACCEPT
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Run nfs and make it start upon boot.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
/sbin/service nfs start
\end_layout

\begin_layout Standard
/sbin/chkconfig nfs on
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Buildslave
\begin_inset LatexCommand label
name "sub:Buildslave"

\end_inset


\end_layout

\begin_layout Standard
First install required packages.
 Note that not all are available from Fedora repositories.
 For i386 and x86_64 architecture they can be found on thesis cd.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
yum install buildbot python-sqlite2 MySQL-python kernel-devel\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
dbus dbus-devel libtool autoconf automake gettext gettext-devel\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
python-setuptools python-nose pyflakes
\end_layout

\begin_layout Standard
rpm -ivh python-django-snapshot-*.rpm\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
TestResultStorage-*.rpm py25_pysvn_svn144-*.rpm
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Install packages from all components.
 This can be skipped, but when further builds will go in wrong order, dependency
 problems could arrive.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
rpm -ivh zen-unit-*.rpm syplog-*.rpm pysyplog-*.rpm\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
zlomekfs-*.rpm zfsd-status-*.rpm TestResultStorage-*.rpm\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
insecticide-*.rpm
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Restart D-bus to use new configuration (allow syplog and zfsd communication).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
/etc/init.d/messagebus restart
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Change TestResultStorage settings to store results on buildmaster (
\begin_inset LatexCommand ref
reference "fig:settings_py_slave"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
DATABASE_ENGINE = 'mysql' 
\end_layout

\begin_layout Standard
DATABASE_NAME = 'trs'
\end_layout

\begin_layout Standard
DATABASE_USER = 'nose'
\end_layout

\begin_layout Standard
DATABASE_PASSWORD = 'secret' 
\end_layout

\begin_layout Standard
DATABASE_HOST = '192.168.16.253'
\end_layout

\begin_layout Standard
DATABASE_PORT = ''3306'
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:settings_py_slave"

\end_inset


\begin_inset Caption

\begin_layout Standard
TestResultStorage/settings.py (buildslave)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you use nfs for file transfers, set nfs mount (
\begin_inset LatexCommand ref
reference "fig:fstab"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
192.168.16.253:/var/lib/TestResultStorage/data\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
/var/lib/TestResultStorage/data nfs defaults 0 0 
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:fstab"

\end_inset


\begin_inset Caption

\begin_layout Standard
/etc/fstab
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Create directory for builds and fetch config.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
mkdir -p /var/buildbot
\end_layout

\begin_layout Standard
cd /var/buildbot
\end_layout

\begin_layout Standard
svn export\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
https://shiva.ms.mff.cuni.cz/svn/zzzzzfs/branches/zouhar/buildbot/buildslave\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
zlomekfs
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Change buildbot configuration to connect to master and use actual credentials
 (
\begin_inset LatexCommand ref
reference "fig:buildbot_tac_slave"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
basedir = r'/var/buildbot/zlomekfs'
\end_layout

\begin_layout Standard
buildmaster_host = '192.168.16.253'
\end_layout

\begin_layout Standard
port = 9989
\end_layout

\begin_layout Standard
slavename = 'zen'
\end_layout

\begin_layout Standard
passwd = 'secret'
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:buildbot_tac_slave"

\end_inset


\begin_inset Caption

\begin_layout Standard
buildbot.tac (slave)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Configure buildbot to start on boot (for example via crontab 
\begin_inset LatexCommand ref
reference "fig:buildslave_cron"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
@reboot buildbot start /var/buildbot/zlomekfs 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:buildslave_cron"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
buildslave.cron
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Start buildbot
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
buildbot start /var/buildbot/zlomekfs
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Development system
\end_layout

\begin_layout Standard
When installing on development system without need of automatic builds,
 just install required packages and build projects in correct order.
\end_layout

\begin_layout Standard
For testing all componets except ZlomekFS can be tested without install
 (make test).
 The reason why this is not possible for ZlomekFS is need of fuse build,
 which is integrated and needs to create device links, install kernel modules
 etc.
\end_layout

\begin_layout Standard
If you want environment as close to buildslave as possible, you can install
 your system in the same way as is described in 
\begin_inset LatexCommand prettyref
reference "sub:Buildslave"

\end_inset

.
 But even in this case development should be done without buildbot checkouts.
 Changing buildbot checkouts could lead into conflicts upon automatic builds.
 
\end_layout

\begin_layout Standard
To not spoil central TestResultRepository with your builds you enable out
 your own TestResultRepository on local machine (create mysql database)
 and report into it.
 This should be done in case of slow connection to master too.
 Running automatic tests without ZfsReportPlugin is discouraged - there
 would be little backtrace provided in that case.
\end_layout

\begin_layout Section
Sample session
\end_layout

\begin_layout Section
Enclosed CD
\end_layout

\begin_layout Standard
\begin_inset LatexCommand bibtex
options "plain"
bibfiles "references"

\end_inset


\end_layout

\end_body
\end_document
