#LyX 1.5.3 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass book
\begin_preamble
\newcommand{\textstylecode}[1]{
 \begin{quote}
  \texttt{#1}
 \end{quote}
}

\newenvironment{codeblock}{
\begin{quote}
\begin{ttfamily}}{
\end{ttfamily}
\end{quote}
}

\usepackage{listings}
\end_preamble
\language english
\inputencoding latin2
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize 12
\spacing single
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 3.5cm
\topmargin 3cm
\rightmargin 3.5cm
\bottommargin 5cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Regression Testing For zlomekFS
\end_layout

\begin_layout Author
Jiri Zouhar
\end_layout

\begin_layout Standard
Something very smart it is, young adept.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Section
Goals
\end_layout

\begin_layout Standard
Extend the existing zlomekFS implementation by introducing a regression
 testing framework.
 The framework should be capable of submitting both predefined and random
 workload to the filesystem and, either by comparing the results with the
 same operations performed over another filesystem, or by some other appropriate
 means, identify filesystem errors.
 The identification of an error should contain both a minimal sequence of
 steps necessary to reproduce the error, and the debugging protocol excerpt
 relevant to the error.
 The framework should include support for generating the debugging protocol
 and changing the network conditions.
\end_layout

\begin_layout Standard
Make all the developer documentation an integral part of the zlomekFS project
 using appropriate tools such as DoxyGen.
\end_layout

\begin_layout Section
Structure of the Thesis
\end_layout

\begin_layout Chapter
Filesystem testing
\end_layout

\begin_layout Standard
Filesystem can be seen as many things and thus it can be tested from at
 least the same number points of view.
 
\end_layout

\begin_layout Standard
Specification testing
\end_layout

\begin_layout Standard
We could look on filesystem as on specification of way how to store data
 and associated metedata on storage media.
 In this case we can ask if the structures are sufficient for accessing
 stored data, if the specfication covers all eventual operations that should
 be availible and if the transistions are sane.
 Specification testing is done only once at the begining.
\end_layout

\begin_layout Standard
Api conformity
\end_layout

\begin_layout Standard
Some filesystems don't focus on the way how to store data on media but how
 to make them accessible.
 Well known group of such filesystems are network filesystems.
 They suppose that some other filesystem do the storage and they specify
 only the way how data will be accessible remotely and put some restrictions
 on the filesystem behaviour.
 In this case we test the particular implementations if they are conform
 to the specification.
 stabilni iface / protokol
\end_layout

\begin_layout Standard
Functional testing
\end_layout

\begin_layout Standard
implementation
\end_layout

\begin_layout Standard
Filesystems have many things in common with normal pieces of code such as
 server or desktop applications.
 But in the means of tesing there is big problem in simulating normal enviroment
 for filesystems.
 This is caused by their low level nature and could be one of key reasons
 why most of the test suites are designed as black box testing.
\end_layout

\begin_layout Standard
is the one we will be doing.
\end_layout

\begin_layout Standard
The most desired feature on testing framework is ease of use tightly coupled
 with automation.
 To achieve this, the tests have to be written in understandable format,
 close to the tested code.
 By the meaning of regression testing, they have to be runned automatically,
 in scheduled periods (defined by amouth of time or changes), the results
 must be collected and presented in readable format somewhere.
\end_layout

\begin_layout Standard
For tracing the code execution, there may be some tracing tools and logging
 tools.
 They have to have minimal footprint and collect as much information as
 possible.
 Their output must be formatted in way compatible with the automation framework
 and with the presentation tool too, if possible.
\end_layout

\begin_layout Standard
The output of tests could be accompanied with some state information from
 the time of failure.
 This can be achieved by using some snapshoting tool which may or may not
 support resuming.
 
\end_layout

\begin_layout Standard
For filesystem testing, it is hard to find good testing patterns, which
 will cover all cases, which can occur.
 So it is good idea to have some random workload generator, which can randomly
 exercise the filesystem.
 The problem with this approach is, that outputs of such testing tends to
 be very big and only a small portion of them is related to the occured
 error.
 To allow random testing and avoid the unwanted side efects, some pruning
 algorithm has to be used.
 The reruns of tests may use the snapshots, if the method used for snapshoting
 make the resume possible.
\end_layout

\begin_layout Standard
As the ZloFS is multi-threaded, distributed filesystem, the suite should
 have some support or at least extensibility to allow control or simulation
 of distributed enviroment.
\end_layout

\begin_layout Standard
Benchmarking
\end_layout

\begin_layout Standard
Are tests which should answer the question 
\begin_inset Quotes eld
\end_inset

how long it will take
\begin_inset Quotes erd
\end_inset

 for every operation we could do with filesystem.
 They measure the performance of specific implementation in conjunction
 with given setup assuming the implementation is sane and doesn't do any
 invalid shortcuts.
 Their goal is to compare more implementations or filesystems.
 This thesis won't consider this type of tests, because there is only one
 implementation of ZFS.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Test format
\end_layout

\begin_layout Standard
When tests are expected to be executed manually, then the format could vary.
 On the other hand, when they have to be executed automatically, then for
 every format there must be support in all components of the test suite.
 Because of this there is tendency to minimize number of formats.
 
\end_layout

\begin_layout Standard
The basic choice is to write tests in native language of the application.
 Sometimes there is support for inlining tests to normal code with some
 flags saying 
\begin_inset Quotes eld
\end_inset

this is test code, it should be runned when testing
\begin_inset Quotes erd
\end_inset

.
 This allow tests as close to code as possible.
 It is ideal for short tests of functionality of separated parts (objects,
 libraries, etc).
 
\end_layout

\begin_layout Standard
For automated testing are often used scripting languages to write either
 control logic or whole thing including tests.
 Scripting languages are ideal for the logic because of their flexibility.
 The reason for writing tests in the same languate goo is that it could
 be easier integrated in that way.
\end_layout

\begin_layout Standard
Another possibility is to have tests in some proper format.
 This offer possibility of having the format very suitable for the needs
 of particular software, but this bring disadvantage of having to change
 the format every time a lag is found in specification or a new requirement
 is found.
\end_layout

\begin_layout Standard
Some testing tools uses configuration (tests) in xml or xml with embedded
 code.
 Main reason for using xml is option of using external tools for editing
 or xml-based transformation.
 On other hand, xml is very unsuitable format for hand written code and
 the DTD of configuration is often hard to understand too.
\end_layout

\begin_layout Standard
For component based systems is often used model checking or behaviour protocols.
 For this approach, there is some meta-language for defining actions and
 requirements of interfaces and some logic algebra to define states and
 conditions which must hold.
 It is usefull for checking the design of whole application, but there is
 speed issues when using behaviour protocols for checking larger or complex
 systems.
\end_layout

\begin_layout Section
Testing frameworks
\end_layout

\begin_layout Subsection
Unit based
\end_layout

\begin_layout Standard
Unit testing is based on Kent Beck's testing pattern 
\begin_inset LatexCommand cite
key "Simple_Smalltalk_Testing"

\end_inset

.
\end_layout

\begin_layout Standard
Common principes of unit testing are very simple:
\newline

\end_layout

\begin_layout Standard
Every 
\series bold
test case
\series default
 is executed separately, 
\emph on
test case
\emph default
 have common interface (in object based languages presented as common super
 class).
 The run should be independent on other 
\emph on
test cases
\emph default
.
\end_layout

\begin_layout Standard

\emph on
Test case
\emph default
 may have 
\series bold
fixtures
\series default
 - methods to set up environment before test and clean up after test.
 These methods are very often called 
\emph on
setup
\emph default
 and 
\emph on
teardown
\emph default
.
 
\emph on
Teardown
\emph default
 method is executed regardless of result of test.
\end_layout

\begin_layout Standard
Expected problem in test is called 
\series bold
failure
\series default
, non anticipated problem is called 
\series bold
error.
\end_layout

\begin_layout Standard
There is 
\series bold
common method of testing
\series default
 if expectations hold.
 In smalltalk by using 
\emph on
should
\emph default
 and 
\emph on
shouldnt
\emph default
 blocks, in 
\begin_inset Quotes eld
\end_inset

modern
\begin_inset Quotes erd
\end_inset

 languages by using 
\emph on
asserts
\emph default
.
 When expectation doesn't hold it is called 
\emph on
failure
\emph default
.
 
\emph on
Errors
\emph default
 are mostly represented by 
\emph on
exceptions
\emph default
.
\end_layout

\begin_layout Standard

\series bold
Result
\series default
 of test is a 
\emph on
result
\emph default
 object.
\end_layout

\begin_layout Standard

\emph on
Test cases
\emph default
 are agreagated to 
\series bold
test suites
\series default
 that can be aggregated too.
 
\end_layout

\begin_layout Standard
All 
\emph on
test cases 
\emph default
in 
\emph on
test suite
\emph default
 are 
\series bold
run recursivelly
\series default
 by calling 
\emph on
run 
\emph default
on root 
\emph on
test suite
\emph default
.
 Returned value is aggregated 
\emph on
Result
\emph default
 object.
\end_layout

\begin_layout Standard
Unit testing should be 
\series bold
automated
\series default
, independent on human interaction.
\end_layout

\begin_layout Standard
Other features:
\newline

\end_layout

\begin_layout Standard
Many unit testing frameworks offer more elaborated tests structuring and
 state handling (
\emph on
fixtures
\emph default
).
 Very often tests can be aggregated to classes with common setup and teardown
 methods that are run before and after every test.
 
\end_layout

\begin_layout Standard
Moreover there can be additional 
\emph on
fixture levels
\emph default
 for all code units (depending on programing language these can be 
\emph on
class level fixtures
\emph default
, 
\emph on
module level fixtures
\emph default
, 
\emph on
package level fixtures
\emph default
, etc.).
 
\emph on
Setup_
\emph default
 code is run before entering particular block and 
\emph on
teardown_
\emph default
 code is run after leaving particular block of tests (for example setup_class
 is run before running tests in class and teardown_class is run after all
 tests have run.
 Around every single test may be setup_method and teardown_method fixtures).
 Note that this could break the independency requirement.
\end_layout

\begin_layout Standard
Best practices:
\newline

\end_layout

\begin_layout Standard
Unit testing is mostly used for
\emph on
 testing 
\emph default
s
\emph on
mall pieces of code 
\emph default
and thus use cases are mostly very fast and simple.
\end_layout

\begin_layout Standard
Unit testing is very often used to watch for regressions so all tests should
 be executed periodically by some automation tool.
\end_layout

\begin_layout Standard
There should be 100% code coverage done by unit tests.
 Every function (method) shoud have at least one test case, class should
 have test suite as counterpart.
 
\end_layout

\begin_layout Standard
Implementations:
\newline

\end_layout

\begin_layout Standard
There is at least one unit testing framework for every programming language
 (see 
\begin_inset LatexCommand cite
key "xUnit"

\end_inset

 for short list).
 We will focus mainly to these which are C or Python based.
\end_layout

\begin_layout Standard

\series bold
JUnit
\series default
 
\begin_inset LatexCommand cite
key "JUnit"

\end_inset

 is unit testing for java.
 This framework is interesting just by it's author: 
\emph on
Kent Beck
\emph default
, guru of unit testing.
 Have standard features as test level fixtures, assert methods and aggregation.
 In last version (JUnit 4) there were added class level fixtures, timeouts
 for tests, expect exception annotation and requirement of inheriting from
 TestCase was removed.
 It is not part of standard distribution.
\end_layout

\begin_layout Standard
Python has 
\series bold
Unittest 
\begin_inset LatexCommand cite
key "unittest"

\end_inset


\series default
 as it's standard (called 
\emph on
PyUnit
\emph default
 
\begin_inset LatexCommand cite
key "PyUnit"

\end_inset

 before integration to python standard distribution).
 The api is strongly object oriented, tests must inherit from TestCase class,
 override specific methods and test with defined methods of TestCase.
 Doesn't offer more levels of fixtures.
 It is very pure reimplemenatation of Kent Beck's original smalltalk framework.
\end_layout

\begin_layout Standard

\series bold
Py.test 
\begin_inset LatexCommand cite
key "PyTest"

\end_inset


\series default
 is alternative python unit testing framework.
 It is part of 
\emph on
py.lib
\emph default
 library 
\begin_inset LatexCommand cite
key "PyLib"

\end_inset

, has fixtures support on all levels, doesn't need to inherit from superclass
 but has fixed naming convention instead.
 Use standard python assert clause to test for failures, handle exceptions
 as errors.
 Moreover, py.test has automated find-run-collect tool for searching for
 tests in directory trees.
 Test classes can be marked as conditionally 
\emph on
disabled
\emph default
 depending on generic boolean expressions.
 This library has support for generator methods which allows to yield 
\begin_inset Quotes eld
\end_inset

more
\begin_inset Quotes erd
\end_inset

 tests easily.
 Py.test most interesting feature is ease of use.
 It is possible to just write function with 
\begin_inset Quotes eld
\end_inset

test
\begin_inset Quotes erd
\end_inset

 in name and py.test will collect it, run and if there is failure or error,
 the output and backtrace will be printed in readable format.
 Py.test can also take big advantage from py.lib which offers distributed
 execution through py.execnet etc.
 Whole py.lib is written to be easy to use but in current implementation
 with trade off configurability.
 Note should be taken, that py.lib was developed as grant project and after
 grant expiration there were little of improvement in project.
\end_layout

\begin_layout Standard
Another unit testing framework for python is 
\series bold
Nose 
\begin_inset LatexCommand cite
key "Nose"

\end_inset


\series default
.
 Offers backward compatibility to standard 
\emph on
unittest
\emph default
, some compatibility with 
\emph on
py.test
\emph default
 library and try to mimic 
\emph on
py.test
\emph default
 without 
\begin_inset Quotes eld
\end_inset

magic
\begin_inset Quotes erd
\end_inset

.
 Nose provide all features of unittest, moreover it implements py.test's
 all level fixtures, tests doesn't need to inherit from superclass, has
 automated find-run-collect tool a use generators.
 In addition, Nose is very configurable, it has inbuild support for changing
 naming conventions, tests can have flags and it is possible to define expressio
ns which tests should be run according to flags.
 Nose has extensible api with plugin support.
 There are for example plugins for profiling, doctest, code coverage, etc.
 
\end_layout

\begin_layout Standard
Curiosity among unit testing frameworks is 
\series bold
MinUnit
\series default
 
\begin_inset LatexCommand cite
key "MinUnit"

\end_inset

, which is C based and consist only from three lines of code (two macros
 and one deffinition).
 Doesn't offer much, just assert - print message block.
\end_layout

\begin_layout Standard

\series bold
CUnit for Dr.Ando
\series default
 
\begin_inset LatexCommand cite
key "CUnitForAndo"

\end_inset

claims to be easy to use C based unit testing framework inspirated by 
\emph on
cppunit-x 
\emph default
(Interesting piece of code documented in Japanese).
 In fact it is just another framework which lacks fixtures and offer just
 test counting beyond 
\emph on
MinUnit.
\end_layout

\begin_layout Standard

\series bold
Simple C++ Testing framework
\series default
 
\begin_inset LatexCommand cite
key "simplectest"

\end_inset

 is written whole as macros and have somehow weird syntax.
 Offers basic assertions and testSuites.
 There is no need to write main listing all tests but this is achieved by
 wrapping all tests to macros START_TESTS and END_TESTS.
 So tests must be written in one big chunk.
 Again, tests files must be compiled and runned by hand.
 Runs equally in pure C and C++ environment.
\end_layout

\begin_layout Standard

\series bold
CxxTest
\series default
 
\begin_inset LatexCommand cite
key "CxxTest"

\end_inset

 is C++ based and all tests have to be wrapped to test suite Classes.
 This framework has assertions, fixtures and handle exceptions.
 Automated collection is done by python script (but simplified C++ gramatic
 is used).
 May have problems when linking with pure C based code.
 CxxTest have support for mocking global functions but this support works
 on base of calling functions in separate namespace, so it is not pure mock
 and code have to be modified to use mocked functions.
\end_layout

\begin_layout Standard

\series bold
CppTest 
\series default

\begin_inset LatexCommand cite
key "CppTest"

\end_inset

 is another C++ based unit test framework.
 Has basic features such as assertions, fixtures and test suites.
 Beyond this, CppTest is capable of handling and formating output and offers
 api for writing output formatters (TextOutput, CompilerOutput and HtmlOutput
 formatters implemented).
 As for CxxTest, pure C sources must be modified (add extern C {} block)
 to run under CppTest.
\end_layout

\begin_layout Standard

\series bold
CUnit
\series default
 
\begin_inset LatexCommand cite
key "CUnit"

\end_inset

 is C based still C++ compatible supports assertions, suites, test counting,
 has global registry, more user interfaces (for running tests), but no automatic
 collection and output handling.
\end_layout

\begin_layout Standard

\series bold
GUnit 
\series default

\begin_inset LatexCommand cite
key "gunit"

\end_inset

 is another unit testing framework.
 Uses GTK+ libraries (for almost anything).
 Supports assertions, suites and fixtures, has gnome and hildon (embedded)
 gui and dedicated logging facility.
 Doesn't offer discovery, however compiles suites as dynamically loadable
 libraries.
\end_layout

\begin_layout Standard

\series bold
RCUnit
\series default
 
\begin_inset LatexCommand cite
key "RCUNIT"

\end_inset

 supports assertions, suites (called modules), fixtures, has own logging
 facility, tests can be disabled.
 RCUnit has defined interface for writing output handlers, html and plain
 text handlers are implemented.
\end_layout

\begin_layout Standard

\series bold
Cutee
\series default
 
\begin_inset LatexCommand cite
key "cutee"

\end_inset

 tends to be as simple as possible.
 Thus supports only assertions, no fixtures or suites.
 Tests are collected automatically yet files with tests must be listed in
 Makefile.
\end_layout

\begin_layout Standard

\series bold
Check
\series default
 
\begin_inset LatexCommand cite
key "Check"

\end_inset

 provides assertions, suites and simple fixtures.
 Forks every test in separate process, can handle timeouts, output can be
 printed in plaintext or xml.
 Has no build or collect helpers thus adding test is very annoying.
\end_layout

\begin_layout Standard

\series bold
CuTest
\series default
 
\begin_inset LatexCommand cite
key "Cutest"

\end_inset

 from basic features provides assertions and suites.
 Has scripted tool for executable generation.
\end_layout

\begin_layout Standard
Mock
\end_layout

\begin_layout Standard
interface, network, etc - pretend to be the other side
\end_layout

\begin_layout Section
Logging, tracing
\begin_inset LatexCommand label
name "sub:Logging,-tracing"

\end_inset


\end_layout

\begin_layout Standard
Models
\end_layout

\begin_layout Standard
When an error is detected in software, developer needs to have as much informati
on about the failure as possible.
 What occured is nice to know but in most cases useless without without
 more details about the run.
 Therefore developers use logging and tracing to get some useful information
 about the particular run.
\end_layout

\begin_layout Standard
Tracing we mean storing information about call sequence in the program,
 by logging we mean saving information about data changes or notes about
 states of system inserted by developer.
 In most cases this features are provided by one tool.
\end_layout

\begin_layout Standard
The simpliest logging tool used is insertion of 
\series bold
direct message prints
\series default
.
 Printing may provide the information needed, but it suffer by not having
 centralized control of what has to be printed.
 This leads to excessive logging, in which is hard to find a usefull information
, and if we want to avoid this it force us to changing the code on many
 places.
\end_layout

\begin_layout Standard
So the next logical step is to send logging messages (accompanied by importance
 level) to some 
\series bold
centralized facility
\series default
.
 The importance levels are in most cases directly given in advance.
 Providing this it is possible to change the amount of information centraly
 and even redirect the messages to distinct places.
\end_layout

\begin_layout Standard
When simple distinguishment by importance is not enough then more advanced
 logging facilities comes with 
\series bold
tagging of messages
\series default
.
 Tags could be flat or of arbitrary structure.
 This allow better filtering of messages of special types.
 
\end_layout

\begin_layout Standard
Other approach to logging is to have more than one logger.
 In this case the tool has frequently 
\series bold
producer - consumer
\series default
 based architecture and loggers are organized to dynamically created hierarchy.
 This ease goal of having different output locations for different types
 of messages.
 On the other hand, the architecture is not so easy to understand for anybody
 who might contribute to the code.
 Moreover, with more people participating on development, it is nearly impossibl
e to keep the hierarchy of producers and consumers used in application sane.
 
\end_layout

\begin_layout Standard
The last approach to logging and tracing is called 
\series bold

\begin_inset Quotes eld
\end_inset

aspect oriented programing
\series default

\begin_inset Quotes erd
\end_inset

.
 In this case the logging is not present in code itself but it is separated
 as independent concern to aspect - logical definition what and where has
 to be logged.
 
\end_layout

\begin_layout Standard
Pitfalls
\end_layout

\begin_layout Standard
Even if a adequate logging facility is used to debug the software, there
 can arise problems when the facility is used under some automated stress
 testing.
 The amouth of output logs will eventually gets too big for storage capacity
 or at least for the potential reader to deal with.
 So the automation tool must be able to communicate with the logging facility
 and in some way dynamically change the amouth of output according to needs.
 This must be tuned so the biggest possible portion of unrelated logs is
 thrown away but the crucial information for debugging is preserved for
 failure as the failure could be hard to repeat.
\end_layout

\begin_layout Standard
There is one more reason that may be considered for muting logging output.
 The reason is that logging could slow the application down.
 To check how much logging slows down a ordinary application, some measurements
 were done.
 
\end_layout

\begin_layout Standard
For testing was used real application - session server from the SUCKS 
\begin_inset LatexCommand cite
key "SUCKS"

\end_inset

project.
 The session server was threaded and accessible by network.
 Logging facility was simple centralized logger with pre-definet log levels.
 Logger was alternated so it measures time spent by logging.
 Tests consisted of pre-defined workload, output was time spent by whole
 application, time spent in logging and characters printed.
 Test cycle was composet of one run of all tests for every log level and
 log target.
 After finishing the cycle starts again.
 This had been running for approximately thirty hours on two platforms:
\end_layout

\begin_layout Enumerate
intel centrino with core2duo cpu set to static frequency of 1Ghz with 2GB
 memory (most unused) running kernel 2.6.20.1 x86_64.
 
\end_layout

\begin_layout Enumerate
motorola ppc MPC8241 (177 bogomips) with 128MB memory running kernel 2.4.32
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename logSums.png
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Logging load
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Both platforms behaved equally, the only difference was in speed (we must
 consider, that motorola was connected by network and all console prints
 must went through ssh).
 From results we can see that all logging targets had the same footprint
 and the only 
\begin_inset Quotes eld
\end_inset

slow
\begin_inset Quotes erd
\end_inset

 target was console write.
 For non-blocking targets, the slowdown was in hundereths of per cent for
 all log levels and the difference between no logging and full logging was
 only one hundereth of per cent.
\end_layout

\begin_layout Standard
So when we don't need to read the output of application online we can log
 everything, having as target some circular buffer which can be flushed
 to file only when error occured.
 Filtering can be done afterwards by user.
 Another finding is that the logging footprint is in half made of checks
 if something has to be logged or not and to minimalize slowdown, logging
 must be entirely deleted in compile time.
 Problem with this is that it makes changes to code, thus to binary image
 too and this changes can lead to different behavior of erroneous code,
 so the bug could be unreproducible with different logging level.
\end_layout

\begin_layout Standard
Other problem which can arise with logging is that logging can act as synchroniz
ation primitive which could prevent some collisions to appear.
 Problem with synchronization can be solved by design of logging facility.
 The logger must be designed in way that create separated resources for
 every concurrently running entity in advance and then the only effect done
 by the logger is slowdown of creation of new 
\begin_inset Quotes eld
\end_inset

threads
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section
Presentation layer
\begin_inset LatexCommand label
name "sub:Presentation-layer"

\end_inset


\end_layout

\begin_layout Standard
Usual test run produce outputs of many types, begining with standart outputs,
 going on with filesystem changes and debug logs and even including state
 snapshots, core dumps etc.
 These are data of very different types.
 The goal is to present them to user in usable way with structure that can
 be easilly understood and through ways which are accessible from as much
 enviroments as possible.
\end_layout

\begin_layout Standard
Raw data
\end_layout

\begin_layout Standard
The easiest way to present results is to leave them as they are produced
 by application and test suite.
 When this approach is used the raw data are often made vaailable for downloadin
g through simple protocol such as FTP or some remote access.
 Raw data hold always full information, don't suffer by ano losses from
 transformations.
 On the other hand raw data are often platform dependent and may have to
 be interpreted on the system that produced them.
 The data should be in standart format to allow readability by external
 tools.
\end_layout

\begin_layout Standard
Web interface
\end_layout

\begin_layout Standard
Dynamic web pages are nowadays very used way of presentation as they are
 relatively easy to write.
 Web pages have big advantage in accessibility - nearly every computer have
 web prowser installed and people are used to get information through these.
 On the other hand web pages can hardly display some debug outputs such
 as core dumps and other binary data.
 In this case data should be downloadable for reading through external tools.
 Interaction with web is little bit slower than with local application and
 user comfort is also worst.
\end_layout

\begin_layout Standard
Special application
\end_layout

\begin_layout Standard
Even raw data must be interpreted by application to be presented in readable
 form.
 When there aren't appropriate general tools, they should be written as
 part of test suite.
 The fact that they must be written is one big disadvantage by itself.
 Full featured interpreter of debug data with presentation layer may consist
 of the same amouth of work as test suite itself.
 Moreover requirements and dependencies of such application could be non-trivial
 and platform independency is hardly to achieve with this approach.
 The big pro of special application is that as written specially for a suite
 it should fits very well the needs.
\end_layout

\begin_layout Section
Random workload generation
\end_layout

\begin_layout Standard
must be generated from small test units (meta tests, atoms).
 Depending on subject tested atoms are either defined by tradition (basic
 operations that can be made on subject tested) or small well defined tests.
 It is sometimes wanted to group some atoms to create new (bigger) atom.
 In ideal case run of a beta test doesn't change state of subject tested.
 But this type of atoms can test only stateless sysatems and operations
 which are less errorneous and not so big candidates for regresion testing
 as statefull systems are.
 For statefull systems (and metat tests) there should be method how to define
 and check states and legal transistions.
 Simple method to allow this is to give to tester some way to define pre-
 and post- run hooks that can initialize state, check transistion and posibly
 do cleanup after test.
 While approach with pre and post run hooks is simple yet powerfull, there
 is one issue connected to it.
 In this system tester can use statefull tests but in trade of possible
 waste of resources.
 When test expected some state different that in which system is, it must
 either made a state change (non trivial operation out of test scope) or
 silently pass without testing and let the system run other test.
 More spohisticated system for resolving state-fullness is to give tester
 tool to define allowet transistions between tests.
 Transistions are often given by graph (edges can be allowed transistions
 or vice versa).
 
\end_layout

\begin_layout Standard
Sometimes it may be desirable to give some preferences (what should be tested).
 For random workload this means either binary switching tests on and off
 or giving preferences in percentage.
 When state-fullnes is not solved or solved by pre- and post- hooks, precentage
 is connected to tests.
 When transistions are used, precentage can be either for tests (implicit
 edges) or for transistions.
\end_layout

\begin_layout Standard
Length of continuous random workload can be simple defined as:
\end_layout

\begin_layout Itemize
number of tests (min, max, mean)
\end_layout

\begin_layout Itemize
time (resources) used
\end_layout

\begin_layout Itemize
by transistions to end point
\end_layout

\begin_layout Standard
When user preferences are given system itself is oten simple automata running
 on satatefull graph.
\end_layout

\begin_layout Section
Pruning output
\end_layout

\begin_layout Standard
When long test (or random test) fails we don't know which step has caused
 the failure, so we need test outputs (debugging info) to locate the bug.
 On the other hand output from long and random tests can be huge and most
 of it may be useless.
 The goal of pruning output is to provide enough information to find the
 bug and at the same time hide useless balast.
 Basically we can divide outputs to developer written log messages, system
 state snapshots (memory dums, FS state, etc).
 The second type is more resources consuming, but easy searchable by hand.
 So as storage capacity is cheap, we can simply leave all snapshots or limit
 space used by constant and delete old snapshots.
 As for logs the problem was described in chapter !!! logging !!!.
 When logging doesn't slow application down and doesn't change behaviour,
 the best approach is to log all, store all (or last X) and provide tool
 for filtering and searching logs.
 With this approach we can be sure that no crucial information was lost
 by heuristic prunning.
 In special cases lice low resource platforms (without storage, extremly
 slow, etc) where we can't afford wasting, some heuristic must be used.
 For system state this can be last state before recognizing failure and
 state after.
 For logs there can be more approaches which can be divided to 
\end_layout

\begin_layout Itemize
on-time prunning - test suite changes log level of application according
 to probability of failure.
 The question is, how it should know.
\end_layout

\begin_layout Itemize
afterwards - log level is constant for test run, logs are stored to cyclic
 buffer.
 When failure occurs, test suite will trim the buffer to store just usefull
 information.
\end_layout

\begin_layout Itemize
re-run - tests are runned with logging on minimal level.
 When failure occur, test suite will rerun the test with more logging 
\begin_inset Quotes eld
\end_inset

around
\begin_inset Quotes erd
\end_inset

 the failure, possibly skiping some parts of test (as for random generated
 workload).
\end_layout

\begin_layout Section
Checkpointing
\begin_inset LatexCommand label
name "sub:Checkpointing"

\end_inset


\end_layout

\begin_layout Standard
As some failures are hardly reproducible, developer wants as much information
 about the faulty run as possible.
 Sometimes logs are not sufficient and state of application in time of failure
 is needed.
 That's why some snapshoting support might be usefull.
 
\end_layout

\begin_layout Standard
Moreover, as the runs to failure could be very long, the test suite may
 try to repeat just short parts of them or skip some steps to find the shortest
 possible run to bring about the bug.
 For reruns is best, when the second run has the same start conditions.
 The snapshots (checkopoints) can help with it by resuming from stored state
 (if possible).
\end_layout

\begin_layout Standard
There are many projects trying to create full featured checkpoint / resume
 support for applications.
 They can be divided in two groups: userspace only tools and kernel-based
 tools.
 The main problem among them is, that none of them have full support for
 every resource an application could use.
 The most frequently missing features are suspend / resume support for:
 networking, devices, threads, signal handlers, shm, shared objects.
 Some of them (BCLR 
\begin_inset LatexCommand cite
key "BLCR"

\end_inset

, CryptoPID 
\begin_inset LatexCommand cite
key "cryptoPID"

\end_inset

, Chpox 
\begin_inset LatexCommand cite
key "chpox"

\end_inset

) seems to have everything needed, but for the price of many constraints
 and dependencies.
 
\end_layout

\begin_layout Standard
Other possibility, which solve the matter of sandboxing too is to use some
 virtualization tool and run application (not necessarilly test suite) inside
 virtual machine.
 Nowadays there is many virtualization tools with support for snapshoting
 (for ex.
 openVZ 
\begin_inset LatexCommand cite
key "openVZ"

\end_inset

, Vmware 
\begin_inset LatexCommand cite
key "Vmware"

\end_inset

, Xen 
\begin_inset LatexCommand cite
key "Xen"

\end_inset

, Qemu 
\begin_inset LatexCommand cite
key "Qemu"

\end_inset

).
 However, working with virtualization is fairly complicated and we can't
 test hardware dependent issues on them.
\end_layout

\begin_layout Standard
The last and easiest possibility is to use just snapshoting without resume
 and save the snapshots in some easy to read format.
 For this we can use for example GDB gcore 
\begin_inset LatexCommand cite
key "gcore"

\end_inset

 command (which creates gdb core dumps) to pause and snapshot the application.
\end_layout

\begin_layout Section
Continuous integration
\end_layout

\begin_layout Standard
Existence of tests is not enough to provide stable developement cyclus.
 For stability of project it is vital to test it for errors (run tests)
 as often as possible, preferably after each change (commit).
 The approach when changes are often merged into 
\emph on
mainline
\emph default
 is called 
\series bold
Continuous integration
\series default
 (good overview of this method is in 
\begin_inset LatexCommand cite
key "Continuous_integration"

\end_inset

).
 To achieve regular tests it is convenient to use some tool (server) which
 automates the process.
 There is no need to develop own system as there are many proprietal solution
 and even more opensource solutions.
 It is interesting how many organizations deploy their own systems (for
 example Mozilla Foundation uses Tinderbox 
\begin_inset LatexCommand cite
key "Tinderbox"

\end_inset

, Redhat has Frysk 
\begin_inset LatexCommand cite
key "Frysk"

\end_inset

, ThoughWorks has 
\begin_inset LatexCommand cite
key "Cruise_Control"

\end_inset

.
 Apache foundation even two projects - Continuum 
\begin_inset LatexCommand cite
key "Continuum"

\end_inset

 and Gump 
\begin_inset LatexCommand cite
key "Gump"

\end_inset

 - that is only from opensourced projects).
 It is obvious why it is this way: core features of continuous integration
 server are easy to write and after some time when more features are needed,
 project may be bound to integration server so tightly that it is nearly
 impossible to switch to another system.
\end_layout

\begin_layout Subsection
Automation
\end_layout

\begin_layout Standard
Best approach to achieve stable build and check cycle is to automate it.
 Some projects use manually driven systems but there are hazard of human
 failure (developer could omit tests, forgot about them or ignore them at
 all).
\end_layout

\begin_layout Standard
Commonly are used two approaches to achieve automated build and check:
\end_layout

\begin_layout Standard
First is to use some post 
\series bold
commit hooks
\series default
 (we assume that version control system is used) which executes tests or
 launch separate process to execute them on background.
 This approach can ensure that no wrong code gets into repository - commit
 that won't pass all tests can be rejected.
 Running all tests can be relatively long lasting task and therefore environment
 is rarely set to execute all tests before commit and more commonly commit
 is delayed only after vital tests pass.
 More in-deep checking tests are executed afterwards in stand-alone process.
 Implementation is often bound to one version control system.
\end_layout

\begin_layout Standard
Other option is don't check validity in commit hooks but use 
\series bold
independent service
\series default
 which monitors state of repository and runs tests either for every change
 (commit) or on regular basis (night builds).
 Benefits of this approach are that it doesn't slow down commits and tools
 using this approach have frequently more features and better configurability.
 These solutions are generally independent on version control system (support
 for distinct version control systems are provided by plugins) but sometimes
 use hooks to get alert upon change.
\end_layout

\begin_layout Standard
Often this combination is used:
\end_layout

\begin_layout Itemize
pre-commit hooks are used to enforce repository rules and coding conventions
\end_layout

\begin_layout Itemize
separate service builds project (upon commit or nightly) and executes all
 tests checking if change breaks something
\end_layout

\begin_layout Standard
Because one of steps should be building the source there sould be support
 for build system used by project.
 Again, many tools are plugin based and have plugins for most common build
 systems used.
 Particular set depends on aim of tool.
\end_layout

\begin_layout Standard
Pure commit driven environment when commit is delayed after all tests had
 passed doesn't need presentation layer at all, there is just the error
 message send to commiter.
 But as this variant is rare, nearly all automation systems have 
\series bold
presentation
\series default
 layer.
 The complexity vary from simple text (html) file statically served by web
 server to rich database backed gui.
 Standard tools offer html overview and detail pages, tools bound to specific
 environment usually provide gui for that environment.
 Very often there are email or instant messaging notifiers too.
 If there are other output than test count and results, it tends to be plain
 text, sometimes there are output format readable by applications.
\end_layout

\begin_layout Subsection
Distributed testing
\begin_inset LatexCommand label
name "sub:Distributed-testing"

\end_inset


\end_layout

\begin_layout Standard
Testing doesn't need to be run on the same machine as control service.
 When tests run elsewhere we call it distributed testing.
 In some cases it is possible to run many separate machines each running
 separate build and check service achieving nearly the same result.
 But managing such system is huge overhead and collecting results is non
 trivial too.
\end_layout

\begin_layout Standard
There can be many reasons for distributing:
\newline

\end_layout

\begin_layout Standard
It is crucial do distribute testing for 
\series bold
multiplatform applications
\series default
.
 Bad code can behave badly only on one of target platforms and therefore
 testing on only one platform can left errors undiscovered.
 In this case distributed testing is the only way to cover specifics of
 all platforms.
\end_layout

\begin_layout Standard
Some tests or projects could be 
\series bold
dangerous
\series default
 to system itself or the project is part of base system.
 These should run them in separation of production system in some sort of
 sandbox.
 As virtualization is nowadays easy to deploy, the best way (and in case
 of base system parts the only way) to sandbox project tests in virtual
 machine.
 This must be considered as distributed testing too because the comunication
 with virtual machine must be done in the same way as if the virtual machine
 were in other network.
 There are in general less security barriers between the host machine and
 guest machine but it don't affect the connection method itself.
\end_layout

\begin_layout Standard
Another reason for running tests on other machine can be 
\series bold
resource consumption
\series default
.
 As the control system should be visible to wide network (at least the presentat
ion layer) it is frequently run on production server which hosts other applicati
ons too.
 In this case it is not good idea to slow down or even block whole system
 by tests.
 Again tests are given to another machine to execute.
\end_layout

\begin_layout Standard
Sometimes tests takes long 
\series bold
time
\series default
 to complete.
 Then it is convenient to spread tests over more machines each running only
 part of tests.
 By this we achieve shorter build and check cycle.
\end_layout

\begin_layout Standard
Distribution can be acchieved by:
\newline

\end_layout

\begin_layout Standard
Sending commands through remote terminal.
 For example on unix data could be copied to target machine by scp, tests
 executed through ssh and results again retrieved through scp.
 This is the easiest way used in simple cases where no synchronization or
 overview is needed.
 Data in general doesn't need to be delivered through the same way as commands.
 Client can fetch them himself upon test command, or there can be shared
 network storage where control server should put data for tests.
\end_layout

\begin_layout Standard
Most common way to connect control server with machines executing tests
 (sometimes called slaves or bots) is to use remote procedure call.
 As remote procedure call we mean not only RPC but any method that allows
 us to call procedures on remote system.
 There are many rpc tools such as RPC, CORBA, dcom, python twisted, py.execnet,
 etc.
\end_layout

\begin_layout Standard
Older systems tends to use e-mail communication.
 It consists of specially formatted messages sent between master and clients.
 This approach has many drawbacks as security problems, frangibility and
 non-deterministic behaviour.
\end_layout

\begin_layout Standard
Sometimes own methods for communication is used, that mimic remote procedure
 call by sending raw data within special protocol.
\end_layout

\begin_layout Section
Sandboxing
\end_layout

\begin_layout Standard
When tests need more privileges over hosting environment or the tested component
 itself is part of operating system there is big probability that running
 tests can broke anything.
 In this case they must be executed in so called sandbox.
 It is either part of system with restricted access to some resources or
 whole separate system.
 Obviously there must be possibility to restore easilly previous state of
 sandbox after breakage from test.
 
\end_layout

\begin_layout Standard
When choosing sandboxing method to use other requirements must be considered
 too.
 
\end_layout

\begin_layout Standard
As we described in 
\begin_inset LatexCommand prettyref
reference "sub:Logging,-tracing"

\end_inset

, execution logs are crucial to track failure (bug) found by automated testing.
 Therefore it should be possible to get logs (and other data) from sandbox
 at least after failure but prefferably to send them back to master straight
 upon generation.
 This is more logger feature, but to use it the sandbox must allow communication
 with outside.
\end_layout

\begin_layout Standard
When testing is distributed (see 
\begin_inset LatexCommand prettyref
reference "sub:Distributed-testing"

\end_inset

) it should be considered to use the remote machine as sandbox too.
 Again, there should be method to easilly restore state of whole remote
 machine after breakage from test.
 Note that this would be problematic with real (non-virtualized) hosts.
\end_layout

\begin_layout Standard
In 
\begin_inset LatexCommand prettyref
reference "sub:Checkpointing"

\end_inset

 we have analysed problem of providing information about test state to developer.
 If sandbox is represented by full operating system then checkpointing of
 whole sandbox would be in most cases big overhead.
 Still it should be taken into account in some cases.
 One case where sandbox snapshots may be convenient is when test depends
 heavily on system state or changes system state.
 Then without system snapshot some information to track failure may be missing.
 Other case when full snapshots may be generated is when test has caused
 system failure (therefore normal snapshots can't be created).
\end_layout

\begin_layout Section
Filesystem test patterns
\end_layout

\begin_layout Standard
muhehe
\end_layout

\begin_layout Standard
fstest
\end_layout

\begin_layout Standard
fsx
\end_layout

\begin_layout Standard
solaris
\end_layout

\begin_layout Standard
ltp
\end_layout

\begin_layout Chapter
The test suite architecture
\end_layout

\begin_layout Section
Programming language
\end_layout

\begin_layout Standard
Since ZlomekFS tends to be multiplatform and support more operating systems
 (currently only linux is supported) we need language which runs on any
 platform and at least under UNIX-like operating systems.
 For testing the language should be flexible enough but on other hand since
 we will be testing file system, speed must be considered too.
 Last but not least need is that the language sould allow integration with
 existing code.
\end_layout

\begin_layout Standard
Because of this criteria 
\series bold
python 
\series default

\begin_inset LatexCommand cite
key "Python"

\end_inset

 was chosen as main programing language for driving component.
 Since python can integrate with most compiled languages, not all components
 must be written in python.
 Performance critical parts and integration libraties are writen in ZlomekFS
 native language - 
\series bold
C
\series default
.
\end_layout

\begin_layout Section
Used tools
\end_layout

\begin_layout Subsection

\series bold
Testing environment
\end_layout

\begin_layout Standard
For very specific purpose of testing distributed file system we have found
 no existing solution.
 Instead of develop new system it was decided to tweak existing some existing
 tool (if possible) to fit our needs.
 From general purpose testing tools written in python 
\series bold
Nose
\series default
 
\begin_inset LatexCommand cite
key "Nose"

\end_inset

 was found as the most suitable for our needs.
 Moreover every feature that we need and nose doesn't implement can be delivered
 as plugin for nose within modifiing nose core code.
 Nose plugin architecture was found as flexible enough for further extending
 of test suite too.
\end_layout

\begin_layout Subsection
Continuous integration
\end_layout

\begin_layout Standard
When choosing tools for continuous integration, we consider only opensource
 projects with reliable comunity around it.
 Specially deeper investigation were made on Cruise Control 
\begin_inset LatexCommand cite
key "Cruise_Control"

\end_inset

, Continuum 
\begin_inset LatexCommand cite
key "Continuum"

\end_inset

, Gump 
\begin_inset LatexCommand cite
key "Gump"

\end_inset

, Cabie 
\begin_inset LatexCommand cite
key "Cabie"

\end_inset

, Tinderbox 
\begin_inset LatexCommand cite
key "Tinderbox"

\end_inset

, Frysk 
\begin_inset LatexCommand cite
key "Frysk"

\end_inset

and Buildbot 
\begin_inset LatexCommand cite
key "BuildBot"

\end_inset

.
\end_layout

\begin_layout Standard
We use 
\series bold
buildbot
\series default
 
\begin_inset LatexCommand cite
key "BuildBot"

\end_inset

 as continuous integration server.
 
\end_layout

\begin_layout Standard
It was chosen for these reasons:
\end_layout

\begin_layout Itemize
Compatibility with our build system.
 Buildbot can use shell comnmands and python code as build steps.
 It can do output parsing for configure, make and gcc output too.
\end_layout

\begin_layout Itemize
It is small and easy to deploy.
 There is no need to write big xml configuration files to run 
\emph on
hello world
\emph default
, buildbot code is relativelly small and easy to read.
\end_layout

\begin_layout Itemize
Written in python.
 Since whole Buildbot is written in python, we can easilly integrate it
 with other tools used in project (as they are written in python too).
\end_layout

\begin_layout Itemize
Extendable architecture.
 Buildbot parts are written as objects, so it is possible to inherit from
 them and tweak behaviour according our needs.
\end_layout

\begin_layout Itemize
Support for distributed testing.
 As ZlomekFS is intended to run on multiple architectures (and in future
 possibly on multiple operating systems) the support for distributed testing
 is essential.
\end_layout

\begin_layout Itemize
Active development.
 Buildbot is often used and has active comunity which ensures that it will
 be maintained in future too.
\end_layout

\begin_layout Subsection
Web result presentation and result repository
\end_layout

\begin_layout Standard
Test results in buildbot are presented as textual output from commands.
 This is not enough from two reasons: when failure or error is found, the
 textual output may be messy.
 Bigger problem is, that it can't provide enough information and binary
 data can't be provided in this way at all.
\end_layout

\begin_layout Standard
So there was need for another way to represent test results.
 Since test outputs can contain binrary data (snapshots, core dumps, filesystem
 state, etc), the presentation layer should be able to distinguish several
 types of data and present them according type.
 As data and information for test run are related to each other we decided
 to use database driven storage.
 
\end_layout

\begin_layout Standard
The solution which fits our needs best was 
\series bold
Django 
\series default

\begin_inset LatexCommand cite
key "Django"

\end_inset

.
 It is written in python, offers object oriented database abstraction layer,
 web pages generating tools.
 It's configuration format is pure python, so it is easy to integrate it
 with other parts of project.
\end_layout

\begin_layout Subsection
Logging
\end_layout

\begin_layout Standard
We need logger with this features:
\end_layout

\begin_layout Itemize
it can be controlled externally
\end_layout

\begin_layout Itemize
it has simple still full featured interface
\end_layout

\begin_layout Itemize
it has to have implementations in both languages in which is written test
 suite and zfs 
\end_layout

\begin_layout Itemize
the output has to be in parseable and user readable format
\end_layout

\begin_layout Standard
This enforces us to write 
\series bold
new logger
\series default
, which suits best the needs.
 From models, we can't use aspect oriented logging as there is no implementation
 of aspects for both languages (and moreover it will be big requirement
 for developers to use aspects).
 The producer-consumer model seems to be too complicated as there will be
 large and non-homogenous group of developers working on zlomek fs.
\end_layout

\begin_layout Standard
So the logger will be centralized, with some sort of tagging with fast evaluatio
n.
 The output will be redirectable to some sort of shared resource (shm, network
 socket) which can be used and controlled by test suite.
 The format of written log for failure may be preferably readable by some
 GUI or web based reader such as Chainsaw 
\begin_inset LatexCommand cite
key "Chainsaw"

\end_inset

, if not possible, user readable output should be used.
\end_layout

\begin_layout Subsection
C based unit testing
\end_layout

\begin_layout Subsection
Documentation
\end_layout

\begin_layout Standard
For documenting C code 
\series bold
Doxygen
\series default
 
\begin_inset LatexCommand cite
key "Doxygen"

\end_inset

 was chosen.
 Main argument was that ZlomekFS is documented in Doxygen, secondary Doxygen
 is nowadays nearly standard tool for documenting C code.
\end_layout

\begin_layout Standard
For Python code, Doxygen has some support, but the support is problematic,
 needs usage of imput filters such as Doxypy 
\begin_inset LatexCommand cite
key "Doxypy"

\end_inset

 and even then results are not ideal.
 
\end_layout

\begin_layout Standard
There is standard docstring format for python 
\begin_inset LatexCommand cite
key "PEP257"

\end_inset

, but it doesn't support more than plain-text formating.
 
\end_layout

\begin_layout Standard
Another option is to use some non-standard documentation tools for python
 (most of them are listed in PEP256 
\begin_inset LatexCommand cite
key "PEP256"

\end_inset

).
 Their problems are mainly listed in mentioned PEP256.
\end_layout

\begin_layout Standard
Finally, 
\series bold
reStructuredText Docstring Format
\series default
 
\begin_inset LatexCommand cite
key "PEP258,reStructuredText"

\end_inset

 was chosen.
 Main reason was that Nose 
\begin_inset LatexCommand cite
key "Nose"

\end_inset

 uses this format, secondary reStructuredText is easy readable in 
\series bold
Pydoc 
\begin_inset LatexCommand cite
key "Pydoc"

\end_inset


\series default
 output and there is html formating tools too.
\end_layout

\begin_layout Subsection
Build system
\end_layout

\begin_layout Subsection
Packaging
\end_layout

\begin_layout Standard
Target audience of both ZlomekFS and regresion testing framework uses mainly
 
\series bold
Redhat
\series default
 or 
\series bold
Fedora
\series default
 based systems.
 To ease installation and upgrades it was decided to provide automatic build
 targets for 
\series bold
RPM
\series default
 packages.
 For other systems, .tar.gz source packages can be generated.
\end_layout

\begin_layout Chapter
Implementation details
\end_layout

\begin_layout Section
Logging
\end_layout

\begin_layout Standard
Original message printing system (two levels, hardcoded values) was switched
 to 
\series bold
new logger
\series default
 (
\emph on
Syplog
\emph default
) developed specially for ZlomekFS.
 
\end_layout

\begin_layout Standard
Logger supports eleven 
\series bold
log levels
\series default
.
 Log level is 32bit unsigned integer (typedef), log levels are defined by
 macro constants (from LOG_EMERG to LOG_LOOPS).
 There is conversion function available to convert log levels to user-readable
 strings.
\end_layout

\begin_layout Standard
For concern separation logger distinguish 
\series bold
facilities
\series default
.
 Facilites are disjunct one-bit flags which can be ORed.
 Log message can be labeled as belonging to any number of facilities.
 Again, there is conversion function to convert facilityes to user-readable
 strings.
\end_layout

\begin_layout Standard
Log levels can be used to 
\series bold
filter
\series default
 what types of messages (of which importance) should be recorded and which
 should be discarded.
 Both log level and facility set can be regulated in runtime.
\end_layout

\begin_layout Standard

\series bold
Output
\series default
 from logger can be written to file or shared memory, api is open for extension
 such as socket write.
 Format of output files can be user readable strings or raw memory dumps.
 For all formats and output targets there is both writer and reader support,
 so transformation between formats is trivial.
\end_layout

\begin_layout Standard

\series bold
Settings
\series default
 is read in format of program arguments (array of string with given array
 size).
 Logger ignores unknown options, so direct configuration from command line
 is possible (and currently used).
\end_layout

\begin_layout Standard
For 
\series bold
integration
\series default
 with external driving component (Nose testing environment) there is 
\series bold
d-bus
\series default
 control api.
 Both log level and facility set is adjustable through d-bus.
 For further integration there is full-featured python wrapper for syplog.
\end_layout

\begin_layout Standard
Log level and facility list can be 
\series bold
extended
\series default
 by listing constants for new log levels and facilities in header files.
 Output formats and targets are defined by static structures holding pointers
 to functions with specified behaviour.
 New formats and targets can be provided by implementing given function
 set and providing description structure.
 For further reference please read doxygen documentation of library 
\emph on
Syplog
\emph default
.
\end_layout

\begin_layout Section
Reporting and result database
\end_layout

\begin_layout Section
Driving
\end_layout

\begin_layout Section
Generating
\end_layout

\begin_layout Section
Tests
\end_layout

\begin_layout Standard
C integration:
\end_layout

\begin_layout Standard
- swig generate modules, then walk dir() and get by name
\end_layout

\begin_layout Standard
- generate binaries by own tool (walk by elf reader)
\end_layout

\begin_layout Standard
- generate binaries by own - walk by c parser
\end_layout

\begin_layout Standard
- macro based mains with test indexes
\end_layout

\begin_layout Standard
- separate binaries with make targets, etc...
\end_layout

\begin_layout Standard
- tool generated binaries / search
\end_layout

\begin_layout Standard
- extern static registry with registration function
\end_layout

\begin_layout Standard
C integration flaws:
\end_layout

\begin_layout Standard
- must be usable without test suite (shell driver)
\end_layout

\begin_layout Standard
- must be easy to use
\end_layout

\begin_layout Standard
- tests have to be easy to write
\end_layout

\begin_layout Standard
- must handle dependencies
\end_layout

\begin_layout Standard
cutest, 
\end_layout

\begin_layout Standard
fork / don't fork
\end_layout

\begin_layout Standard
what with system-dependent errors (nomemory, etc)? how to mock?
\end_layout

\begin_layout Standard
macro / hand / grep 
\end_layout

\begin_layout Standard
setup/teardown
\end_layout

\begin_layout Standard
code layout (mixing or separating)
\end_layout

\begin_layout Standard
collecting
\end_layout

\begin_layout Standard
test framework code readability & flexibility (modular design)
\end_layout

\begin_layout Standard
test framework maturity#
\end_layout

\begin_layout Standard
!!ATTR and EXPR in nose 
\end_layout

\begin_layout Standard
--with-stopwatch --faster-than 5
\end_layout

\begin_layout Standard
--with-figleafsecions
\end_layout

\begin_layout Standard
config by environment
\end_layout

\begin_layout Standard
untestable test with comparision
\end_layout

\begin_layout Standard
! when pickling, only names are written for code blocks (methods etc) so
 before unpickling, the original module must be imported...
\end_layout

\begin_layout Standard
the same (^) holds for class data (so be carefull when pickling class with
 setup_class method)
\end_layout

\begin_layout Standard
!!!! this disable pickling of random data....!!!!!
\end_layout

\begin_layout Standard
__getstate__(), __setstate__()
\end_layout

\begin_layout Section
The big picture
\end_layout

\begin_layout Chapter
Conclusion
\end_layout

\begin_layout Standard
work enlightens
\end_layout

\begin_layout Chapter
Apendix
\end_layout

\begin_layout Section
Coding conventions
\end_layout

\begin_layout Subsection*
C based code
\end_layout

\begin_layout Standard
For code in C, original formating from ZlomekFS was adopted.
\end_layout

\begin_layout Standard

\series bold
Identifiers
\series default
 ah are in lower case, words separated by underscore.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset

uint32_t log_level;
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Defines
\series default
 (macros) are in upper case, words separated by underscore.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset

#define MY_MACRO_CONSTANT 5
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Typedefs 
\series default
are in lower case with suffix 
\emph on
_t
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset

typedef uint32_t fibheapkey_t;
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Braces around code block
\series default
 should be on new lines, indentation level as previous code.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
syp_error set_log_level (logger target, log_level_t level) 
\end_layout

\begin_layout Standard
{ 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
target->log_level = level;
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
return NOERR; 
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Braces around function arguments
\series default
 sould be separated from function name by one space, if argument list is
 multiline, ending brace should be right after last argument (on same line).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
syp_error send_uint32_by_function (uint32_t data, 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
syp_error (*function)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
(int, uint32_t, const struct sockaddr *, socklen_t),
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
const char * ip, uint16_t port);
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I
\series bold
ndentation
\series default
 should be two spaces per level.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
syp_error dbus_disconnect(DBusConnection ** connection) 
\end_layout

\begin_layout Standard
{
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
if (connection == NULL)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
return ERR_BAD_PARAMS; 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
if (*connection == NULL) 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
return ERR_NOT_INITIALIZED;
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
dbus_bus_release_name (*connection, 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
SYPLOG_DEFAULT_DBUS_SOURCE, NULL);
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
dbus_connection_unref(*connection);
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
*connection = NULL;
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
return NOERR; 
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Operators 
\series default
should be separated from arguments by one space on both sides.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset

file_position\InsetSpace ~
+=\InsetSpace ~
bytes_written;
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Comments 
\series default
have one space between comment makr and comment text.
 They are on line before code they are describing.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
/*!\InsetSpace ~
Structure holding logger state and configuration.\InsetSpace ~
*/
\end_layout

\begin_layout Standard
typedef struct logger_def 
\end_layout

\begin_layout Standard
{ 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
///\InsetSpace ~
input - output medium definition struct
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
struct medium_def printer;
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Filenames 
\series default
consisting from more words should have dash between words.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset

control-protocol.h
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Python code
\end_layout

\begin_layout Standard
For code in python, formatting from Nose 
\begin_inset LatexCommand cite
key "Nose"

\end_inset

 was adopted.
\end_layout

\begin_layout Standard

\series bold
Identifiers
\series default
 ah are in CamelCase, class names with first letter in upper case, instance
 names with first letter in lower case.
\end_layout

\begin_layout Standard
I
\series bold
ndentation
\series default
 should be four spaces per level.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
class DependencyGraph(object):
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
graph = None 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
currentNode = None 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
randomGenerator = SystemRandom()
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
def equals(self, graph):
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
return self.graph == graph.graph and 
\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
self.currentNode == graph.currentNode 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
def initRandomStartNode(self): 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
self.restart(self.randomGenerator.choice(self.graph.keys()))
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Braces around function arguments
\series default
 sould be right after function name.
 
\end_layout

\begin_layout Standard

\series bold
Arguments
\series default
 should be separated by one space.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
def testLocal(self,\InsetSpace ~
empty):
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
assert self.buildGraphsAndCompare(reference = self.nonUniformGraph,
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
buildMethod = GraphBuilder.USE_LOCAL,
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
methods = self.nonUniformMethods)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Operators 
\series default
should be separated from arguments by one space on both sides.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset

file_position\InsetSpace ~
+=\InsetSpace ~
bytes_written;
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Documentation comments 
\series default
should have one space between comment makr and comment text.
 They should be on line after element they are describing.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
def isMetaClass (self, cls):
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
"""\InsetSpace ~
Tests if class is meta class (should contain meta tests)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
:Parameters:
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
cls: class object to check
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
:Return: 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
True if is metaclass, False otherwise
\end_layout

\begin_layout Standard
"""
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Code comments
\series default
 should have one space between comment mark and comment text.
 They should be on line before code they are describing.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
def countNiceElements(list):
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
''' Count elements which are nice :) '''
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
count = 0
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
for element in list:
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
if isNice(element):
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
count += 1
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
return count
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Installation
\end_layout

\begin_layout Standard
\begin_inset LatexCommand bibtex
options "plain"
bibfiles "references"

\end_inset


\end_layout

\end_body
\end_document
