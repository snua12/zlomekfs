#LyX 1.5.4 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass book
\begin_preamble
\newcommand{\textstylecode}[1]{
 \begin{quote}
  \texttt{#1}
 \end{quote}
}

\newenvironment{codeblock}{
\begin{quote}
\begin{ttfamily}}{
\end{ttfamily}
\end{quote}
}

\usepackage{listings}
\usepackage{varioref}
\end_preamble
\language english
\inputencoding latin2
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize 12
\spacing single
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 3.5cm
\topmargin 4cm
\rightmargin 3.5cm
\bottommargin 4.5cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Regression Testing For zlomekFS
\end_layout

\begin_layout Author
Jiří Zouhar
\end_layout

\begin_layout Standard
ZlomekFS is distributed file system aimed to transparent sharing of directory
 trees.
 This thesis describes how regression testing for it was build.
\end_layout

\begin_layout Standard
Firstly, it summarizes actual methods used for software testing, debugging,
 and bug tracing.
 Where applicable, emphasis is put on specific application of these methods
 on filesystems.
 On the basis of this research actual system for ZlomekFS is considered
 and build.
 System consists of six parts.
\end_layout

\begin_layout Standard
Unit testing framework for C code providing automatic test discovery with
 minimalistic interface.
\end_layout

\begin_layout Standard
Logging facility with C and python interface using message importance and
 concerns separation for filtering.
 The logger is remotely controllable.
\end_layout

\begin_layout Standard
Workload generator which can generate random test sequence.
 Rules for random workload can be defined by tests content and dependency
 graph describing order constrains.
 Failed sequences can be saved for later reproduction.
 The generator can try to find the shortest sequence to reproduce error.
\end_layout

\begin_layout Standard
Test controlling and reporting framework.
 This part controls test execution, prepares sane environment, executes
 tests, and collects data for further failure investigation.
\end_layout

\begin_layout Standard
Test result repository with user interface where test results are stored.
\end_layout

\begin_layout Standard
Continuous integration server which triggers events and runs automatic builds.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
ZlomekFS is special distributed filesystem aimed to allow transparent sharing
 of directory trees between any number of computers (nodes).
\end_layout

\begin_layout Standard
Unit of sharing (local directory) is called volume.
 In ZlomekFS, there are no server and client nodes, the hierarchy is general
 graph where every node can export volume.
 Nevertheless, when two nodes connects, for volume one of them must be master
 providing content, and the other client.
 This relationship can be bidirectional (client for one volume can be master
 for another).
\end_layout

\begin_layout Standard
Node can cache content of volume obtained from outside and provide it to
 further nodes.
 But this caching is not required, node can use remote volume without local
 cache too.
 By this approach, arbitrary hierarchy can be created.
 On one node, all volumes must be mounted under tree with one root directory
 (volume), while other volumes are mounted beneath.
 
\end_layout

\begin_layout Standard
ZlomekFS doesn't require any special layer on disk, it uses arbitrary filesystem
 for storing cached content.
 To reduce network bandwidth, ZlomekFS doesn't have files as elementary
 units, but operates on 
\emph on
chunks
\emph default
 (parts of file of predefined size).
 Since the hierarchy can be nontrivial, conflicts can arise.
 In ZlomekFS, conflict is represented as files in special directory.
 
\end_layout

\begin_layout Standard
For mobile nodes there are two modes to operate in (beyond full speed connection
).
 If there is no connection, node can operate in disconnected mode, when
 data are served from cache only.
 Eventually, when node connects again, data are synchronized with other
 nodes.
 Last mode is 
\emph on
slow connection
\emph default
 mode when, to limit traffic, only directories and parts of files actually
 read are synchronized with master node.
\end_layout

\begin_layout Standard
As in any software, in filesystems could be bugs too.
 But in case of filesystems, there is even bigger need for reliability.
 This is caused by low-level character of filesystems, where all other applicati
ons depends on proper work of components beneath them, and nearly every
 application needs to store permanent data (for which filesystems are widely
 used).
 To ensure reliability of software, tests are used.
 They should cover maximum of use-cases software could be use for.
 This is convenient for one term software development, but essential when
 further extension and development would be done.
\end_layout

\begin_layout Standard
However, ZlomekFS lacks any tests or testing environment.
 As described, ZlomekFS is very complex and special filesystem, and there
 is only few similar filesystems.
 Because of this, there is need to develop special framework for testing.
 It should be able to provide debugging and tracing information, if bugs
 are found.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Goals
\end_layout

\begin_layout Standard
Extend the existing zlomekFS implementation by introducing a regression
 testing framework.
 The framework should be capable of submitting both predefined and random
 workload to the filesystem and, either by comparing the results with the
 same operations performed over another filesystem, or by some other appropriate
 means, identify filesystem errors.
 The identification of an error should contain both a minimal sequence of
 steps necessary to reproduce the error, and the debugging protocol excerpt
 relevant to the error.
 The framework should include support for generating the debugging protocol
 and changing the network conditions.
\end_layout

\begin_layout Standard
Make all the developer documentation an integral part of the zlomekFS project
 using appropriate tools such as DoxyGen.
\end_layout

\begin_layout Section
Structure of the thesis
\end_layout

\begin_layout Standard
Chapter 2 describes common techniques used for testing.
 Basic test types are listed with their usage and aims.
 Reasons are given for what tools should be used when testing and how they
 can help debugging.
 
\end_layout

\begin_layout Standard
Chapter 3 summarizes tools used in final system, gives reasons for why they
 were chosen and describes their main features.
 
\end_layout

\begin_layout Standard
Chapter 4 describes internals of the system: changes made in ZlomekFS are
 written down, then component interaction is described, and finally each
 component function is documented.
\end_layout

\begin_layout Standard
Chapter 5 summarizes the work done, how goals are met and what new approaches
 are used.
\end_layout

\begin_layout Chapter
Filesystem testing
\end_layout

\begin_layout Standard
The most desired feature on testing framework is ease of use, tightly coupled
 with automation.
 To achieve this, the tests have to be written in readable format.
 There is tendency to place small unit tests as near to actual code as possible
 to allow easy maintenance.
 By the mean of regression testing, they have to be run automatically, in
 scheduled periods (defined by amount of time or number of changes), the
 results must be collected and presented on well known place.
\end_layout

\begin_layout Standard
For tracing the code execution, there may be some tracing tools and logging
 tools.
 They have to have minimal footprint, but collect as much information as
 possible.
 Their output must be formatted in way compatible with the automation framework.
\end_layout

\begin_layout Standard
The output of tests should be accompanied with some state information from
 the time of failure.
 This can be achieved by using some tool for creating snapshots, that may
 or may not support resuming.
 
\end_layout

\begin_layout Standard
For filesystem testing, it is hard to find good testing patterns which will
 cover all cases, that can occur.
 So it is good idea to have some random workload generator which can randomly
 exercise the filesystem.
 The problem with this approach is, that outputs of such testing tends to
 be very big and only a small portion of them is related to the occurred
 error.
 To allow random testing and avoid this unwanted side effects, some pruning
 algorithm has to be used.
 The reruns of tests may use the snapshots, if the method used for creating
 snapshots make the resume possible.
\end_layout

\begin_layout Standard
As the ZlomekFS is multi-threaded, distributed filesystem, the suite should
 have some support, or at least extensibility to allow control or simulation
 of distributed environment.
\end_layout

\begin_layout Section
Test types
\end_layout

\begin_layout Standard
Filesystem can be seen as many things, and thus it can be tested from many
 points of view.
 
\end_layout

\begin_layout Subsection
Specification testing
\end_layout

\begin_layout Standard
We could look on filesystem as on specification of way how to store data
 and associated metedata on storage media.
 In this case we can ask if the structures specified are sufficient for
 accessing stored data, if the specification covers all eventual operations
 that should be available, and if the transitions made by operations are
 sane and leads from correct state to correct state.
 Specification testing is generally done only once at the beginning, before
 actual implementation work is done.
\end_layout

\begin_layout Subsection
Api conformity
\end_layout

\begin_layout Standard
Some filesystems don't focus on the way how to store data on media but how
 to make them accessible.
 Well known group of such filesystems are network filesystems.
 They suppose that some other filesystem does the storage, and they specify
 only the way how data will be accessible remotely, and put some restrictions
 on the filesystem behavior.
 In this case, we test the particular implementations if they are conform
 to the specification.
 For example in case of NFS, there are test suites for checking interface
 stability, protocol conformity.
\end_layout

\begin_layout Subsection
Functional testing
\end_layout

\begin_layout Standard
Filesystems have many things in common with normal pieces of code, such
 as server or desktop applications.
 But in the means of testing there is big problem in simulating normal environme
nt for filesystems.
 This is caused by their low level nature and could be one of key reasons
 why most of the test suites are designed as black box testing.
\end_layout

\begin_layout Subsection
Benchmarking
\end_layout

\begin_layout Standard
Benchmarking gives answer the question 
\begin_inset Quotes eld
\end_inset

how long it will take
\begin_inset Quotes erd
\end_inset

 for every operation we could do with filesystem.
 Measurements are done on different filesystem implementations, or filesystems
 with similar purpose.
 There should be similar setup for all subjects tested.
 Most of benchmarking tools assumes that the implementation is sane and
 doesn't do any invalid shortcuts.
 Their goal is to compare more implementations or filesystems.
 
\end_layout

\begin_layout Section
Test format
\end_layout

\begin_layout Standard
When tests are expected to be executed manually, then the format could vary.
 On the other hand, when they have to be executed automatically, then for
 every format there must be support in all components of the test suite.
 Because of this there is tendency to minimize the number of formats.
 
\end_layout

\begin_layout Standard
The basic choice is to write tests in native language of the application.
 Sometimes there is support for embody tests to normal code with some flags
 saying, 
\begin_inset Quotes eld
\end_inset

this is test code, it should be run when testing
\begin_inset Quotes erd
\end_inset

.
 This allow tests as close to code as possible.
 It is ideal for short tests of functionality of separated parts (functions,
 objects, etc).
 
\end_layout

\begin_layout Standard
For automated testing scripting languages are often used to write either
 control logic or everything including tests.
 Scripting languages are ideal for the logic because of their flexibility.
 The reason for writing tests in the same language goo is that it integration
 is easier in that way.
\end_layout

\begin_layout Standard
Another possibility is to have tests in some proper format.
 This offer possibility of having the format very suitable for the needs
 of particular software, but brings disadvantage of having to change the
 format every time a lag is found in specification, or if new requirement
 is found.
\end_layout

\begin_layout Standard
Some testing tools use configuration (tests) in XML or XML with embedded
 code.
 Main reason for XML is option of using external tools for editing or XML-based
 transformations.
 On other hand, XML is very unsuitable format for hand written code and
 the DTD of configuration is often hard to understand.
\end_layout

\begin_layout Standard
For component based systems is often used model checking or behavior protocols.
 For this approach, there is meta-language for defining actions and requirements
 of interfaces and logic algebra to define states and conditions which must
 hold.
 It is useful for checking the design of whole application, but there is
 speed issues when using behavior protocols for checking larger or complex
 systems.
\end_layout

\begin_layout Section
Unit based testing frameworks
\end_layout

\begin_layout Standard
Unit testing is based on Kent Beck's testing pattern 
\begin_inset LatexCommand cite
key "Simple_Smalltalk_Testing"

\end_inset

.
\end_layout

\begin_layout Subsection
Common principles
\end_layout

\begin_layout Standard
Every 
\series bold
test case
\series default
 is executed separately, 
\emph on
test case
\emph default
 have common interface (in object based languages presented as common super
 class).
 The run of test should be independent on other 
\emph on
test cases
\emph default
.
\end_layout

\begin_layout Standard

\emph on
Test case
\emph default
 may have 
\series bold
fixtures
\series default
 - methods to set up environment before test and clean up after test.
 These methods are very often called 
\emph on
setup
\emph default
 and 
\emph on
teardown
\emph default
.
 
\emph on
Teardown
\emph default
 method is executed regardless of result of test.
\end_layout

\begin_layout Standard
Expected problem in test is called 
\series bold
failure
\series default
, non anticipated problem is called 
\series bold
error.
\end_layout

\begin_layout Standard
There is 
\series bold
common method of testing
\series default
 if expectations hold.
 In smalltalk by using 
\emph on
should
\emph default
 and 
\emph on
shouldn't
\emph default
 blocks, in 
\begin_inset Quotes eld
\end_inset

modern
\begin_inset Quotes erd
\end_inset

 languages by using 
\emph on
asserts
\emph default
.
 When assertion doesn't hold it is called 
\emph on
failure
\emph default
.
 
\emph on
Errors
\emph default
 are mostly represented by 
\emph on
exceptions
\emph default
.
\end_layout

\begin_layout Standard

\series bold
Result
\series default
 of test is a 
\emph on
result
\emph default
 object.
\end_layout

\begin_layout Standard

\emph on
Test cases
\emph default
 are aggregated to 
\series bold
test suites
\series default
 that can be aggregated too.
 
\end_layout

\begin_layout Standard
All 
\emph on
test cases 
\emph default
in 
\emph on
test suite
\emph default
 are 
\series bold
run recursively
\series default
 by calling 
\emph on
run 
\emph default
on root 
\emph on
test suite
\emph default
.
 Returned value is aggregated 
\emph on
Result
\emph default
 object.
\end_layout

\begin_layout Standard
Unit testing should be 
\series bold
automated
\series default
, independent on human interaction.
\end_layout

\begin_layout Subsection
Other features:
\end_layout

\begin_layout Standard
Many unit testing frameworks offer more 
\series bold
elaborated tests structuring and state handling
\series default
 (
\emph on
fixtures
\emph default
).
 Very often, tests can be aggregated to classes with common setup and teardown
 methods that are run before and after every test.
 
\end_layout

\begin_layout Standard
Moreover there can be 
\series bold
additional
\emph on
 
\emph default
fixture levels
\series default
 for all code units (depending on programing language these can be 
\emph on
class level fixtures
\emph default
, 
\emph on
module level fixtures
\emph default
, 
\emph on
package level fixtures
\emph default
, etc.).
 
\emph on
Setup_
\emph default
 code is run before entering particular block, and 
\emph on
teardown_
\emph default
 code is run after leaving particular block of tests.
 For example setup_class is run before running tests in class and teardown_class
 is run after all tests have run.
 Around every single test may be setup_method and teardown_method fixtures.
 Note that this could break the independency requirement.
\end_layout

\begin_layout Subsection
Best practices:
\end_layout

\begin_layout Standard
Unit testing is mostly used for
\emph on
 
\series bold
\emph default
testing 
\emph on
s
\emph default
mall pieces of code
\series default
\emph on
 
\emph default
and thus use cases are mostly very fast and simple.
\end_layout

\begin_layout Standard
Unit testing is very often used to watch for regressions so all tests should
 be 
\series bold
executed periodically
\series default
 by some automation tool.
\end_layout

\begin_layout Standard
There should be 
\series bold
100% code coverage
\series default
 done by unit tests.
 Every function (method) should have at least one test case, class should
 have test suite as counterpart.
 
\end_layout

\begin_layout Subsection
Implementations:
\end_layout

\begin_layout Standard
There is at least one unit testing framework for every programming language
 (see 
\begin_inset LatexCommand cite
key "xUnit"

\end_inset

 for short list).
 We will focus mainly to these which are C or Python based.
\end_layout

\begin_layout Standard

\series bold
JUnit
\series default
 
\begin_inset LatexCommand cite
key "JUnit"

\end_inset

 is unit testing for java.
 This framework is interesting just by it's author: 
\emph on
Kent Beck
\emph default
, guru of unit testing.
 Has standard features as test level fixtures, assert methods and aggregation.
 In last version (JUnit 4) there were added class level fixtures, timeouts
 for tests, expect exception annotation and requirement of inheriting from
 base class (TestCase) was removed.
 It is not part of standard language distribution.
\end_layout

\begin_layout Standard
Python has 
\series bold
Unittest 
\begin_inset LatexCommand cite
key "unittest"

\end_inset


\series default
 as it's standard (called 
\emph on
PyUnit
\emph default
 
\begin_inset LatexCommand cite
key "PyUnit"

\end_inset

 before integration to python standard distribution).
 The interface is strongly object oriented, test must inherit from TestCase
 class, override specific methods, and assert using defined methods of TestCase.
 Doesn't offer more levels of fixtures.
 It is very pure reimplementation of Kent Beck's original smalltalk framework.
\end_layout

\begin_layout Standard

\series bold
Py.test 
\begin_inset LatexCommand cite
key "PyTest"

\end_inset


\series default
 is alternative python unit testing framework.
 It is part of 
\emph on
py.lib
\emph default
 library 
\begin_inset LatexCommand cite
key "PyLib"

\end_inset

, has fixture support on all levels, doesn't need to inherit from superclass,
 but has fixed naming convention instead.
 Uses standard python assert clause to test for failures, handle exceptions
 as errors.
 Moreover, py.test has automated find-run-collect tool for searching for
 tests in directory trees.
 Test classes can be marked as conditionally 
\emph on
disabled
\emph default
 depending on generic boolean expressions.
 This library has support for generator methods which 
\emph on
allows to yield more
\emph default
 
\emph on
tests
\emph default
 easily.
 Py.test most interesting feature is ease of use.
 It is possible to just write function with 
\emph on
test
\emph default
 in name and 
\emph on
py.test
\emph default
 will collect it, run, and if there is failure or error, the output and
 backtrace will be printed in readable format.
 
\emph on
Py.test
\emph default
 can also take big advantage from 
\emph on
py.lib
\emph default
 which offers distributed execution through 
\emph on
py.execnet
\emph default
 etc.
 Whole 
\emph on
py.lib
\emph default
 is written to be easy to use, but in current implementation with trade
 off configurability.
 Note should be taken, that py.lib was developed as grant project, and after
 grant expiration there were little of improvement in project.
\end_layout

\begin_layout Standard
Another unit testing framework for python is 
\series bold
Nose 
\begin_inset LatexCommand cite
key "Nose"

\end_inset


\series default
.
 Offers backward compatibility to standard 
\emph on
unittest
\emph default
, some compatibility with 
\emph on
py.test
\emph default
 library, and try to mimic 
\emph on
py.test
\emph default
 without magic.
 Nose provides all features of unittest, moreover it implements py.test's
 all level fixtures, tests doesn't need to inherit from superclass, has
 automated find-run-collect tool, and uses generators.
 In addition, Nose is very configurable, it has in build support for changing
 naming conventions, tests can have flags, and it is possible to define
 expressions which tests should be run according to these flags.
 Nose has extensible api with plugin support.
 There are for example plugins for profiling, doctest, code coverage, etc.
 
\end_layout

\begin_layout Standard
Curiosity among unit testing frameworks is 
\series bold
MinUnit
\series default
 
\begin_inset LatexCommand cite
key "MinUnit"

\end_inset

, which is C based, and consist only from three lines of code (two macros
 and one definition).
 Doesn't offer much, just assert - print message block.
\end_layout

\begin_layout Standard

\series bold
CUnit for Dr.Ando
\series default
 
\begin_inset LatexCommand cite
key "CUnitForAndo"

\end_inset

claims to be easy to use C based unit testing framework inspired by 
\emph on
cppunit-x 
\emph default
(Interesting piece of code documented in Japanese).
 In fact, it is just another framework which lacks fixtures and offer just
 test counting beyond 
\emph on
MinUnit.
\end_layout

\begin_layout Standard

\series bold
Simple C++ Testing framework
\series default
 
\begin_inset LatexCommand cite
key "simplectest"

\end_inset

 is written whole as macros, and have somehow weird syntax.
 Offers basic assertions and test suites.
 There is no need to write main function listing all tests, but this is
 achieved by wrapping all tests to macros START_TESTS and END_TESTS.
 So tests must be written in one big chunk.
 Again, tests files must be compiled and run by hand.
 Runs equally in pure C and C++ environment.
\end_layout

\begin_layout Standard

\series bold
CxxTest
\series default
 
\begin_inset LatexCommand cite
key "CxxTest"

\end_inset

 is C++ based, all tests have to be wrapped to test suite Classes.
 This framework has assertions, fixtures, and handle exceptions.
 Automated collection is done by python script (but simplified C++ grammar
 is used).
 May have problems when linking with pure C based code.
 CxxTest have support for mocking global functions, but this support works
 on base of calling functions in separate namespace, so it is not pure mock
 and code have to be modified to use mocked functions.
\end_layout

\begin_layout Standard

\series bold
CppTest 
\series default

\begin_inset LatexCommand cite
key "CppTest"

\end_inset

 is another C++ based unit test framework.
 Has basic features such as assertions, fixtures, and test suites.
 Beyond this, CppTest is capable of handling and formatting output, offers
 api for writing output formatters (TextOutput, CompilerOutput, and HtmlOutput
 formatters implemented).
 As for CxxTest, pure C sources must be modified (add extern C {} block)
 to run under CppTest.
\end_layout

\begin_layout Standard

\series bold
CUnit
\series default
 
\begin_inset LatexCommand cite
key "CUnit"

\end_inset

 is C based (still C++ compatible), supports assertions, suites, test counting,
 has global registry, more user interfaces (for running tests), but has
 no automatic collection and output handling.
\end_layout

\begin_layout Standard

\series bold
GUnit 
\series default

\begin_inset LatexCommand cite
key "gunit"

\end_inset

 is another unit testing framework.
 Uses GTK+ libraries (for almost anything).
 Supports assertions, suites and fixtures, has gnome and hildon (embedded)
 GUI, dedicated logging facility.
 Doesn't offer discovery, however compiles suites as dynamically loadable
 libraries.
\end_layout

\begin_layout Standard

\series bold
RCUnit
\series default
 
\begin_inset LatexCommand cite
key "RCUNIT"

\end_inset

 supports assertions, suites (called modules), fixtures, has own logging
 facility, tests can be disabled.
 RCUnit has defined interface for writing output handlers.
 HTML and plain text handlers are implemented.
\end_layout

\begin_layout Standard

\series bold
Cutee
\series default
 
\begin_inset LatexCommand cite
key "cutee"

\end_inset

 tends to be as simple as possible.
 Thus supports only assertions, no fixtures or suites.
 Tests are collected automatically yet files with tests must be listed in
 Makefile.
\end_layout

\begin_layout Standard

\series bold
Check
\series default
 
\begin_inset LatexCommand cite
key "Check"

\end_inset

 provides assertions, suites, and simple fixtures.
 Forks every test in separate process, can handle timeouts, output can be
 printed in plain text or XML.
 Has no build or collect helpers, adding test is very annoying.
\end_layout

\begin_layout Standard

\series bold
CuTest
\series default
 
\begin_inset LatexCommand cite
key "Cutest"

\end_inset

 from basic features provides assertions and suites.
 Has scripted tool for executable generation.
\end_layout

\begin_layout Section
Logging, tracing
\begin_inset LatexCommand label
name "sub:Logging,-tracing"

\end_inset


\end_layout

\begin_layout Subsection
Models
\end_layout

\begin_layout Standard
When an error is detected in software, developer needs to have as much informati
on about the failure as possible.
 What occurred is nice to know, but in most cases useless without more details
 about circumstances.
 Therefore developers use logging and tracing to get some useful information
 about the particular run.
\end_layout

\begin_layout Standard
By tracing we mean storing information about call sequence in the program,
 by logging we mean saving information about data changes, or notes about
 states of system inserted by developer.
 In most cases these features are provided by one tool.
\end_layout

\begin_layout Standard
The simplest logging tool used is insertion of 
\series bold
direct message prints
\series default
.
 Messages may provide the information needed, but this approach suffers
 by not having centralized control of what has to be printed.
 This leads to excessive logging, in which is hard to find useful information,
 and if we want to avoid this it force us to changing the code on many places.
\end_layout

\begin_layout Standard
So next logical step is to send logging messages (accompanied by importance
 level) to some 
\series bold
centralized facility
\series default
.
 The importance level list is in most cases directly given in advance.
 Providing this it is possible to change the amount of output centrally
 and even redirect messages to distinct places.
\end_layout

\begin_layout Standard
When simple distinction by importance is not enough, then more advanced
 logging facilities come with 
\series bold
tagging of messages
\series default
.
 Tags could be flat or of arbitrary structure.
 This allow better filtering of messages of special types.
 
\end_layout

\begin_layout Standard
Other approach to logging is to have more than one logger.
 In this case the tool has frequently 
\series bold
producer - consumer
\series default
 based architecture and loggers are organized to dynamically created hierarchy.
 This ease goal of having different output locations for different types
 of messages.
 On the other hand, the architecture is not so easy to understand for anybody
 who might contribute to the code.
 Moreover, with more people participating on development, it is nearly impossibl
e to keep the hierarchy of producers and consumers used in application sane.
 
\end_layout

\begin_layout Standard
The last approach to logging and tracing is called 
\series bold
aspect oriented programing
\series default
.
 In this case the logging is not present in code itself, but it is separated
 as independent concern to aspect - logical definition what and where has
 to be logged.
 
\end_layout

\begin_layout Subsection
Pitfalls
\end_layout

\begin_layout Standard
Even if a adequate logging tool is used to debug the software, there can
 arise problems when the tool is used under some automated stress testing.
 The amount of output 
\series bold
logs would eventually grow too big
\series default
 for storage capacity, or at least for the potential reader to deal with.
 So the automation tool should be able to communicate with the logging facility
 and dynamically change the amount of output according to actual needs.
 This must be tuned to throw away the biggest possible portion of unrelated
 logs, but to preserve the crucial information for debugging the failure
 as the failure could be hard to repeat.
\end_layout

\begin_layout Standard
There is one more reason that may be considered for muting logging output.
 The reason is that 
\series bold
logging could slow the application down
\series default
.
 To check how much logging slows down a ordinary application, some measurements
 were done.
 
\end_layout

\begin_layout Standard
For testing was used real application - session server from the SUCKS 
\begin_inset LatexCommand cite
key "SUCKS"

\end_inset

project.
 The session server was threaded and accessible by network.
 Logging facility was simple centralized logger with predefined log levels.
 Logger was alternated so it measures time spent by logging.
 Tests consisted of predefined workload, output was time spent by whole
 application, time spent in logging and characters printed.
 Test cycle was composed of one run of all tests for every log level and
 log target.
 After finishing the cycle starts again.
 This had been running for approximately thirty hours on two platforms:
\end_layout

\begin_layout Enumerate
Intel centrino with core2duo CPU set to static frequency of 1Ghz with 2GB
 memory (most unused) running kernel 2.6.20.1 x86_64.
 
\end_layout

\begin_layout Enumerate
Motorola ppc MPC8241 (177 bogomips) with 128MB memory running kernel 2.4.32
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename logSums.png
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Logging load
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Both platforms behaved equally, the only difference was in speed (and we
 must consider, that Motorola was connected by network and all console prints
 must went through ssh).
 From results we can see that all logging targets had the same footprint
 and the only 
\emph on
slow
\emph default
 target was console write.
 For non-blocking targets, the slowdown was in hundredths of per cent for
 all log levels and the difference between no logging and full logging was
 only one hundredth of per cent.
\end_layout

\begin_layout Standard
So when we don't need to read the output of application online we can log
 everything that fits on storage medium.
 In case of small storage capacity could be used circular buffer which can
 be flushed to file only when error occurred.
 Filtering can be done afterward by user.
 Another finding is, that on non-blocking media, the logging footprint is
 in half made by checks if something has to be logged or not.
 Thus to minimize slowdown, logging must be entirely removed from binary
 in compile time.
 Problem with this is, that it makes changes to binary image, and these
 changes can lead to different behavior of erroneous code, so the bug could
 be unreproducible with different logging level.
\end_layout

\begin_layout Standard
Other problem, which can arise with logging is that logging can act as synchroni
zation primitive, which could prevent some collisions to appear.
 Problem with synchronization can be solved by design of logging facility.
 The logger must be designed in way that creates separated resources for
 every concurrently running entity in advance, and then the only effect
 done by the logger is slowdown upon creation of new 
\emph on
threads
\emph default
.
\end_layout

\begin_layout Section
Presentation layer
\begin_inset LatexCommand label
name "sub:Presentation-layer"

\end_inset


\end_layout

\begin_layout Standard
Usual test run produces outputs of many types, beginning with standard outputs,
 going on with filesystem changes, debug logs, even including state snapshots,
 core dumps, etc.
 These are data of very different types.
 The goal is to present them to user in usable way with structure that can
 be easily understood, and through ways, which are accessible from as much
 environments as possible.
\end_layout

\begin_layout Subsection
Raw data
\end_layout

\begin_layout Standard
The easiest way to present results is to leave them as they are produced
 by application and test suite.
 When this approach is used the raw data are often made available for downloadin
g through simple protocol such as FTP or remote console.
 Raw data hold always full information, don't suffer by any losses from
 transformations.
 On the other hand, raw data are often platform dependent and may have to
 be interpreted on the system that have produced them.
 The data should be in standard format to allow readability by external
 tools.
\end_layout

\begin_layout Subsection
Web interface
\end_layout

\begin_layout Standard
Dynamic web pages are nowadays very used way of presentation, as they are
 relatively easy to write.
 Web pages have big advantage in accessibility - nearly every computer have
 web browser installed and people are used to get information through these.
 On the other hand, web pages can hardly display some debug outputs such
 as core dumps and other binary data.
 In this case data should be downloadable for reading through external tools.
 Interaction with web is little bit slower than with local application and
 user comfort is also worst.
\end_layout

\begin_layout Subsection
Special application
\end_layout

\begin_layout Standard
Even raw data must be interpreted by application to be presented in readable
 form.
 When there aren't appropriate general tools, they should be written as
 part of test suite.
 The fact that they must be written is one big disadvantage by itself.
 Full featured interpreter of debug data with presentation layer may consist
 of the same amount of work as test suite itself.
 Moreover requirements and dependencies of such application could be non-trivial
 and platform independency is hardly to achieve with this approach.
 The big advantage of special application is that as written specially for
 a suite it should fits very well the needs.
\end_layout

\begin_layout Section
Random workload generation
\end_layout

\begin_layout Standard
Random workload for stress testing must be generated from small tests (operation
s, meta tests, atoms).
 Depending on subject tested atoms are either defined by tradition (basic
 operations that can be made on subject tested), or small well defined tests.
 It is sometimes wanted to group some atoms to create new (bigger) atom.
 In ideal case, run of meta test doesn't change state of subject tested.
 But this type of atoms can test only stateless systems and operations which
 are less erroneous, thus not so big candidates for regression testing as
 state-full systems are.
 For state-full systems (and meta tests) there should be method how to define
 and check states and legal transitions.
 Simple method to allow this is to give to tester way to define pre and
 post run hooks that can initialize state, check transition, and possibly
 do cleanup after test.
 While approach with pre and post run hooks is simple yet powerful, there
 is one issue connected to it.
 In this system tester can use state-full tests, but in trade of possible
 waste of resources.
 When test expected some state different that in which system is, it must
 either made a state change (non trivial operation out of test scope) or
 silently pass without testing and let the system run other test.
 More sophisticated system for resolving state-fullness is to give tester
 tool to define allowed transitions between tests.
 Transitions are often given by graph (edges can be allowed transitions
 or tests).
 
\end_layout

\begin_layout Standard
Sometimes it may be desirable to give some preferences (what should be tested).
 For random workload this means either switching meta tests on and off or
 giving preferences in percentage.
 When state-fullness is not solved or solved by pre and post hooks, percentage
 is connected to tests.
 When transitions are used, percentage can be either for tests (implicit
 edges) or for transitions.
\end_layout

\begin_layout Standard
Length of continuous random workload can be simple defined as:
\end_layout

\begin_layout Itemize
number of meta tests (minimum, maximum, mean)
\end_layout

\begin_layout Itemize
time (resources) used
\end_layout

\begin_layout Itemize
by transitions to end point
\end_layout

\begin_layout Standard
When user preferences are given system itself is often simple automata running
 on state-full graph.
\end_layout

\begin_layout Section
Pruning output
\end_layout

\begin_layout Standard
When long test (or random test) fails it could not be clear which step has
 caused the failure.
 So we need test outputs (debugging info) to locate the bug.
 On the other hand output from long and random tests can be huge and most
 of it may be useless.
 The goal of pruning output is to provide enough information to find the
 bug and at the same time hide useless ballast.
\end_layout

\begin_layout Standard
Basically we can divide outputs to developer written log messages, run backtrace
, and system state snapshots (memory dumps, filesystem state, etc).
 
\end_layout

\begin_layout Standard
Data automatically generated is more resources consuming, but as storage
 capacity is cheap, we can simply leave all snapshots or limit space used
 by constant and delete old snapshots.
 On the other hand, we must avoid excessive slowdown (which in case of core
 dumps is non-trivial).
 
\end_layout

\begin_layout Standard
As for logs, the problem was described in 
\begin_inset LatexCommand prettyref
reference "sub:Logging,-tracing"

\end_inset

: when logging doesn't slow application down and doesn't change behavior,
 the best approach is to log all, store all (or last N), and provide tool
 for filtering and searching logs.
 With this approach, we can be sure that no crucial information was lost
 by heuristic pruning.
 In special cases, like low resource platforms (without storage, extremely
 slow, etc), where we can't afford wasting, some heuristic must be used.
 For system state this can be the state in time of failure.
 For logs there can be more approaches which can be divided to 
\end_layout

\begin_layout Itemize

\series bold
on-time pruning
\series default
 - test suite changes log level of application according to probability
 of failure.
 The question is, how it should know.
\end_layout

\begin_layout Itemize

\series bold
afterward
\series default
 - log level is constant for test run, logs are stored to cyclic buffer.
 When failure occurs, test suite will trim the buffer to store just useful
 information.
\end_layout

\begin_layout Itemize

\series bold
re-run
\series default
 - tests are run with logging on minimal level.
 When failure occur, test suite will rerun the test with more logging 
\emph on
around
\emph default
 the failure, possibly skipping some parts of test (as for random generated
 workload).
\end_layout

\begin_layout Section
Checkpointing
\begin_inset LatexCommand label
name "sub:Checkpointing"

\end_inset


\end_layout

\begin_layout Standard
Some failures are hard to reproduce and thus developer wants as much information
 about the faulty run as possible.
 Sometimes logs are not sufficient and state of application in time of failure
 is needed.
 That's why some snapshot creation support might be useful.
 
\end_layout

\begin_layout Standard
Moreover, as the runs to failure could be very long, the test suite may
 try to repeat just short parts of them, or skip some steps to find the
 shortest possible run to bring about the bug.
 For reruns is best, when the second run has the same start conditions.
 The snapshot (checkpoint) can help with it by resuming from stored state
 (if possible).
\end_layout

\begin_layout Standard
There are many projects trying to create full featured checkpoint / resume
 support for applications.
 They can be divided in two groups: user-space only tools and kernel-based
 tools.
 The main problem among them is, that none of them have full support for
 every resource an application could use.
 The most frequently missing features are suspend / resume support for:
 networking, devices, threads, signal handlers, shared memory, shared objects.
 Some of them (BCLR 
\begin_inset LatexCommand cite
key "BLCR"

\end_inset

, CryptoPID 
\begin_inset LatexCommand cite
key "cryptoPID"

\end_inset

, Chpox 
\begin_inset LatexCommand cite
key "chpox"

\end_inset

) seems to have everything needed, but for the price of many constraints
 and dependencies.
 
\end_layout

\begin_layout Standard
Other possibility, which solve the matter of sandbox too, is to use some
 virtualization tool and run application (not necessarily test suite) inside
 virtual machine.
 Nowadays, there is many virtualization tools with support for snapshoting
 (for ex.
 openVZ 
\begin_inset LatexCommand cite
key "openVZ"

\end_inset

, Vmware 
\begin_inset LatexCommand cite
key "Vmware"

\end_inset

, Xen 
\begin_inset LatexCommand cite
key "Xen"

\end_inset

, Qemu 
\begin_inset LatexCommand cite
key "Qemu"

\end_inset

).
 However, working with virtualization is fairly complicated and we can't
 test hardware dependent issues on them.
\end_layout

\begin_layout Standard
The last and easiest possibility is to use just snapshoting without resume
 and save the snapshots in some easy to read format.
 For this we can use for example GDB gcore 
\begin_inset LatexCommand cite
key "gcore"

\end_inset

 command (which creates gdb core dumps) to snapshot the application.
\end_layout

\begin_layout Section
Continuous integration
\end_layout

\begin_layout Standard
Existence of tests is not enough to provide stable development cycle.
 For stability of project it is vital to test it for errors (run tests)
 as often as possible, preferably after each change (commit).
 The approach when changes are often merged into 
\emph on
mainline
\emph default
 is called 
\series bold
Continuous integration
\series default
 (good overview of this method is in 
\begin_inset LatexCommand cite
key "Continuous_integration"

\end_inset

).
 To achieve regular testing, it is convenient to use some tool (server)
 which automates the process.
 There are many proprietary solution and even more opensource solutions.
 It is interesting how many organizations deploy their own systems (for
 example Mozilla Foundation uses Tinderbox 
\begin_inset LatexCommand cite
key "Tinderbox"

\end_inset

, Redhat has Frysk 
\begin_inset LatexCommand cite
key "Frysk"

\end_inset

, ThoughWorks has 
\begin_inset LatexCommand cite
key "Cruise_Control"

\end_inset

.
 Apache foundation has even two projects - Continuum 
\begin_inset LatexCommand cite
key "Continuum"

\end_inset

 and Gump 
\begin_inset LatexCommand cite
key "Gump"

\end_inset

 - that is only from opensource projects).
\end_layout

\begin_layout Subsection
Automation
\end_layout

\begin_layout Standard
Best approach to achieve stable build and check cycle is to automate it.
 Some projects use manually driven systems but there is hazard of human
 failure (developer could omit tests, forgot about them or ignore them at
 all).
\end_layout

\begin_layout Paragraph

\series bold
In common there are two approaches used to achieve automated build and check
\series default
:
\newline

\end_layout

\begin_layout Standard
First is to use some 
\series bold
post
\series default
 
\series bold
commit hooks
\series default
 (we assume that version control system is used) which executes tests or
 launch separate process to execute them on background.
 This approach can ensure that no wrong code gets into repository - commit
 that won't pass all tests can be rejected.
 Running all tests can be relatively long lasting task and therefore environment
 is rarely set to execute all tests before commit.
 Commonly, commit is delayed only after vital tests pass and more in-deep
 checking tests are executed afterward in stand-alone process.
 Implementations of this approach are often bound to one version control
 system.
\end_layout

\begin_layout Standard
Other option is to not check validity in commit hooks, but use 
\series bold
independent service
\series default
 which monitors state of repository and runs tests either for every
\series bold
 
\series default
change (commit),
\series bold
 
\series default
or on regular basis (night builds).
 Benefits of this approach are that it doesn't slow down commits and tools
 using this approach have frequently more features and better configurability.
 These solutions are generally independent on version control system (support
 for distinct version control systems is provided by plugins), but sometimes
 use hooks to get alert upon change.
\end_layout

\begin_layout Paragraph

\series bold
Often this combination is used
\series default
:
\newline

\end_layout

\begin_layout Itemize
pre-commit hooks are used to enforce repository rules and coding conventions
\end_layout

\begin_layout Itemize
separate service builds project (upon commit or nightly) and executes all
 tests checking, if change doesn't break something
\end_layout

\begin_layout Standard
Because one of build steps can be building the source, there should be support
 for
\series bold
 build system
\series default
 used by project.
 Again, many tools are plugin based and have plugins for most common build
 systems used.
 Particular set depends on aim of the tool.
\end_layout

\begin_layout Standard
Pure commit driven environment, when commits are delayed after all tests
 passed doesn't need presentation layer at all, there is just the message
 send to commiter.
 But as this variant is rare, nearly all automation systems have 
\series bold
presentation
\series default
 layer.
 The complexity vary from simple text (HTML) file statically served by web
 server to rich database backed GUI.
 Standard tools offer HTML overview and detail pages, tools bound to specific
 environment usually provide GUI for that environment.
 Very often there are email or instant messaging notifiers too.
 If there are no other output than test count and results, it tends to be
 plain text.
 Sometimes there are output format readable by applications.
\end_layout

\begin_layout Subsection
Distributed testing
\begin_inset LatexCommand label
name "sub:Distributed-testing"

\end_inset


\end_layout

\begin_layout Standard
Testing doesn't need to be run on the same machine as control service.
 When tests doesn't run on the same machine as main continuous server, we
 call it distributed testing.
 
\end_layout

\begin_layout Paragraph
There can be many reasons for distributing:
\newline

\end_layout

\begin_layout Standard
It is crucial do distribute testing for 
\series bold
multiplatform applications
\series default
.
 Wrong code can behave badly only on one of target platforms and therefore
 testing on only one platform can left errors undiscovered.
 In this case distributed testing is the only way to cover specifics of
 all platforms.
 In some cases it is possible to run one separate machine with full build
 and check service for every platform.
 But managing such system is huge overhead and collecting results is non
 trivial too.
\end_layout

\begin_layout Standard
Some tests or projects could be 
\series bold
dangerous
\series default
 to system itself, or the project is part of base system.
 These should run in separation of production system (not to break it) in
 some sort of sandbox.
 One possibility is to run dangerous tests on separated physical machines.
 But this would lead to non-trivial problems with recovery.
 As virtualization is nowadays easy to deploy, the best way (and in case
 of base system parts the only viable way) is to sandbox project tests in
 virtual machine.
 This must be considered as distributed testing too because the communication
 with virtual machine must be done in the same way as if the virtual machine
 were in other network.
 There are in general less security barriers between the host machine and
 guest machine but it don't affect the connection method itself.
 For some special cases there can be one more option how to separate dangerous
 tests without distributing: to use operating system provided tools to restring
 their privileges and resources (for example chroot).
\end_layout

\begin_layout Standard
Another reason for running tests on other machine can be 
\series bold
resource consumption
\series default
.
 As the control system should be visible to wide network (at least the presentat
ion layer) it is frequently run on production server which hosts other applicati
ons too.
 In this case it is not good idea to slow down or even block whole system
 by tests.
 Again, tests are given to another machine to execute.
\end_layout

\begin_layout Standard
Sometimes tests takes long 
\series bold
time
\series default
 to complete.
 Then it is convenient to spread tests over more machines, each running
 only part of tests.
 By this we achieve shorter build and check cycle.
\end_layout

\begin_layout Paragraph
Distribution can be achieved by:
\newline

\end_layout

\begin_layout Standard
Sending commands through 
\series bold
remote terminal
\series default
.
 For example on UNIX data could be copied to target machine by scp, tests
 executed through ssh and results again retrieved through scp.
 This is the easiest way, used in simple cases where no synchronization
 or overview is needed.
 Data in general doesn't need to be delivered through the same way as commands,
 clients can fetch them themselves upon test command, or there can be shared
 network storage where control server should put data for tests.
\end_layout

\begin_layout Standard
Most common way to connect control server with machines executing tests
 (sometimes called slaves or bots) is to use
\series bold
 remote procedure call
\series default
.
 As remote procedure call we mean not only RPC, but any method that allows
 us to call procedures on remote system.
 There are many RPC tools such as RPC, CORBA, dcom, python twisted, py.execnet,
 etc.
\end_layout

\begin_layout Standard
Older systems tends to use 
\series bold
e-mail
\series default
 communication.
 It consists of specially formatted messages sent between master and clients.
 This approach has many drawbacks as security problems, frangibility and
 non-deterministic behavior.
\end_layout

\begin_layout Standard
Sometimes 
\series bold
own methods
\series default
 for communication is used, that mimic remote procedure call by sending
 raw data within special protocol.
\end_layout

\begin_layout Section
Sandboxing
\end_layout

\begin_layout Standard
When tests need more privileges over hosting environment, or the tested
 component itself is part of operating system, there is big probability
 that running tests can broke something.
 In this case they must be executed in so called sandbox.
 It is either part of system with restricted access to some resources, or
 whole separate system.
 
\end_layout

\begin_layout Standard
Obviously there should be possibility to restore previous state of sandbox
 after breakage from test, but when choosing sandboxing method to use other
 requirements must be considered too.
 
\end_layout

\begin_layout Standard
As we described in 
\begin_inset LatexCommand prettyref
reference "sub:Logging,-tracing"

\end_inset

, execution logs are crucial to track failure (bug) found by automated testing.
 Therefore it should be possible to get logs (and other data) from sandbox
 at least after failure, but preferably to send them back to master straight
 upon generation.
 This is mostly feature of logger, but to use it, the sandbox must allow
 communication with outside.
\end_layout

\begin_layout Standard
When testing is distributed (see 
\begin_inset LatexCommand prettyref
reference "sub:Distributed-testing"

\end_inset

), it should be considered to use the remote machine as sandbox too.
 Again, there should be method to easily restore state of whole remote machine
 after breakage from test.
 Note that this would be problematic with real (non-virtualized) hosts.
\end_layout

\begin_layout Standard
In 
\begin_inset LatexCommand prettyref
reference "sub:Checkpointing"

\end_inset

 we have analyzed problem of providing information about test state to developer.
 If sandbox is represented by full operating system, then checkpointing
 of whole sandbox would be in most cases big overhead.
 Still it should be taken into account in some cases.
 One case where sandbox snapshots may be convenient is when test depends
 heavily on system state or changes system state.
 Then without system snapshot some information to track failure may be missing.
 Other case when full snapshots may be generated is when test has caused
 system failure (therefore normal snapshots can't be created).
\end_layout

\begin_layout Section
Filesystem test patterns
\end_layout

\begin_layout Subsection
FSX
\begin_inset LatexCommand label
name "sub:FSX"

\end_inset


\end_layout

\begin_layout Standard
Originally written by Avadis Tevanian, Jr.
 for Apple Computer, Inc.
 and BSD-style operating systems.
 Nowadays, there are more versions used, but the main part stay the same
 
\begin_inset LatexCommand cite
key "FSX"

\end_inset

.
\end_layout

\begin_layout Standard
Test consists of single source file written in C, compatible with most Unix
 based operating systems.
 Test operates on one file, does loop with random operation in every cycle
 - one of read, write, truncate, close and open, map read and map write.
 Memory mapped operations can be disabled.
 Checks in FSX are made by comparison of write buffer and data read, additional
 checks of file size are made too.
 Failure report from FSX is dump of operation sequence and buffer dump.
\end_layout

\begin_layout Subsection
LTP
\end_layout

\begin_layout Standard
Linux testing project 
\begin_inset LatexCommand cite
key "LTP"

\end_inset

 is collection of test suites for Linux operating system internals.
 Tests are compiled programs or scripts, driving is done by control script.
 The part dedicated to filesystems contains previously mentioned FSX (
\begin_inset LatexCommand prettyref
reference "sub:FSX"

\end_inset

) and own filesystem testing binaries.
 Checking is mostly done by comparison between results and expected values.
 There are both types of tests: predefined loops with random arguments (file
 sizes, etc) and stress tests consisting of random sequences of operations.
 No cleanup is provided.
 Failure log contains only arguments to last tests.
 There is vast amount of operations implemented.
\end_layout

\begin_layout Subsection
Mongo
\end_layout

\begin_layout Standard
Mongo benchmark 
\begin_inset LatexCommand cite
key "Mongo"

\end_inset

 is test program written in Perl, aimed to Linux filesystem performance
 and functionality testing (developed by reiserfs team).
 Is very tightly coupled with standard tools and filesystem usage.
 Does everything from mkfs, through mount to classic operations.
 The version examined was mainly benchmarking tool, there were no checks
 if things goes well, just if they goes.
\end_layout

\begin_layout Subsection
OpenSolaris ZFS / NFSv4 Test Suite
\end_layout

\begin_layout Standard
Very exhaustive test suite for filesystems on OpenSolaris 
\begin_inset LatexCommand cite
key "OpenSolarisZFS"

\end_inset

.
 There is two sets of tests: one for NFSv4 and one for ZFS, but the techniques
 used in them are the same.
 Just ZFS test suite have extra stress tests.
\end_layout

\begin_layout Standard
System is Makefile driven with default targets, tests are generally shell
 scripts (ksh) with few compiled support programs and tests.
 Testing is deterministic, cleanup is done after set of tests (directory).
 Errors are printed to stderr.
 
\end_layout

\begin_layout Standard
What should be noted is the coverage of these tests, there are tests for
 nearly every operation possible, even for zones, ACL or redundancy.
 In ZFS part, there are simple stress tests too - predefined loops with
 configurable length.
\end_layout

\begin_layout Chapter
The test suite architecture
\end_layout

\begin_layout Section
Programming language
\end_layout

\begin_layout Standard
Since ZlomekFS tends to be multiplatform and support more operating systems
 (currently only Linux is supported), language which runs on any platform
 (or at least under UNIX-like operating systems) is needed.
 For testing, the language should be flexible enough, but on other hand
 since file system will be tested, speed must be considered too.
 Last but not least need is that the language should allow integration with
 existing code.
\end_layout

\begin_layout Standard
Because of this criteria 
\series bold
python 
\series default

\begin_inset LatexCommand cite
key "Python"

\end_inset

 was chosen as main programing language for driving component.
 Python can integrate with most compiled languages and thus not all components
 must be written in python.
 Performance critical parts and integration libraries can be written in
 ZlomekFS native language - 
\series bold
C
\series default
.
\end_layout

\begin_layout Section
Used tools
\end_layout

\begin_layout Subsection

\series bold
Testing environment
\end_layout

\begin_layout Standard
For very specific purpose of testing distributed file system, no suitable
 existing solution was found.
 Instead of development of new system, it was decided to tweak existing
 tool (if possible) to fit the needs.
 From general purpose testing tools written in python 
\series bold
Nose
\series default
 
\begin_inset LatexCommand cite
key "Nose"

\end_inset

 was considered as the most suitable.
 Moreover every feature needed which Nose doesn't implement can be delivered
 as plugin without modifying Nose core code.
 Nose plugin architecture was found as flexible enough for further extending
 of the test suite too.
\end_layout

\begin_layout Subsection
Continuous integration
\end_layout

\begin_layout Standard
When choosing tools for continuous integration, only opensource projects
 with reliable community around it were considered.
\end_layout

\begin_layout Standard

\series bold
Buildbot
\series default
 
\begin_inset LatexCommand cite
key "BuildBot"

\end_inset

 was chosen as continuous integration server.
 
\end_layout

\begin_layout Paragraph
It was chosen for these reasons:
\end_layout

\begin_layout Itemize
Compatibility with ZlomekFS build system.
 Buildbot can use shell commands and python code as build steps.
 It can do output parsing for configure, make and gcc output too.
\end_layout

\begin_layout Itemize
It is small and easy to deploy.
 There is no need to write big XML configuration files to run 
\emph on
hello world
\emph default
, buildbot code is relatively small and easy to read.
 In comparison with others, buildbot has around 500K, where build of CruiseContr
ol can take more than 500M.
\end_layout

\begin_layout Itemize
Written in python.
 Since whole Buildbot is written in python, we can easily integrate it with
 other tools used in project (as they are written in python too).
\end_layout

\begin_layout Itemize
Extendable architecture.
 Buildbot parts are written as objects, so it is possible to inherit from
 them and tweak behavior according our needs.
\end_layout

\begin_layout Itemize
Support for distributed testing.
 As ZlomekFS is intended to run on multiple architectures (and in future
 possibly on multiple operating systems) the support for distributed testing
 is essential.
\end_layout

\begin_layout Itemize
Active development.
 Buildbot is often used and has active community which ensures that it will
 be maintained in future too.
\end_layout

\begin_layout Subsection
Web result presentation and result repository
\end_layout

\begin_layout Standard
Test results in buildbot are presented as textual output from commands.
 This is not enough from two reasons: when failure or error is found, the
 textual output may be messy (yet useful in some cases).
 Bigger problem is, that it can't provide enough information, and binary
 data can't be provided in this way at all.
\end_layout

\begin_layout Standard
So there was need for another way to represent test results.
 Since test outputs can contain binary data (snapshots, core dumps, filesystem
 state, etc), the presentation layer should be able to distinguish several
 types of data and present them according to type.
 As data and information for test run are related to each other, database
 driven storage was preferred.
 
\end_layout

\begin_layout Standard
The solution used was 
\series bold
Django 
\series default

\begin_inset LatexCommand cite
key "Django"

\end_inset

.
 It is written in python, offers object oriented database abstraction layer,
 web pages generating tools.
 It's configuration format is pure python, so it is easy to integrate it
 with other parts of project.
\end_layout

\begin_layout Subsection
Logging
\end_layout

\begin_layout Paragraph
We need logger with this features:
\newline

\end_layout

\begin_layout Itemize
it can be controlled externally
\end_layout

\begin_layout Itemize
it has simple still full featured interface
\end_layout

\begin_layout Itemize
it has to have implementations in both languages (python and C)
\end_layout

\begin_layout Itemize
the output has to be in parseable and user readable format
\end_layout

\begin_layout Standard
This enforces us to write 
\series bold
new logger
\series default
, which suits best the needs.
 From models, we can't use aspect oriented logging, as there is no implementatio
n of aspects for both languages (and moreover it will be big requirement
 for developers to learn aspects).
 The producer-consumer model seems to be too complicated as there will be
 large and non-homogeneous group of developers working on ZlomekFS.
\end_layout

\begin_layout Standard
Thus the logger will be centralized, supporting tagging with fast evaluation.
 The output will be redirectable to shared resource (shared memory, network
 socket) which can be used and controlled by test suite.
 The format of written log for failure may be preferably readable by some
 GUI or web based reader such as Chainsaw 
\begin_inset LatexCommand cite
key "Chainsaw"

\end_inset

, if not possible, user readable output should be used.
\end_layout

\begin_layout Subsection
C based unit testing
\end_layout

\begin_layout Standard
All existing C based unit testing tools have one of two major problems (or
 both).
 
\end_layout

\begin_layout Itemize
Many tools are very complicated and writing simple test for 
\begin_inset Quotes eld
\end_inset

a + b
\begin_inset Quotes erd
\end_inset

 could take five minutes.
 
\end_layout

\begin_layout Itemize
No one of C based unit testing tools have automatic test discovery.
 Thus tests must be listed somewhere and collected manually (even in case
 of hierarchies).
 The best is heuristic search by grep.
\end_layout

\begin_layout Standard
Since external are non-trivial for integration to project and writing of
 simple C based unit testing is relatively easy, new C based unit testing
 library was implemented.
\end_layout

\begin_layout Subsection
Documentation
\end_layout

\begin_layout Standard
For documenting C code 
\series bold
DoxyGen
\series default
 
\begin_inset LatexCommand cite
key "Doxygen"

\end_inset

 was chosen.
 Main argument was that ZlomekFS is documented in DoxyGen.
 Secondary, DoxyGen is nowadays nearly standard tool for documenting C code.
\end_layout

\begin_layout Standard
For Python code, DoxyGen has some support, but the support is problematic,
 needs usage of impute filters such as Doxypy 
\begin_inset LatexCommand cite
key "Doxypy"

\end_inset

, and even then results are not ideal.
 
\end_layout

\begin_layout Standard
There is standard docstring format for python 
\begin_inset LatexCommand cite
key "PEP257"

\end_inset

, but it doesn't support more than plain-text formatting.
 
\end_layout

\begin_layout Standard
Another option is to use some non-standard documentation tools for python
 (most of them are listed in PEP256 
\begin_inset LatexCommand cite
key "PEP256"

\end_inset

).
 Their problems are mainly listed in mentioned PEP256.
\end_layout

\begin_layout Standard
Finally, 
\series bold
reStructuredText Docstring Format
\series default
 
\begin_inset LatexCommand cite
key "PEP258,reStructuredText"

\end_inset

 was chosen.
 Main reason was that Nose 
\begin_inset LatexCommand cite
key "Nose"

\end_inset

 uses this format, secondary reStructuredText is easy readable in 
\series bold
Pydoc 
\begin_inset LatexCommand cite
key "Pydoc"

\end_inset


\series default
 output and there are HTML formatting tools too.
\end_layout

\begin_layout Chapter
Implementation details
\end_layout

\begin_layout Section
ZlomekFS changes
\end_layout

\begin_layout Subsection
Logging
\end_layout

\begin_layout Standard
Original message printing system (two levels, hardcoded values) was replaced
 with 
\series bold
new logger
\series default
 (
\emph on
Syplog
\emph default
) developed specially for ZlomekFS.
 
\end_layout

\begin_layout Standard
Logger supports eleven 
\series bold
log levels
\series default
.
 Log level is 32bit unsigned integer (typedef), log levels are defined by
 macro constants (from LOG_EMERG to LOG_LOOPS).
 There is conversion function available to convert log levels to user-readable
 strings.
\end_layout

\begin_layout Standard
For concern separation, logger distinguishes 
\series bold
facilities
\series default
.
 Facilities are distinct one-bit flags which can be OR-ed.
 Log message can be labeled as belonging to any number of facilities.
 Again, there is conversion function to convert facilities to user-readable
 strings.
\end_layout

\begin_layout Standard
Log levels and facilities can be used to 
\series bold
filter
\series default
 what types of messages (of which importance) should be recorded and what
 should be discarded.
 Both log level and facility filtering set can be altered in run-time.
\end_layout

\begin_layout Standard

\series bold
Output
\series default
 from logger can be written to file or shared memory, api is open for extension
 such as socket write.
 Format of output files can be user readable strings or raw memory dumps.
 For all formats and output targets, there is both writer and reader support,
 so transformation between formats is trivial.
\end_layout

\begin_layout Standard

\series bold
Settings
\series default
 is read from program arguments (array of string with given array size).
 Logger ignores unknown options, so direct configuration from command line
 is possible (and currently used).
\end_layout

\begin_layout Standard

\series bold
Integration
\series default
 with external driving component (Nose testing environment) is done through
 
\series bold
D-bus
\series default
 control api.
 Both log level and facility set is adjustable through D-bus.
 For further integration there is full-featured python wrapper for syplog
 generated by swig.
\end_layout

\begin_layout Standard
Log level and facility sets can be 
\series bold
extended
\series default
 by listing constants for new log levels and facilities in header files.
 Output formats and targets are defined by static structures holding pointers
 to functions with specified behavior.
 New formats and targets can be provided by implementing given function
 set and providing description structure.
 For further reference please read DoxyGen documentation of
\emph on
 Syplog
\emph default
 library.
\end_layout

\begin_layout Subsection
Control component
\end_layout

\begin_layout Standard
The driving component needs to know in which state ZlomekFS daemon is (starting,
 running, terminating).
 To accommodate this need 
\series bold
D-bus
\series default
 listener was added to zfsd.
\end_layout

\begin_layout Paragraph
The D-bus component of ZlomekFS consists of two parts:
\end_layout

\begin_layout Itemize
D-bus 
\series bold
provider
\series default
 - state-full service which manages initialization of D-bus, listening loop
 and termination of D-bus connection.
 Doesn't serve messages.
\end_layout

\begin_layout Itemize
D-bus 
\series bold
message handlers
\series default
.
 Set of functions describing zfsd specifics - naming and signal handlers.
\end_layout

\begin_layout Standard

\series bold
Integration
\series default
 of this two components with zfsd daemon is following: On beginning, zfsd
 creates and initializes D-bus provider handler (structure).
 Then, it registers zfsd D-bus message handlers by calling 
\emph on
dbus_provider_add_listener
\emph default
.
 Currently, the syplog D-bus service is implemented in way compatible with
 zfsd D-bus provider.
 Thus another 
\emph on
dbus_provider_add_listener
\emph default
 is called for syplog service.
 After all needed listeners are registered, zfsd calls 
\emph on
dbus_provider_start
\emph default
.
 This starts new thread which listens for messages and forwards them to
 registered handlers.
 Finally, when zfsd is terminating, 
\emph on
dbus_provider_end 
\emph default
is called.
\end_layout

\begin_layout Standard
For future there are plans for
\series bold
 remote zfsd control
\series default
 mechanism.
 Main intention of it should be to allow user initiated synchronizations,
 mode changes (slow connection, fast connection), etc.
 These should be implemented either as another set of message handlers or
 by extending current zfsd message handler.
\end_layout

\begin_layout Standard
As the test driving component is written in python, there is 
\series bold
python client module
\series default
 for this api too.
 Client module is automatically generated by swig, so there should not be
 problems upon extending the service.
\end_layout

\begin_layout Section
Testing environment
\end_layout

\begin_layout Standard
To allow central result repository, all tests should be executed under 
\series bold
Nose
\series default
.
 Settings for plugins can be given by command line options, but preferred
 way is to store them as 
\series bold
environment variable
\series default
s.
 Environment variables are used to pass values between components too.
 This way is used to ensure all tests within one BatchRun will be reported
 properly.
 To ease repeated runs with the same configuration, support for 
\series bold
profiles
\series default
 is implemented.
 If environment variable 
\emph on
PROFILE_NAME
\emph default
 is found, system will try to load module with given name and read environment
 variables from it.
 
\end_layout

\begin_layout Standard
If 
\series bold
zfsReportPlugin 
\series default
is enabled, results are reported to Django driven 
\series bold
TestResultStorage
\series default
.
 Settings for it is read from module which name is in environment variable
\series bold
\emph on
 
\series default
DJANGO_SETTINGS_MODULE.

\emph default
 Default place for it is 
\emph on
TestResultStorage.settings
\emph default
 (on most systems in 
\emph on
/usr/lib/python/site-packages/TestResultStorage/settings.py
\emph default
).
\end_layout

\begin_layout Subsection
ZfsTest
\end_layout

\begin_layout Standard

\emph on
Zfsd
\emph default
 control from python is implemented in 
\emph on
ZfsProxy
\emph default
.
 This class provides methods for starting zfsd, status queries, 
\emph on
syplog
\emph default
 control, sane zfsd terminating and locked daemon killing.
 
\end_layout

\begin_layout Standard
Normal 
\series bold
ZlomekFS tests
\series default
 should inherit from class 
\emph on
ZfsTest
\emph default
 which implements basic fixtures for zfs.
 New filesystem daemon is started for every test to run.
\end_layout

\begin_layout Standard

\series bold
Stress test
\series default
 classes listing meta tests should inherit from class 
\emph on
ZfsStressTest
\emph default
 which runs all tests on single instance of zfsd.
\end_layout

\begin_layout Standard
TODO: WOODOO
\end_layout

\begin_layout Standard
multi-thread
\end_layout

\begin_layout Standard
distributed
\end_layout

\begin_layout Standard
infinite
\end_layout

\begin_layout Subsection
Failure state data
\end_layout

\begin_layout Standard

\emph on
ZfsProxy
\emph default
 class sets environment for zfsd to create core dump upon crash.
 If crash is recognized, this core dump is collected and appended to snapshot.
 If zfsd is running while snapshot is created, core dump of running process
 is created instead.
\end_layout

\begin_layout Standard
When test fails or error is detected, 
\series bold
snapshotPlugin
\series default
 creates snapshot of predefined components.
 Snapshot plugin can be configured to create snapshots before tests and
 after successful tests too, but while zfsd core dump has more than 150Mb
 it takes non-trivial amount of time to create it (and thus it is disabled
 by default).
\end_layout

\begin_layout Paragraph
By default snapshot will consists of:
\end_layout

\begin_layout Itemize
snapshot of zfs cache (filesystem)
\end_layout

\begin_layout Itemize
snapshot of filesystem to which comparisons are made
\end_layout

\begin_layout Itemize
zfsd log output
\end_layout

\begin_layout Itemize
test instance
\end_layout

\begin_layout Itemize
ZfsProxy instance
\end_layout

\begin_layout Itemize
zfsd core dump
\end_layout

\begin_layout Itemize
python exception and backtrace (if any)
\end_layout

\begin_layout Standard
Developer can specify any 
\series bold
further data
\series default
 to include to snapshots by overriding 
\emph on
snapshot
\series bold
 
\series default
\emph default
method of test class.
 Method gets 
\emph on
SnapshotDescription
\emph default
 instance as argument.
 
\emph on
SnapshotDescriptio
\emph default
n has methods for appending primitive types, python objects, files and directori
es.
 Every entry in snapshot have unique name, type and description.
 Primitive types are stored in memory, bigger data on disk.
 For purpose of reporting snapshot can be packed into single file which
 contains both data and their descriptions.
 For further reference see python documentation for 
\emph on
insecticide/snapshot.py
\end_layout

\begin_layout Subsection
Reporting and result repository
\end_layout

\begin_layout Standard
Test results are stored in 
\series bold
MySQL database
\series default
 to which access is provided through 
\series bold
django
\series default
 api.
 Settings are stored in 
\emph on
TestResultStorage/settings.py
\emph default
 and should be synchronized between master and any slave reporting to master.
\end_layout

\begin_layout Standard
Small data (textual information, return codes, etc) are stored in database.
 Big data such as snapshots are stored on disk.
 Every file has to have entry in database where it's relation to test run
 is stored.
 
\series bold
File transfer
\series default
 between slave and master must be handled externally.
 Preferred method how to handle this is to map storage directory (for example
 /var/lib/TestResultStorage/data) between master and slave by NFS (in case
 of separate hosts) or by method provided by virtualization software (if
 master and slave are virtualized on the same machine).
\end_layout

\begin_layout Standard
Django stores objects as rows in 
\series bold
tables
\series default
, one table for one class (plus some index and many-to-many relation tables).
 We use 
\emph on
TestRun
\emph default
 class for information about one run of single test, 
\emph on
TestRunData
\emph default
 class to hold auxiliary information for (mostly failed) tests - backtraces,
 exceptions, file names of snapshots.
 Set of TestRuns that were executed together are connected by 
\emph on
BatchRun
\emph default
 object which holds common attributes such as machine that executes tests,
 branch, revision and profile.
 Projects and profile information are represented as foreign key to tables
 
\emph on
Project
\emph default
 and 
\emph on
ProfileInfo
\emph default
 because they repeats a lot.
\end_layout

\begin_layout Standard
In 
\series bold
Nose,
\series default
 reporting of test results is wrapped in 
\series bold
ReportProxy
\series default
 class which holds BatchRun information, generates and commits TestRun objects
 into database.
 Nose integration is done by 
\series bold
zfsReportPlugin
\series default
.
 This plugin implements 
\emph on
startTest
\emph default
 hook for test duration measurements, 
\emph on
addFailure
\emph default
, 
\emph on
addError
\emph default
 and 
\emph on
addSuccess
\emph default
 hooks to catch and report test results.
 When there is a unhandled system error (python Exception), it is caught
 by outer try-except block and reported to database too.
\end_layout

\begin_layout Standard
Result repository has dynamic 
\series bold
web interface
\series default
 which consists of tests and batches listing pages (with simple filtering
 options), detail pages for test run and batch run and project list page.
 If snapshot is available for test run, it can be downloaded from test run
 detail page.
 Older results can be deleted from administration interface.
\end_layout

\begin_layout Subsection
Options
\end_layout

\begin_layout Standard
Test sets can be 
\series bold
filtered
\series default
 in three ways:
\end_layout

\begin_layout Itemize
by passing 
\series bold
list of files
\series default
 (modules, classes, tests), that should be run (disables search)
\end_layout

\begin_layout Itemize
by 
\series bold
nose.attrib
\series default
 plugin.
 User can define expression, that must evaluate to True for given test attribute
s.
 For example expression '
\emph on
not disabled
\emph default
' will discard tests where 
\emph on
test.disabled
\emph default
 evaluates to True.
 Test loaded from saved path bypasses this filtering.
\end_layout

\begin_layout Itemize
by 
\series bold
name regular expressions
\series default
.
 By default, test name must match regular expression 
\emph on
(?:^|[
\backslash

\backslash
b_
\backslash

\backslash
./-])[Tt]est)
\emph default
 to be executed
\emph on
.
 
\emph default
But this expression is configurable through 
\emph on
NOSE_TESTMATCH
\emph default
 environment variable.
\end_layout

\begin_layout Standard

\series bold
ZfsConfig 
\series default
plugin provides user-definable configuration files straight to tests.
 List of configuration files (in defined format) can be passed to plugin.
 Plugin will read them, convert to python object, and pass this object to
 all tests.
\end_layout

\begin_layout Standard
To handle 
\series bold
deadlocks 
\series default
and infinite loops both in zfsd and malformed tests, there is 
\series bold
\emph on
timed
\emph default
 decorator
\series default
, by which timeout for test can be set and handler function to execute when
 time runs out.Current implementation of handler will send SIGABRT to zfsd
 causing termination with core dump generated.
\end_layout

\begin_layout Subsection
Random workload generation
\end_layout

\begin_layout Standard
Generation of random workload to file system (stress tests) is done by 
\series bold
zfsStressGenerator 
\series default
plugin.
 User must define so called 
\emph on
meta-tests
\emph default
, basic operations, from which workload will consists.
 Random workload is generated by graph walk.
 By default, full graph with even edge scores will be used, but user can
 define dependency graph by himself.
\end_layout

\begin_layout Standard

\series bold
Format
\series default
 for meta-test is identical with normal test, meta-tests intended to be
 used together must be listed in one test class (as python has multiple
 inheritance allowed, this should not be problem).
 
\end_layout

\begin_layout Standard
If there are 
\series bold
dependencies between tests
\series default
 (such as that open test should run before read test), they can be defined
 by graph.
 Graph format is python dictionary, where key is meta-test name and value
 is list of oriented edges originating in the meta-test.
 Edge is defined by target meta-test name and by edge score.
 Score is arbitrary positive number, bigger number means bigger probability
 to use that edge.
\end_layout

\begin_layout Standard
Meta-test chain will be terminated, if meta-test with no successor is hit
 or there can be defined terminating probability.
 Hard 
\series bold
length
\series default
 
\series bold
limit 
\series default
of meta-test chain can be defined by plugin option.
\end_layout

\begin_layout Standard
If stress test fails, the path which causes failure is saved into file for
 further usage.
 By default, 
\series bold
saved paths
\series default
 aren't committed into repository, but it can be specified to do so.
 ZfsStressGenerator plugin can try to
\series bold
 strip failed tests
\series default
 to see, if shorter test sequence would cause failure too.
 Actual algorithm to strip sequences is shortest path between first meta-test
 and the failing meta-test.
\end_layout

\begin_layout Subsection
Extendability
\end_layout

\begin_layout Standard
Extending tests should be pretty straightforward.
 As python is object oriented language, inheritance should be used.
 
\end_layout

\begin_layout Standard
If new features are needed on the level of driving component (Nose), they
 should be delivered as new plugins.
 Plugins are nearly independent, but the ordering of their execution should
 be preserved.
 Execution order is given by 
\emph on
score
\emph default
 attribute ascending.
 See 
\begin_inset LatexCommand cite
key "Nose"

\end_inset

 for further information.
\end_layout

\begin_layout Section
C test
\end_layout

\begin_layout Standard
For unit testing of C source code 
\series bold
Zen-unit
\series default
 library was developed.
 
\end_layout

\begin_layout Standard
Library has very minimalistic api consisting of single file with four defines:
\end_layout

\begin_layout Enumerate

\series bold
ZEN_TEST
\series default
 macro used to declare test header
\end_layout

\begin_layout Enumerate

\series bold
ZEN_ASSERT
\series default
 to test conditions in tests
\end_layout

\begin_layout Enumerate

\series bold
PASS
\series default
 which is value that should be returned from passing tests.
\end_layout

\begin_layout Enumerate

\series bold
FAIL
\series default
 which is value that should be returned from failing tests.
 Where 
\emph on
FAIL
\emph default
 is recommended return value, but any test returning value different from
 
\emph on
PASS
\emph default
 is considered as failed.
\end_layout

\begin_layout Standard
Searching for tests is made using libelf, tests are looked for in dyntab
 and symtab of binary and all libraries linked to it.
 Shared libraries can be tested by linking through 
\emph on
LD_PRELOAD
\emph default
 to 
\emph on
zentest
\emph default
 binary.
\end_layout

\begin_layout Standard
There were more options to use for test collection:
\end_layout

\begin_layout Itemize
To use user listed tests in some type of #ifdef declared main.
 This doesn't remove the need of listing and moreover creates some difficulties
 in main source file.
\end_layout

\begin_layout Itemize
To use full C grammar to search for tests in source files and to generate
 main file.
 This remove need of listing tests, but requires full C parser.
\end_layout

\begin_layout Itemize
To use some C preprocessor to generate simply parseable overview (XML) and
 generate test list from them.
 This possibility was not fully explored but was considered far more complicated
 that binary format based discovery.
\end_layout

\begin_layout Standard
For integration with nose, we use parsing of test output.
 We have considered generation of test lists or test libraries (through
 swig), but we found it as redundant overhead.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Build system
\end_layout

\begin_layout Standard
Original ZlomekFS build system (make) was switched to 
\series bold
automake
\series default
 due to problems with library directories (lib vs lib64) on 64bit systems.
 Hence for C based components 
\series bold
autoconf
\series default
, 
\series bold
automake
\series default
 and 
\series bold
libtool
\series default
 are used, for python based components 
\series bold
setuptools
\series default
 are used (with make wrapper for better compatibility with other tools).
\end_layout

\begin_layout Standard
Target audience of both ZlomekFS and regression testing framework uses mainly
 
\series bold
Redhat
\series default
 or 
\series bold
Fedora
\series default
 based systems.
 To ease installation and upgrades, it was decided to provide automatic
 build targets for 
\series bold
RPM
\series default
 packages.
 For other systems, .tar.gz source packages can be generated.
\end_layout

\begin_layout Subsection
Standard targets
\end_layout

\begin_layout Standard
All components understand following make targets:
\end_layout

\begin_layout Itemize
all - build all binaries and libraries
\end_layout

\begin_layout Itemize
doc - build documentation
\end_layout

\begin_layout Itemize
dist - build .tar.gz source package
\end_layout

\begin_layout Itemize
rpm - build all available rpm packages (source, doc, binary)
\end_layout

\begin_layout Itemize
clean - remove generated data
\end_layout

\begin_layout Itemize
test - run available tests
\end_layout

\begin_layout Section
Buildbot configuration
\end_layout

\begin_layout Standard
Buildbot is configured to create builder for every component on every host.
 Thanks to build system unification, build step sequence is equal for all
 components: it goes update - build - test - make rpm - install - upload.
 
\end_layout

\begin_layout Standard
Change source is SVN polling, schedulers are configured to wait some time
 after change before builder is run.
 
\end_layout

\begin_layout Standard
Test driving (Nose) was included in way, that doesn't need external configuratio
n, only django needs to have 
\emph on
DJANGO_SETTINGS_MODULE
\emph default
 present in environment, so it is exported in start time of buildbot.
\end_layout

\begin_layout Section
Typical call sequence
\end_layout

\begin_layout Standard
When testing is invoked (through buildbot or manually by 
\emph on
make test
\emph default
), the cooperation and calls between components are as follows.
\end_layout

\begin_layout Standard
First component used is 
\series bold
nose wrapper
\series default
, which loads 
\series bold
profile
\series default
, creates 
\series bold
BatchRun
\series default
 object and commits it to TestResultRepository.
 Then, control is passed to nose (environment and command line options are
 preserved).
 
\end_layout

\begin_layout Standard

\series bold
Nose
\series default
 parses environment and command line options and 
\series bold
configure enabled plugins
\series default
 according to them.
 Here is initialization phase of 
\emph on
SnapshotPlugin
\emph default
, 
\emph on
ZfsConfig
\emph default
 plugin, 
\emph on
ZfsStressGenerator
\emph default
, 
\emph on
ZfsReportPlugin
\emph default
 executed.
 ZfsConfig plugin tries to load configuration files for tests, that contains
 for example paths for zfsd and zfsd configuration.
 SnapshotPlugin ensure, that required directories exists.
 ZfsReportPlugin calls TestResultRepository fetching previously created
 object of BatchRun.
\end_layout

\begin_layout Standard
After initialization phase, nose will 
\series bold
search for tests
\series default
.
 Standard tests are handled directly by nose, plugins are not involved in
 this process.
 When file with meta class is found (or directly passed), 
\emph on
ZfsStressGenerator
\emph default
 will load all tests from it to cache and block their normal execution.
 The same is done for saved path files.
 If binary file (or library) is found, 
\emph on
ZenPlugin
\emph default
 will try to execute it as 
\emph on
zen test suite
\emph default
 - that means executing it with LD_PRELOAD of libzenunit.so.
 Then output is parsed and if there were test run, ZenPlugin will create
 report for it.
\end_layout

\begin_layout Standard
Before execution of tests begins, ZfsStressGenerator will appends ContextSuite
 containing 
\series bold
stress tests
\series default
 into main ContextSuite of nose.
\end_layout

\begin_layout Standard
Then, execution phase is reached.
 For every ContextSuite (TestCase) it's 
\series bold
context
\series default
 
\series bold
is initialized
\series default
.
 In initialization, 
\emph on
ZfsConfig
\emph default
 plugin passes 
\series bold
ConfigParser
\series default
 object (representation of config files) to test.
 In case of classic (non stress) tests, initialization of zfsd is made in
 setup and teardown methods in scope of method, in case of stress tests,
 initialization of zfsd is made in setupClass and teardownClass - methods
 in scope of class fixtures.
 In setup and teardown methods of stress test, there is only check, if zfsd
 is still running and if not, execution is raised.
\end_layout

\begin_layout Standard

\series bold
Initialization of zfsd
\series default
 is encapsulated into 
\emph on
ZfsProxy
\emph default
 object, consists of: unpacking configuration, reading configuration and
 fork of actual zfsd (passing given parameters).
 After fork, there is wait loop where proxy object tries to connect to zfsd
 through d-bus, and check if it have started correctly.
 Eventually, when something goes wrong, exception is raised.
\end_layout

\begin_layout Standard
In next phase, 
\series bold
tests are executed
\series default
.
 Each test is considered as passing if there is no exception raised.
 There are two types of exceptions distinguished.
 If the exception is of type 
\emph on
AssertionException
\emph default
 (raised by assert clause), test is considered as failed.
 
\emph on
Other exceptions
\emph default
 are handled as not-expected, thus error is reported.
 Tests can modify zfsd behavior by calls on 
\emph on
ZfsProxy
\emph default
 instance, for example there is possibility to change log level or facility
 set (this can be convenient in tests of special scope - if test is aimed
 to locking problems, it can constrain log messages to threading related
 only).
\end_layout

\begin_layout Standard
If failure or error is detected, 
\emph on
SnapshotPlugin
\emph default
 will 
\series bold
create snapshot
\series default
 of failed test, where arbitrary data defined by developer are appended
 in test class 
\emph on
snapshot
\emph default
 method.
 In current implementation of 
\emph on
ZfsTest
\emph default
 class, it means test object, test data, 
\emph on
ZfsProxy
\emph default
 object, zfsd 
\emph on
log file
\emph default
, zfsd 
\emph on
core dump
\emph default
, zfs 
\emph on
cache directory
\emph default
, in case of comparing tests the directory on compare filesystem.
 In case of stress test, 
\emph on
call sequence
\emph default
 is stored too.
\end_layout

\begin_layout Standard

\series bold
Reporting
\series default
 of classic tests are handled by 
\emph on
ZfsReportPlugin
\emph default
 which creates 
\emph on
TestRun
\emph default
 object with appropriate parameters and commits it to 
\emph on
TestResultStorage
\emph default
.
 If test has failed, ZfsReportPlugin will append failure data (
\emph on
snapshot, backtrace, exception
\emph default
) to 
\emph on
TestRunData
\emph default
.
 Stress tests are handled and reported by 
\emph on
ZfsStressGenerator
\emph default
 plugin.
 This special case is separated to prevent multiple reports of the same
 call sequence.
\end_layout

\begin_layout Standard
After 
\series bold
stress test
\series default
 fails, 
\emph on
ZfsStressGenrator
\emph default
 can try to 
\series bold
prune
\series default
 the call sequence and put it back to test queue.
 This is done only given number of times, then the last failure (some pruned
 sequences may not fail) is stored by ZfsStressGenerator to 
\series bold
saved path
\series default
 file.
\end_layout

\begin_layout Standard
When all tests have run, control is passed to 
\series bold
nose wrapper
\series default
, which 
\series bold
finalizes BatchRun
\series default
 - sets it's duration and result.
 If there is exception, that is not handled in nose, it is caught by wrapper
 and reported as system failure in current BatchRun.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Chapter
Conclusion
\end_layout

\begin_layout Standard
Goal of this thesis was to extend existing ZlomekFS implementation and to
 implement regression testing framework which would fit it's special needs.
 After exploration of ZlomekFS, there were clear need of logging facility
 and remote state discovery to allow reliable testing.
 From research done on related projects, it was decided to create new logger
 and made status information available through d-bus.
\end_layout

\begin_layout Standard
As basic regression testing framework, existing solution (Nose) was used.
 It was extended by plugins to support new types of tests and to provide
 required features.
\end_layout

\begin_layout Standard
Under it, prototypes of tests are created.
 First type of tests identifies problems of filesystem by performing operations
 on second, reliable, filesystem and comparing results.
 Second test type identifies errors by checking, if behavior of filesystem
 is as expected (data read is the same as written, ...).
\end_layout

\begin_layout Standard
By plugin, possibility to generate random workload to filesystem is provided.
 This plugin can be constrained to generate valid sequences of operations
 only.
 Plugin can prune sequence to find minimal sequence needed to reproduce
 the error.
 
\end_layout

\begin_layout Standard
Snapshoting plugin offer chance to have as much state information and trace
 protocol as possible to ease debugging of the problem which have caused
 the problem.
 Current implementation provides core dump of daemon, log files, sequence
 which have caused the error, cache content, comparison file system (if
 used) snapshot, and python component state.
 Snapshot plugin can include most of possible data types that can be required
 when debugging, thus tester can easily define other data to include to
 snapshots.
\end_layout

\begin_layout Standard
Currently, change of network conditions is possible only by inserting special
 rules into iptables.
 The change of network conditions is mainly aimed to check behavior in disconnec
ted of slowly connected state.
 For future, there is d-bus interface prepared, to allow direct change of
 ZlomekFS state without changing network conditions (which could be useful
 in real usage too).
 When there will be need to provide network protocol robustness testing,
 it will need use of sophisticated external tool which is beyond scope of
 this thesis.
\end_layout

\begin_layout Standard
It is possible to use this system for testing of any other filesystem.
 Especially in case of userspace based filesystem the modification needed
 will be only change of daemon binary and settings (which will be obviously
 different).
 If filesystem will have kernel component (especially in case of full kernel
 based filesystems) there will be need of 
\emph on
kdump
\emph default
 integration for snapshoting state of filesystem in case of failure.
 According our information it is currently the only project for testing
 filesystem capable of storing step sequence for reproducing error and snapshoti
ng state of filesystem.
 
\end_layout

\begin_layout Standard
For unit testing of small parts of code (whitebox testing), small library
 for C were written.
 This library called Zen-unit has very intuitive interface, but what is
 special about it is, that it has automatic test discovery.
 This allows thing common in scripting languages, but rare in compiled ones:
 to write tests anywhere in code without listing them in some central block.
\end_layout

\begin_layout Standard
Developer documentation for C code was written in DoxyGen and there are
 build target for generating HTML documentation available (moreover RPM
 packages with documentation can be build too).
 For python we use language provided __doc__ attributes with predefined
 syntax.
\end_layout

\begin_layout Standard
TODO:real usage - we found some bugs (size, deadlock)
\end_layout

\begin_layout Chapter
Appendix
\end_layout

\begin_layout Section
Coding conventions
\end_layout

\begin_layout Subsection*
C based code
\end_layout

\begin_layout Standard
For code in C, original formatting from ZlomekFS was adopted.
\end_layout

\begin_layout Standard

\series bold
Identifiers
\series default
 ah are in lower case, words separated by underscore.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset

uint32_t log_level;
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Defines
\series default
 (macros) are in upper case, words separated by underscore.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset

#define MY_MACRO_CONSTANT 5
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Typedef
\series default
s
\series bold
 
\series default
are in lower case with suffix 
\emph on
_t
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset

typedef uint32_t fibheapkey_t;
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Braces around code block
\series default
 should be on new lines, indentation level as previous code.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
syp_error set_log_level (logger target, log_level_t level) 
\end_layout

\begin_layout Standard
{ 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
target->log_level = level;
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
return NOERR; 
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Braces around function arguments
\series default
 should be separated from function name by one space, if argument list is
 multiline, ending brace should be right after last argument (on same line).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
syp_error send_uint32_by_function (uint32_t data, 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
syp_error (*function)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
(int, uint32_t, const struct sockaddr *, socklen_t),
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
const char * ip, uint16_t port);
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I
\series bold
ndentation
\series default
 should be two spaces per level.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
syp_error dbus_disconnect(DBusConnection ** connection) 
\end_layout

\begin_layout Standard
{
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
if (connection == NULL)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
return ERR_BAD_PARAMS; 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
if (*connection == NULL) 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
return ERR_NOT_INITIALIZED;
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
dbus_bus_release_name (*connection, 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
SYPLOG_DEFAULT_DBUS_SOURCE, NULL);
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
dbus_connection_unref(*connection);
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
*connection = NULL;
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
return NOERR; 
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Operators 
\series default
should be separated from arguments by one space on both sides.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset

file_position\InsetSpace ~
+=\InsetSpace ~
bytes_written;
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Comments 
\series default
have one space between comment mark and comment text.
 They are on line before code they are describing.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
/*!\InsetSpace ~
Structure holding logger state and configuration.\InsetSpace ~
*/
\end_layout

\begin_layout Standard
typedef struct logger_def 
\end_layout

\begin_layout Standard
{ 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
///\InsetSpace ~
input - output medium definition struct
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
struct medium_def printer;
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
File names 
\series default
consisting from more words should have dash between words.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset

control-protocol.h
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Python code
\end_layout

\begin_layout Standard
For code in python, formatting from Nose 
\begin_inset LatexCommand cite
key "Nose"

\end_inset

 was adopted.
\end_layout

\begin_layout Standard

\series bold
Identifiers
\series default
 ah are in CamelCase, class names with first letter in upper case, instance
 names with first letter in lower case.
\end_layout

\begin_layout Standard
I
\series bold
ndentation
\series default
 should be four spaces per level.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
class DependencyGraph(object):
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
graph = None 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
currentNode = None 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
randomGenerator = SystemRandom()
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
def equals(self, graph):
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
return self.graph == graph.graph and 
\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
self.currentNode == graph.currentNode 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
def initRandomStartNode(self): 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
self.restart(self.randomGenerator.choice(self.graph.keys()))
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Braces around function arguments
\series default
 should be right after function name.
 
\end_layout

\begin_layout Standard

\series bold
Arguments
\series default
 should be separated by one space.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
def testLocal(self,\InsetSpace ~
empty):
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
assert self.buildGraphsAndCompare(reference = self.nonUniformGraph,
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
buildMethod = GraphBuilder.USE_LOCAL,
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
methods = self.nonUniformMethods)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Operators 
\series default
should be separated from arguments by one space on both sides.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset

file_position\InsetSpace ~
+=\InsetSpace ~
bytes_written;
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Documentation comments 
\series default
should have one space between comment mark and comment text.
 They should be on line after element they are describing.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
def isMetaClass (self, cls):
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
"""\InsetSpace ~
Tests if class is meta class (should contain meta tests)
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
:Parameters:
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
cls: class object to check
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
:Return: 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
True if is metaclass, False otherwise
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
"""
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Code comments
\series default
 should have one space between comment mark and comment text.
 They should be on line before code they are describing.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
def countNiceElements(list):
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
""" Count elements which are nice :) """
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
count = 0
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
for element in list:
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
if isNice(element):
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
count += 1
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~

\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
return count
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Installation
\end_layout

\begin_layout Standard
This guide is based on new Fedora 8 installation, installation to other
 systems may be different.
 In example, we have buildmaster on IP 192.168.16.253, buildslave on IP 192.168.16.252
 and development system on IP 192.168.16.128.
 We assume that buildslave has basic development packages (such as gcc)
 installed.
\end_layout

\begin_layout Subsection
Buildmaster
\end_layout

\begin_layout Standard
Create user account under which buildbot will run on buildmaster.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset

useradd -d /home/buildmaster -s /bin/bash buildmaster
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then, install external packages and tools.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
yum install buildbot python-sqlite2 mysql-server\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
MySQL-python screen
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Install TestResultStorage.
 Django in version version 0.97 (pre) is required.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset

rpm -ivh python-django-snapshot-*.rpm TestResultStorage-*.rpm
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Set mysql to start on boot and start it.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
/sbin/chkconfig mysqld on
\end_layout

\begin_layout Standard
/etc/init.d/mysqld start
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Change root password for mysql.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
/usr/bin/mysqladmin -u root password 'secret'
\end_layout

\begin_layout Standard
/usr/bin/mysqladmin -u root -h 192.168.16.253 password 'secret'
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Create database for TestResultStorage.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
echo '
\end_layout

\begin_layout Standard
CREATE DATABASE trs character set utf8;
\end_layout

\begin_layout Standard
GRANT all ON trs.* TO nose@localhost IDENTIFIED BY 'secret';
\end_layout

\begin_layout Standard
GRANT all ON trs.* TO nose@192.168.16.252 IDENTIFIED BY 'secret';
\end_layout

\begin_layout Standard
GRANT all ON trs.* TO nose@192.168.16.128 IDENTIFIED BY 'secret';
\end_layout

\begin_layout Standard
FLUSH PRIVILEGES;
\end_layout

\begin_layout Standard
'| mysql --user=root --password=secret
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Setup TestResultStorage to use local mysql database with right credentials
 (
\begin_inset LatexCommand prettyref
reference "fig:settings_py_master"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
DATABASE_ENGINE = 'mysql' 
\end_layout

\begin_layout Standard
DATABASE_NAME = 'trs'
\end_layout

\begin_layout Standard
DATABASE_USER = 'nose'
\end_layout

\begin_layout Standard
DATABASE_PASSWORD = 'secret' 
\end_layout

\begin_layout Standard
DATABASE_HOST = 'localhost'
\end_layout

\begin_layout Standard
DATABASE_PORT = '' 
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:settings_py_master"

\end_inset


\begin_inset Caption

\begin_layout Standard
TestResultStorage/settings.py (buildmaster)
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Create TestResultStorage tables.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
cd /usr/lib/python2.5/site-packages/TestResultStorage
\end_layout

\begin_layout Standard
python manage.py syncdb
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Checkout (export) buildmaster's configuration
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
su buildmaster
\end_layout

\begin_layout Standard
cd /home/buildmaster
\end_layout

\begin_layout Standard
svn export\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
http://shiva.ms.mff.cuni.cz/svn/zzzzzfs/branches/zouhar/buildbot/buildmaster\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
zlomekfs
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Setup buildmaster to allow client connections and to start www server on
 right port (
\begin_inset LatexCommand prettyref
reference "fig:master_cfg"

\end_inset

, 
\begin_inset LatexCommand prettyref
reference "fig:buildbot_tac_master"

\end_inset

).
 Note that if svn url or branching schema changes, they should be tweaked
 too.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
WAIT_BEFORE_BUILD = 1
\newline

\end_layout

\begin_layout Standard
c['slaves'] = [BuildSlave("bug", "secret"),
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
BuildSlave("zen", "secret")]
\end_layout

\begin_layout Standard
c['slavePortnum'] = "tcp:9989"
\newline

\end_layout

\begin_layout Standard
c['projectName'] = 'ZlomekFS'
\end_layout

\begin_layout Standard
c['projectURL'] = 'http://dsrg.mff.cuni.cz/~ceres/prj/zlomekFS'
\newline

\end_layout

\begin_layout Standard
c['buildbotURL'] = 'http://192.168.16.253:8010'
\newline

\end_layout

\begin_layout Standard
svnurl = 'https://shiva.ms.mff.cuni.cz/svn/zzzzzfs'
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:master_cfg"

\end_inset


\begin_inset Caption

\begin_layout Standard
master.cfg
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
basedir = r'/home/buildmaster/zlomekfs'
\end_layout

\begin_layout Standard
configfile = r'master.cfg' 
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:buildbot_tac_master"

\end_inset


\begin_inset Caption

\begin_layout Standard
buildbot.tac (master)
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Set buildbot to start on boot, for example by adding crontab entry (
\begin_inset LatexCommand prettyref
reference "fig:buildmaster_cron"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
@reboot make start -C /home/buildmaster/zlomekfs
\end_layout

\begin_layout Standard
@reboot screen -d -m -S\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
TestResultStorage python\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
/usr/lib/python2.5/site-packages/TestResultStorage/manage.py\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
runserver 192.168.16.253:8020 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:buildmaster_cron"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
buildmaster.cron
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Start buildmaster.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset

make start -C /home/buildmaster/zlomekfs 
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Open ports 3306, 8010, 9989 (or other, if setting in master.cfg is different)
 on firewall.
 Rules below are only examples, they should be pernament (for example written
 in /etc/sysconfig/iptables).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
/sbin/iptables -A RH-Firewall-1-INPUT -m state --state NEW\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
-m tcp -p tcp --dport 8010 -j ACCEPT
\end_layout

\begin_layout Standard
/sbin/iptables -A RH-Firewall-1-INPUT -m state --state NEW\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
-m tcp -p tcp --dport 9989 -j ACCEPT
\end_layout

\begin_layout Standard
/sbin/iptables -A RH-Firewall-1-INPUT -m state --state NEW\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
-m tcp -p tcp --dport 3306 --source 192.168.16.0/24 -j ACCEPT
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is all except for file transfers.
 If you want to use nfs for file transfers, read nfs configuration below.
\end_layout

\begin_layout Standard
Set data directory to be exported (
\begin_inset LatexCommand ref
reference "fig:exports"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
/var/lib/TestResultStorage/data 
\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
192.168.16.252(fsid=0,rw,root_squash,sync)\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
192.168.16.128(fsid=0,rw,root_squash,sync)
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:exports"

\end_inset


\begin_inset Caption

\begin_layout Standard
/etc/exports
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Tell portmap to allow connections to services (
\begin_inset LatexCommand ref
reference "fig:hosts_allow"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
portmap: 192.168.16.128 , 192.168.16.252
\end_layout

\begin_layout Standard
lockd: 192.168.16.128 , 192.168.16.252
\end_layout

\begin_layout Standard
rquotad: 192.168.16.128 , 192.168.16.252
\end_layout

\begin_layout Standard
mountd: 192.168.16.128 , 192.168.16.252
\end_layout

\begin_layout Standard
statd: 192.168.16.128 , 192.168.16.252
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:hosts_allow"

\end_inset


\begin_inset Caption

\begin_layout Standard
/etc/hosts.allow
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Set mount daemon to use specific port - needed for firewall settings (
\begin_inset LatexCommand ref
reference "fig:sysconfig_nfs"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
MOUNTD_PORT=32773
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:sysconfig_nfs"

\end_inset


\begin_inset Caption

\begin_layout Standard
/etc/sysconfig/nfs
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Open ports on firewall.
 Note that you must make this rules pernament for example through 
\emph on
system-config-firewall
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
/sbin/iptables -A RH-Firewall-1-INPUT -m state --state NEW\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
-m tcp -p tcp --dport 2049 -j ACCEPT
\end_layout

\begin_layout Standard
/sbin/iptables -A RH-Firewall-1-INPUT -m state --state NEW\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
-m udp -p udp --dport 2049 -j ACCEPT
\end_layout

\begin_layout Standard
/sbin/iptables -A RH-Firewall-1-INPUT -m state --state NEW\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
-m tcp -p tcp --dport 111 -j ACCEPT
\end_layout

\begin_layout Standard
/sbin/iptables -A RH-Firewall-1-INPUT -m state --state NEW\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
-m udp -p udp --dport 111 -j ACCEPT
\end_layout

\begin_layout Standard
/sbin/iptables -A RH-Firewall-1-INPUT -m state --state NEW\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
-m udp -p udp --dport 32773 -j ACCEPT
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Run nfs and make it start upon boot.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
/sbin/service nfs start
\end_layout

\begin_layout Standard
/sbin/chkconfig nfs on
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Buildslave
\begin_inset LatexCommand label
name "sub:Buildslave"

\end_inset


\end_layout

\begin_layout Standard
First install required packages.
 Note that not all are available from Fedora repositories.
 For i386 and x86_64 architecture they can be found on thesis cd.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
yum install buildbot python-sqlite2 MySQL-python kernel-devel\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
dbus dbus-devel libtool autoconf automake gettext gettext-devel\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
python-setuptools python-nose pyflakes
\end_layout

\begin_layout Standard
rpm -ivh python-django-snapshot-*.rpm\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
TestResultStorage-*.rpm py25_pysvn_svn144-*.rpm
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Install packages from all components.
 This can be skipped, but when further builds will go in wrong order, dependency
 problems could arrive.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
rpm -ivh zen-unit-*.rpm syplog-*.rpm pysyplog-*.rpm\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
zlomekfs-*.rpm zfsd-status-*.rpm TestResultStorage-*.rpm\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
insecticide-*.rpm
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Restart D-bus to use new configuration (allow syplog and zfsd communication).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
/etc/init.d/messagebus restart
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Change TestResultStorage settings to store results on buildmaster (
\begin_inset LatexCommand ref
reference "fig:settings_py_slave"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
DATABASE_ENGINE = 'mysql' 
\end_layout

\begin_layout Standard
DATABASE_NAME = 'trs'
\end_layout

\begin_layout Standard
DATABASE_USER = 'nose'
\end_layout

\begin_layout Standard
DATABASE_PASSWORD = 'secret' 
\end_layout

\begin_layout Standard
DATABASE_HOST = '192.168.16.253'
\end_layout

\begin_layout Standard
DATABASE_PORT = ''3306'
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:settings_py_slave"

\end_inset


\begin_inset Caption

\begin_layout Standard
TestResultStorage/settings.py (buildslave)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you use nfs for file transfers, set nfs mount (
\begin_inset LatexCommand ref
reference "fig:fstab"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
192.168.16.253:/var/lib/TestResultStorage/data\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
/var/lib/TestResultStorage/data nfs defaults 0 0 
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:fstab"

\end_inset


\begin_inset Caption

\begin_layout Standard
/etc/fstab
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Create directory for builds and fetch config.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
mkdir -p /var/buildbot
\end_layout

\begin_layout Standard
cd /var/buildbot
\end_layout

\begin_layout Standard
svn export\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
https://shiva.ms.mff.cuni.cz/svn/zzzzzfs/branches/zouhar/buildbot/buildslave\InsetSpace ~

\backslash

\end_layout

\begin_layout Standard
\InsetSpace ~
zlomekfs
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Change buildbot configuration to connect to master and use actual credentials
 (
\begin_inset LatexCommand ref
reference "fig:buildbot_tac_slave"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
basedir = r'/var/buildbot/zlomekfs'
\end_layout

\begin_layout Standard
buildmaster_host = '192.168.16.253'
\end_layout

\begin_layout Standard
port = 9989
\end_layout

\begin_layout Standard
slavename = 'zen'
\end_layout

\begin_layout Standard
passwd = 'secret'
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:buildbot_tac_slave"

\end_inset


\begin_inset Caption

\begin_layout Standard
buildbot.tac (slave)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Configure buildbot to start on boot (for example via crontab 
\begin_inset LatexCommand ref
reference "fig:buildslave_cron"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
@reboot buildbot start /var/buildbot/zlomekfs 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:buildslave_cron"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
buildslave.cron
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Start buildbot
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
buildbot start /var/buildbot/zlomekfs
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{codeblock}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Development system
\end_layout

\begin_layout Standard
When installing on development system without need of automatic builds,
 just install required packages and build projects in correct order.
\end_layout

\begin_layout Standard
For testing all components except ZlomekFS can be tested without install
 (make test).
 The reason why this is not possible for ZlomekFS is need of fuse build,
 which is integrated and needs to create device links, install kernel modules
 etc.
\end_layout

\begin_layout Standard
If you want environment as close to buildslave as possible, you can install
 your system in the same way as is described in 
\begin_inset LatexCommand prettyref
reference "sub:Buildslave"

\end_inset

.
 But even in this case development should be done without buildbot checkouts.
 Changing buildbot checkouts could lead into conflicts upon automatic builds.
 
\end_layout

\begin_layout Standard
To not spoil central TestResultRepository with your builds you enable out
 your own TestResultRepository on local machine (create mysql database)
 and report into it.
 This should be done in case of slow connection to master too.
 Running automatic tests without ZfsReportPlugin is discouraged - there
 would be little backtrace provided in that case.
\end_layout

\begin_layout Section
Sample session
\end_layout

\begin_layout Section
Enclosed CD
\end_layout

\begin_layout Standard
\begin_inset LatexCommand bibtex
options "plain"
bibfiles "references"

\end_inset


\end_layout

\end_body
\end_document
